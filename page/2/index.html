
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Rocky for Everything</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Rocky ZhouJin QQ987415811">
    

    
    <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">

    
    <link rel="alternative" href="/atom.xml" title="Rocky for Everything" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Rocky for Everything" title="Rocky for Everything"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Rocky for Everything">Rocky for Everything</a></h1>
				<h2 class="blog-motto">慢慢喜欢你</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/" title="Dubbo系列之Dubbo可扩展性SPI" itemprop="url">Dubbo系列之Dubbo可扩展性SPI</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-03T02:07:36.000Z" itemprop="datePublished"> Published 2018-09-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-Dubbo扩展机制"><a href="#1-Dubbo扩展机制" class="headerlink" title="1. Dubbo扩展机制"></a>1. Dubbo扩展机制</h2><ul>
<li>任何系统都是从小系统不断完善的，应当关注当下的需求，然后不断对系统进行迭代。</li>
<li>代码层面，需要适当的对关注点进行抽象和隔离，在不断添加和特性时，仍然能保持良好的结构和可维护性，同时允许第三方开发者对其功能及进程扩展。</li>
<li>对扩展性的追求甚至超过了性能。</li>
<li>良好的扩展性<ul>
<li>作为框架的维护这，在添加新功能的时候，只需要添加一些新的代码，而不用大量修改现有代码，符合开闭原则</li>
<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架源码，在自己工程中添加代码即可。<h2 id="2-可扩展的集中解决方案"><a href="#2-可扩展的集中解决方案" class="headerlink" title="2. 可扩展的集中解决方案"></a>2. 可扩展的集中解决方案</h2></li>
</ul>
</li>
<li>通常有：<ul>
<li>Factory模式</li>
<li>IoC容器</li>
<li>OSGI容器</li>
</ul>
</li>
<li>Dubbo参考了Java原生的SPI机制，并进行一定扩展，以满足Dubbo需求。<h2 id="3-Java-SPI机制"><a href="#3-Java-SPI机制" class="headerlink" title="3. Java SPI机制"></a>3. Java SPI机制</h2></li>
</ul>
<ol>
<li>Java SPI(Service Provider Interface)是JDK一种动态加载扩展点的实现。</li>
<li>在ClassPath的META-INF/services目录下放置一个接口同名的文本文件，内容为接口的实现类，多个实现类用换行符分割。</li>
<li>缺点：<ul>
<li>需要遍历所有的实现，并实例化，然后才能在循环中找到我们需要的实现。</li>
<li>配置文件中只是需要简单的列出所有扩展实现，没有命名，很难定位。</li>
<li>扩展如果依赖其他扩展就做不到自动注入和装配。</li>
<li>不提供类似于Spring IOC和AOP功能。</li>
<li>很难和其他框架集成。<h2 id="4-Dubbo扩展点机制"><a href="#4-Dubbo扩展点机制" class="headerlink" title="4. Dubbo扩展点机制"></a>4. Dubbo扩展点机制</h2></li>
</ul>
</li>
<li>扩展点—Java接口</li>
<li>扩展—扩展点的实现类</li>
<li>扩展实例—扩展点实现类的实例</li>
<li>扩展自适应实例—扩展代理类</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Dubbo-SPI/">Dubbo SPI</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/29/微服务系列之深入理解SpringCloud与微服务构建/" title="微服务系列之深入理解SpringCloud与微服务构建" itemprop="url">微服务系列之深入理解SpringCloud与微服务构建</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-29T08:25:35.000Z" itemprop="datePublished"> Published 2018-08-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><ol>
<li>系统的架构决定了系统能否满足业务，技术，组织，灵活，可扩展性等多种要求，同时肩负起了解放程序员生产力的作用。</li>
<li>微服务框架:服务注册和发现===Eureka组件，负载均衡Ribbon组件，熔断器Hystrix组件，路由网关Zuul组件，SpringCloud配置中心，服务链路追踪等内容。</li>
<li>微服务提出者Martin Fowler<h2 id="第2章-SpringCloud简介"><a href="#第2章-SpringCloud简介" class="headerlink" title="第2章 SpringCloud简介"></a>第2章 SpringCloud简介</h2><h3 id="2-1-微服务应该具备的功能"><a href="#2-1-微服务应该具备的功能" class="headerlink" title="2.1 微服务应该具备的功能"></a>2.1 微服务应该具备的功能</h3></li>
<li>服务:一个独立运行的单元组件，每个单元组件运行在独立的进程中，组件与组件之间通常使用HTTP的通信机制进行通信。</li>
<li>微服务的特点:<ol>
<li>按照业务来划分服务，单个服务代码量小，业务单一，易于维护；</li>
<li>每个微服务都有自己独立的基础组件，如数据库，缓存，且运行在独立的进程中；</li>
<li>微服务之间的通信通过Http协议或者消息组件，且具有容错能力；</li>
<li>微服务有一套服务治理的解决方案，服务之间不耦合，可以随时加入和剔除服务；</li>
<li>单个微服务能够集群化部署，并且负载均衡能力；</li>
<li>整个微服务系统有一个完整的安全机制，包括用户验证，权限验证，资源保护等；</li>
<li>链路追踪的能力；</li>
<li>完整的实时日志系统。<h3 id="2-1-1-服务的注册与发现"><a href="#2-1-1-服务的注册与发现" class="headerlink" title="2.1.1 服务的注册与发现"></a>2.1.1 服务的注册与发现</h3></li>
</ol>
</li>
</ol>
<ul>
<li>服务粒度小，服务数量众多，服务之间相互依赖成网状，需要服务注册中心来同一管理微服务实例，方便查看每一个微服务实例的健康状态。</li>
<li>服务注册是指向服务注册中心注册一个服务实例，服务提供者将自己的服务信息(如服务名，IP地址等)告知服务注册中心。</li>
<li>服务发现是指当服务消费者需要消费另一个服务时，服务注册中心能够告知服务消费者它所要消费服务的实例信息（服务名，IP地址等）。</li>
<li>通常一个服务既是服务提供者也是服务消费者，使用Http协议或者消息组件进行服务费。</li>
<li>注册中心会提供服务的健康检查方案，检查被注册的服务是否可用。通常实例注册后，会定时向服务注册中心提供心跳，以表明自己还处于可用状态。当一个服务实例停止向服务注册中心提供心跳一段时间后，服务注册中心会认为该服务实例不可用，将会从服务注册列表中剔除。</li>
<li>如果这个被剔除掉的服务实例过一段时间重新加入服务器注册中心列表中，就重新恢复心跳。</li>
<li>微服务的服务注册组件都回提供服务的健康状况查看UI界面，通过界面可以指导服务的健康状态。<h3 id="2-1-2-服务的负载均衡"><a href="#2-1-2-服务的负载均衡" class="headerlink" title="2.1.2 服务的负载均衡"></a>2.1.2 服务的负载均衡</h3></li>
<li>微服务架构中，服务之间相互调用通过http通信协议来实现。网络往往不可靠，为了保证高可用，服务单元往往需要集群化部署。===&gt;引发负载均衡</li>
<li>服务消费者集成了负载均衡组件，该组件回向服务消费者提供获取的服务注册列表，并隔一段时间重新刷新该列表。</li>
<li>注册中心集群化。<h4 id="2-1-3-集群的容错"><a href="#2-1-3-集群的容错" class="headerlink" title="2.1.3 集群的容错"></a>2.1.3 集群的容错</h4></li>
<li>部分服务不可用，引发阻塞，消耗系统资源，引发雪崩。</li>
<li>解决方案：熔断机制<ol>
<li>当一个服务处理用户请求失败次数小于设定的阈值时，熔断器处于关闭状态，服务正常</li>
<li>当失败次数大于设定阈值时，说明服务出现了故障，打开熔断器，所有该服务的请求会执行快速失败，不执行业务逻辑。</li>
<li>当处于打开状态的熔断器时，一段时间后会处于半打开状态，并执行一定数量的请求，剩余的请求会执行快速失败，如果执行请求失败，则继续打开熔断器；若成功了，则将熔断器关闭。 </li>
</ol>
</li>
<li>熔断器的附加功能：<ol>
<li>将资源隔离，如果某个API出现故障，将该API隔离，不会影响其他API接口。被隔离的API接口会执行快速失败的逻辑，不会等待，请求不会阻塞。</li>
<li>服务降级功能。当服务处于正常状态时，大量请求在短时间内同时涌入，超过了服务的处理能力，这是熔断器打开可以将服务降级，以免服务器因负载过高而出现故障。</li>
<li>自我修复能力。比如网络短时间内不可用，熔断器被打开。如果不能自我监控，自我检测和自我修复，那么需要开发人员手动去关闭熔断器，会增加开发工作量。</li>
<li>Netfix的Hystrix熔断器组件功能非常强大，有熔断器功能，熔断器状态检测，UI，开发人员或者运维人员通过UI界面能够直观看到熔断器的状态和各种性能指标。<h4 id="2-1-4-服务网关"><a href="#2-1-4-服务网关" class="headerlink" title="2.1.4 服务网关"></a>2.1.4 服务网关</h4></li>
<li>微服务系统通过将资源以API接口的形式暴露给外界来提供服务。API接口资源通常是由服务网关统一暴露，内部服务不直接对外提供API资源暴露，将内部服务隐藏。</li>
<li>API网关通常有请求转发的作用，可能需要负责一定的安全验证，如请求是否合法，对某一资源是否具有操作权限等。</li>
<li>通常网关层以集群形式存在，在服务网关层之前，会加上负载均衡层，通常为nginx双机热备，通过一定路由策略，将请求转发到网管层。</li>
<li>到达网关层后，经过一系列用户身份验证，权限判断，最终转发到具体的服务。</li>
<li>服务经过一些列的逻辑运算和数据操作，最终将结果返回给用户。</li>
<li>网关层的意义：<ol>
<li>网关将所有的API接口资源统一聚合，对外统一暴露，外界系统调用的API接口都是网关对外暴露的API接口。</li>
<li>身份认证，权限认证，防止非法请求操作API接口，对内部服务起保护作用。</li>
<li>网关可以实现监控功能，实时日志输出，对请求进行记录。</li>
<li>网关可以用来做流控，在流量情况下，对服务进行降级。</li>
<li>API接口从内部服务分离出来，方便测试。<h4 id="2-1-5-服务配置的统一管理"><a href="#2-1-5-服务配置的统一管理" class="headerlink" title="2.1.5 服务配置的统一管理"></a>2.1.5 服务配置的统一管理</h4></li>
</ol>
</li>
<li>数据库配置，日志是输出级别配置，不同环境不一样，管理复杂。</li>
<li>SpringCloud的Config组件，阿里Diamond，百度Disconf，携程Apollo等。</li>
<li>大致过程：<ol>
<li>Config Server读取配置文件仓库的配置信息，其中配置文件存放在配置服务的本地仓库，也可以放在远程Git仓库。</li>
<li>配置服务启动后，读取配置文件信息，读取完成配置信息存放在配置服务的内存中。</li>
<li>当启动服务A,B是，由于服务A，B指定了向配置服务读取配置信息，服务A，B向配置服务读取配置信息。</li>
<li>当服务配置信息需要修改且修改完成后，向配置服务发送Post请求进行刷新，这时服务A,B会向配置服务重写读取配置文件。<h4 id="2-1-6-服务链路追踪"><a href="#2-1-6-服务链路追踪" class="headerlink" title="2.1.6 服务链路追踪"></a>2.1.6 服务链路追踪</h4></li>
</ol>
</li>
<li>服务单元数量多且复杂，服务与服务之间的调用非常复杂，出现异常和错误很难追踪；</li>
<li>实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序，使得每个请求链路清晰可见，方便问题定位。<h3 id="2-2-Sprin-Cloud"><a href="#2-2-Sprin-Cloud" class="headerlink" title="2.2 Sprin Cloud"></a>2.2 Sprin Cloud</h3></li>
<li>基于SpringBoot—&gt;简化开发和部署的过程，简化Spring复杂的配置和依赖管理；</li>
<li>通过起步依赖和内置Servlet容器就能快速搭建起一个Web工程。 </li>
<li>SpringCloud首要目标是通过一些列开发组件和框架，快速搭建分布式微服务系统。<h4 id="2-2-1-常用组件"><a href="#2-2-1-常用组件" class="headerlink" title="2.2.1 常用组件"></a>2.2.1 常用组件</h4><h3 id="2-3-Dubbo"><a href="#2-3-Dubbo" class="headerlink" title="2.3 Dubbo"></a>2.3 Dubbo</h3></li>
<li>RPC调用:封装了长连接NIO框架，采用多线程模式；</li>
<li>集群容错：提供了基于接口方法的远程调用功能。集群容错:实现了负载均衡，失败容错；服务发现:集成了Zookeeper,用于服务注册和发现。</li>
<li>SpringCloud通信方式基于http restful风格，服务与服务之间五耦合，无状态，语言平台普适。</li>
<li>Dubbo基于远程调用，对接口平台和语言有强依赖。跨平台调用更需要额外依赖。 <h3 id="2-4-Kubernetes简介"><a href="#2-4-Kubernetes简介" class="headerlink" title="2.4 Kubernetes简介"></a>2.4 Kubernetes简介</h3>1.Kubernetes是一个容器集群管理系统，为容器化的应用程序提供部署运行，维护，扩展，资源调度，服务发现等功能呢。</li>
</ol>
</li>
</ul>
<h2 id="3-构建微服务的准备"><a href="#3-构建微服务的准备" class="headerlink" title="3.构建微服务的准备"></a>3.构建微服务的准备</h2><h3 id="3-3-构建啊工具Maven使用"><a href="#3-3-构建啊工具Maven使用" class="headerlink" title="3.3 构建啊工具Maven使用"></a>3.3 构建啊工具Maven使用</h3><pre><code>1. 基于工程对象模型，Maven可以管理项目构建整个生命周期，包括清理，编译，打包，测试等环节。
2. 构建一个项目需要的流程：
    1. 生成源码； 2. 从源码中生存文档；3.编译源码；4.测试；5.将源码打包成Jar,运行在服务器，仓库或者其他位置。
</code></pre><h4 id="3-3-1-Maven核心概念"><a href="#3-3-1-Maven核心概念" class="headerlink" title="3.3.1 Maven核心概念"></a>3.3.1 Maven核心概念</h4><pre><code>1. 核心是pom文件，pom文件以及xml文件的形式表示的资源，依赖jar,插件，构建文件等。
2. 工作过程：
    1. Maven 读取pom文件，构建的生命周期各阶段和目标；
    2. 依赖---&gt;Maven本地仓库；
    3. 构建插件
    4. 构建Profile
3. 首先读取pom文件，pom文件时Maven核心，所有的项目依赖，插件都在pom文件中统一管理。
4. 下载依赖jar到本地仓库。Maven命令执行时，首先会检查pom文件的依赖jar，当检测本地没有安装jar时，会默认Maven的中央仓库下载依赖Jar，中央仓库地址为:/.
5. 依赖下载后，会存放在本地仓库中，如果下载不成功，该命令无法执行通过。
6. 执行构建的生命周期。Maven的构建过程会被分解成构建阶段和构建目标，共同构成了Maven的生命周期。
7. 执行构建插件。插件可以更方便地执行构建各个阶段，可以用插件实现一些额外功能。
</code></pre><h4 id="3-3-2-编写Pom文件"><a href="#3-3-2-编写Pom文件" class="headerlink" title="3.3.2 编写Pom文件"></a>3.3.2 编写Pom文件</h4><pre><code>1. pom文件是一个xml文件，用于描述项目用到的资源，项目依赖，插件，代码位置等信息。
2. pom.xml文件一般放在根目录。
</code></pre><h4 id="3-3-3-Maven构建项目的生命周期"><a href="#3-3-3-Maven构建项目的生命周期" class="headerlink" title="3.3.3 Maven构建项目的生命周期"></a>3.3.3 Maven构建项目的生命周期</h4><pre><code>1. Maven工程中，默认定义了构建工程的生命周期，本身集成了这些插件。
2. validate initialize compile test package verify install deploy
</code></pre><h4 id="3-3-4-常用Maven命令"><a href="#3-3-4-常用Maven命令" class="headerlink" title="3.3.4 常用Maven命令"></a>3.3.4 常用Maven命令</h4><pre><code>1. mvn clean 删除工程target下所有文件；
2. mvn package将工程打为jar包
3. 上述由一些列命令构成：
    1. 验证verify
    2. 编译compile
    3. 处理代码
    4. 生成资源文件
    5. 生成Jar包
    6. 测试
4. mvn package -Dmaven.test.ship=ture，打包跳过测试；
5. mvn compile 编译代码工程，不生成jar包；
6. mvn install 包含了mvn package的所有过程，并且将生成的jar包安装到本地仓库。
7. mvn spring-boot:run 使用spring-boot插件，启动Springboot工程；
8. mvn test 测试；
9. mvn idea:idea 生成idea项目
10. mvn mvnLjar只打jar包
11. mvn vaildate 检验资源是否可用。
</code></pre><h2 id="4-Spring-Boot"><a href="#4-Spring-Boot" class="headerlink" title="4.Spring Boot"></a>4.Spring Boot</h2><pre><code>1. 特点：自动配置，起步依赖，Actuator对运行状态的监控。
2. 安全，度量，监控检查，内嵌Servlet容器，外置设置
</code></pre><h3 id="4-1-构建SpringBoot项目"><a href="#4-1-构建SpringBoot项目" class="headerlink" title="4.1 构建SpringBoot项目"></a>4.1 构建SpringBoot项目</h3><pre><code>1. @SpringBootApplication注解包含了@SpringBootConfiguration,@EnableAutoConfiguration和@    ComponentScan，开启包扫描配置和自动配置的功能；
2. @RestController = @Controller + @ResponseBody；
3. @RequestMapping = 配置请求地址的Url映射； 
4. 测试:
    1. @RunWith(SpringRunner.class) 和 SpringBootTest注解。
    2. @SpringBootTest注解加上Web测试环境的端口为随机端口的配置 
</code></pre><h3 id="4-2-SpringBoot-配置文件详解"><a href="#4-2-SpringBoot-配置文件详解" class="headerlink" title="4.2 SpringBoot 配置文件详解"></a>4.2 SpringBoot 配置文件详解</h3><h4 id="4-2-1-自定义属性"><a href="#4-2-1-自定义属性" class="headerlink" title="4.2.1 自定义属性"></a>4.2.1 自定义属性</h4><pre><code>1. 默认创建application.properties;同时也支持yml格式的文件；
2. 读取配置文件的值:在变量上加上@Value(&quot;${属性名}&quot;)；
</code></pre><h4 id="4-2-2-将配置文件的属性赋给实体类"><a href="#4-2-2-将配置文件的属性赋给实体类" class="headerlink" title="4.2.2 将配置文件的属性赋给实体类"></a>4.2.2 将配置文件的属性赋给实体类</h4><pre><code>1. 当有多个配置属性的时候，通常会把这些属性名创建一个JavaBean变量，并将属性值赋给JavaBean变量。
2. random.int 生成整型值，random.uuid生成一个uuid,random.value随机生成一个值，random.value(10)随机生成一个小于10整数。
3. 在一个Bean类上加一个注解@ConfigurationProperies,表明该类为配置属性类，并且加上配置的prefix,并且加上@Component注解。
</code></pre><h4 id="4-2-3-自定义配置文件"><a href="#4-2-3-自定义配置文件" class="headerlink" title="4.2.3 自定义配置文件"></a>4.2.3 自定义配置文件</h4><pre><code>1. 如在resource下自定义一个test.properties配置文件：
    com.my.name = rocky
    com.my.age = 23
2. 此时需要在类名上加上@Configuration,@PropertySource和@ConfigurationProperties这3个注解。
</code></pre><h3 id="4-3-运行状态监控Actuator"><a href="#4-3-运行状态监控Actuator" class="headerlink" title="4.3 运行状态监控Actuator"></a>4.3 运行状态监控Actuator</h3><h3 id="4-4-SpringBoot-整合JPA"><a href="#4-4-SpringBoot-整合JPA" class="headerlink" title="4.4 SpringBoot 整合JPA"></a>4.4 SpringBoot 整合JPA</h3><h3 id="4-5-SpringBoot-整合Redis"><a href="#4-5-SpringBoot-整合Redis" class="headerlink" title="4.5 SpringBoot 整合Redis"></a>4.5 SpringBoot 整合Redis</h3><pre><code>1. Redis简介
2. 加入redis依赖
</code></pre><h2 id="5-服务注册与发现Eureka"><a href="#5-服务注册与发现Eureka" class="headerlink" title="5.服务注册与发现Eureka"></a>5.服务注册与发现Eureka</h2><h3 id="5-1-源码解析Eureka"><a href="#5-1-源码解析Eureka" class="headerlink" title="5.1 源码解析Eureka"></a>5.1 源码解析Eureka</h3><pre><code>1. Register---服务注册
    当Eureka Client向Euerka Server注册时，Eureka Client提供自身的元数据，如IP地址，端口，运行状态指标Url,主页地址信息
2. Renew---服务续约
    Eureka Client每隔30秒发送一次心跳来进行服务续约。通过服务续约来告知Eureka Server该Eureka Client仍然可用，没有出现故障。正常情况下，如果Eureka Server在90s内没有收到Eureka Client的心跳，EurekaServer会将Eureka Client实例从注册列表中删除。
3. Fetch Registries---获取服务注册列表信息
    C从S获取服务注册表信息，并将其缓存在本地。C使用服务注册列表信息查找其他服务信息，从而进行RPC。该注册列表信息定时更新，每次返回与缓存可能不同，Eureka Client缓存信息不同，C会自己处理。注册信息不匹配时，C重新获取整个注册表信息。S缓存了所有服务的注册列表信息，并将整个注册列表以及每个应用程序的信息进行压缩，以Json和XML数据格式进行通信。默认使用Json方式来获取服务注册列表信息。

4. Cancel---服务下线
    C程序关闭时，向S发送下线请求。完成请求后，S将C从list删除。需要在程序关闭时调用方法。
5. Eviction---服务剔除
    连续90s没有向Eureka Server发送服务续约，就会将该S从服务注册列表删除。
</code></pre><h3 id="5-2-1-Eureka高可用架构"><a href="#5-2-1-Eureka高可用架构" class="headerlink" title="5.2.1 Eureka高可用架构"></a>5.2.1 Eureka高可用架构</h3><h3 id="5-2-2-Register服务注册"><a href="#5-2-2-Register服务注册" class="headerlink" title="5.2.2 Register服务注册"></a>5.2.2 Register服务注册</h3><h3 id="5-2-3-Renew服务续约"><a href="#5-2-3-Renew服务续约" class="headerlink" title="5.2.3 Renew服务续约"></a>5.2.3 Renew服务续约</h3><h2 id="6-负载均衡Ribbon"><a href="#6-负载均衡Ribbon" class="headerlink" title="6. 负载均衡Ribbon"></a>6. 负载均衡Ribbon</h2><h3 id="6-1-RestTemplate简介"><a href="#6-1-RestTemplate简介" class="headerlink" title="6.1 RestTemplate简介"></a>6.1 RestTemplate简介</h3><pre><code>1. 是SpringResources中的一个访问第三方Restful API接口的网络请求框架。目的都是为了执行复杂任务提供一个具有默认行为的简单方法。
2. RestTemplate是用来消费Rest服务的，所有方法都与Rest的Http协议的一些方法紧密相连。
</code></pre><h3 id="6-2-Ribbon简介"><a href="#6-2-Ribbon简介" class="headerlink" title="6.2 Ribbon简介"></a>6.2 Ribbon简介</h3><pre><code>1. 负载均衡方式:独立进程单元，通过负载均衡策略将请求转发到不同执行单元上，如Nginx；另一种是将负载均衡逻辑以代码形式封装到服务消费者的客户端上，C中维护了一份服务提供者信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。
2. Ribbon采用第二种方式。有两种使用方式：一种是和RestTemplate结合，另一种是和Feign结合。默认与feign结合。
3. 源码解析
</code></pre><h2 id="7-声明式调用Feign"><a href="#7-声明式调用Feign" class="headerlink" title="7.声明式调用Feign"></a>7.声明式调用Feign</h2><h2 id="8-熔断器Hystrix"><a href="#8-熔断器Hystrix" class="headerlink" title="8.熔断器Hystrix"></a>8.熔断器Hystrix</h2><ol>
<li>分布式系统中，服务与服务之间的依赖错综复杂，一种不可避免的情况就是某些服务出现故障，导致依赖他们的其他服务出现远程调度的线程阻塞。Hystrix具有熔断器功能，能够阻止分布式系统中出现联动故障。Hystrix通过隔离服务访问点阻止联动故障，并提供故障解决方案，从而提高整个分布式系统的弹性。</li>
<li>高并发情况下，单个服务的延迟会导致整个请求都处于延迟状态，导致服务处于线程饱和状态，资源消耗殆尽。并且因为服务的依赖，导致其他服务也处于阻塞状态，引发雪崩。</li>
<li>Hystrix设计原则    <ol>
<li>防止单个服务的故障耗尽整个服务的Serlvet容器线程资源。</li>
<li>快速失败机制，如果单个服务出现故障，则调用服务的请求快速失败，而不是线程等待。</li>
<li>提供回退方案，在请求发生故障时，提供设定好的回退方案。</li>
<li>使用熔断机制，防止故障扩散到其他服务。</li>
<li>提供熔断器监控组件Hystrix Dashboard,实时监控熔断器状态。</li>
</ol>
</li>
<li>Hystrix工作机制</li>
</ol>
<h2 id="9-路由网关Spring-Cloud-Zuul"><a href="#9-路由网关Spring-Cloud-Zuul" class="headerlink" title="9.路由网关Spring Cloud Zuul"></a>9.路由网关Spring Cloud Zuul</h2><ol>
<li>用于构建边界服务，致力于动态路由，过滤，监控，弹性伸缩和安全。<h3 id="9-1-为什么需要Zuul"><a href="#9-1-为什么需要Zuul" class="headerlink" title="9.1 为什么需要Zuul"></a>9.1 为什么需要Zuul</h3><h3 id="9-2-Zuul工作原理"><a href="#9-2-Zuul工作原理" class="headerlink" title="9.2 Zuul工作原理"></a>9.2 Zuul工作原理</h3></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/SpringCloud-微服务/">SpringCloud 微服务</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/28/微服务系列之源初/" title="微服务系列之源初" itemprop="url">微服务系列之源初</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-28T03:10:23.000Z" itemprop="datePublished"> Published 2018-08-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>近期安排主要路线：</p>
<ul>
<li>微服务-&gt;service mesh-&gt;dubbo相关源码<br></li>
<li>设计模式-&gt;主流框架设计模式总结</li>
<li>微服务系列主要以微服务设计+深入理解SpringCloud与微服务构建这两本书的读书笔记为主。</li>
</ul>
</blockquote>
<h1 id="微服务设计读书笔记"><a href="#微服务设计读书笔记" class="headerlink" title="微服务设计读书笔记"></a>微服务设计读书笔记</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><pre><code>微服务是一种分布式解决方案，推动细粒度服务的使用，这些服务协同工作，并且每个服务都有自己的生命周期。微服务主要围绕业务领域建模，所以避免了传统的分层架构引发的问题。避免了面向服务的架构中的陷阱。
</code></pre><h2 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1.微服务"></a>1.微服务</h2><pre><code>i.领域驱动设计---用代码呈现真实世界的重要性。
ii.六边形架构理论---&gt;替代分层架构---&gt;更好的体现业务逻辑。借助虚拟化平台可以按需创建机器并且调整大小，借助基础设施自动化，可以从一台机器扩展到多台。
iii.领域驱动设计，持续交付，按需虚拟化，基础设施自动化，小型自治团队，大型集群系统---&gt;微服务诞生。
</code></pre><h3 id="1-1-什么是微服务"><a href="#1-1-什么是微服务" class="headerlink" title="1.1 什么是微服务"></a>1.1 什么是微服务</h3><blockquote>
<p>微服务就是一些协同工作的小而自治的服务。</p>
</blockquote>
<h4 id="1-1-1-很小专注于做好一件事"><a href="#1-1-1-很小专注于做好一件事" class="headerlink" title="1.1.1 很小专注于做好一件事"></a>1.1.1 很小专注于做好一件事</h4><ol>
<li>在一个单块系统内，通常会创建一些抽象层或者模块来保证代码的内聚性；内聚性是指将相关代码放一起，在考虑使用微服务的时候，<strong>内聚性很重要</strong>；</li>
<li>单一职责原则：把因相同原因而变化的东西聚合在一起，而把因不同原因而变化的东西分离开来。</li>
<li>微服务的理念应用在独立的服务上。根据业务的边界来确定服务的边界，从而确定某个功能代码应该放在那里。</li>
<li>小-&gt;服务管理难度增加</li>
</ol>
<h4 id="1-1-2-自治性"><a href="#1-1-2-自治性" class="headerlink" title="1.1.2 自治性"></a>1.1.2 自治性</h4><ol>
<li>一个微服务就是一个独立的实体，可以独立部署在PAAS上，作为操作系统独立进程存在。避免将多个服务部署在同一台机器上。通过隔离也会带来一定量的代价，但是能够简化分布式系统的构建。</li>
<li>服务之间均通过网络进行通信，加强了服务之间的隔离性，避免紧耦合。</li>
<li>服务可以彼此间独立进行修改，某一个服务的部署不应该引起服务消费方的变动。对于一个服务来说，需要考虑什么应该暴露，什么应该隐藏。如果暴露过多会造成消费方与服务的内部实现产生耦合，使得服务和消费方之间产生额外的协调工作，从而降低服务的自治性。</li>
<li>服务会暴露出API,然后服务之间通过这些API进行通信。API的实现技术应该避免与消费放耦合，这就意味着应该选择与具体技术不相关的API实现方法，以保证技术的选择不被限制。</li>
<li>如果系统没有很好地解耦，那么一旦出现问题，所有功能都将不可用</li>
</ol>
<h3 id="1-2-主要好处"><a href="#1-2-主要好处" class="headerlink" title="1.2 主要好处"></a>1.2 主要好处</h3><h4 id="1-2-1-技术异构性"><a href="#1-2-1-技术异构性" class="headerlink" title="1.2.1 技术异构性"></a>1.2.1 技术异构性</h4><ol>
<li>一个由多个服务相互协作的系统中，可以在不同的服务中使用最合适改服务的技术。通用的技术不会得到很好的性能。</li>
<li>如果系统中一部分需要做性能提升，可以使用性能更好的技术栈重新构建该部分。<strong>系统中不同部分可以使用不同的数据存储技术，比如社交网络来说，图数据库能够更好地处理用户之间的交互操作，对于用户发布的帖子，使用文档数据库可能更好的选择。异构架构。</strong></li>
<li>微服务可以帮助我们更快地采用新技术，并且理解这些新技术的好处。—&gt;单块降低风险。<h4 id="1-2-2-弹性"><a href="#1-2-2-弹性" class="headerlink" title="1.2.2 弹性"></a>1.2.2 弹性</h4></li>
<li>如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。服务边界就是一个很显然的舱壁。</li>
<li>在单块系统中，如果服务不可用，那么所有的功能都会不可用，那么对于单块服务的系统而言，可以通过将同样的实例运行在不同的机器上来降低功能完全不可用的概率，微服务本身能够很好地处理服务不可用和功能降级的问题。<h4 id="1-2-3-扩展"><a href="#1-2-3-扩展" class="headerlink" title="1.2.3 扩展"></a>1.2.3 扩展</h4><h4 id="1-2-4-简化部署"><a href="#1-2-4-简化部署" class="headerlink" title="1.2.4 简化部署"></a>1.2.4 简化部署</h4>几百万行的单块应用程序中，即使只修改一行代码也需要重新部署整个应用程序才能发布改变更。<h4 id="1-2-5-与组织结构相匹配"><a href="#1-2-5-与组织结构相匹配" class="headerlink" title="1.2.5 与组织结构相匹配"></a>1.2.5 与组织结构相匹配</h4><h4 id="1-2-6-可组合性"><a href="#1-2-6-可组合性" class="headerlink" title="1.2.6 可组合性"></a>1.2.6 可组合性</h4></li>
<li>单纯考虑桌面网站或者移动应用程序时代过去，现在需要考虑的应用程序包括web，原生应用，移动端web,平板应用以及可穿戴设备等。</li>
<li>在微服务架构中，系统会开放很多接缝供外部使用。当情况发生改变的时候，可以使用不同的方式构建应用，而整体化应用程序只能提供一个非常粗粒度的接缝供外部使用。</li>
</ol>
<h3 id="1-3-面向服务架构"><a href="#1-3-面向服务架构" class="headerlink" title="1.3 面向服务架构"></a>1.3 面向服务架构</h3><pre><code>1.SOA是一种设计方法，其中包含多个服务，服务之间通过配合最终提供一系列功能。服务之间通过网络调用，而非采用进程内调用的方式进行通信。
2.SOA遇到的问题：通信协议的选择，第三方中间件的选择，服务粒度如何确定，如何划分系统。
</code></pre><h2 id="2-演化式架构师"><a href="#2-演化式架构师" class="headerlink" title="2.演化式架构师"></a>2.演化式架构师</h2><h3 id="2-1-不确定的比较"><a href="#2-1-不确定的比较" class="headerlink" title="2.1 不确定的比较"></a>2.1 不确定的比较</h3><pre><code>1. 架构师的职责:确保团队由共同的技术愿景，以帮助我们向客户交付他们想要的系统。
2. 架构师的影响:所构建系统的质量，同事的工作条件，组织应对变化的能力等。
</code></pre><h3 id="2-2-架构师的演化视角"><a href="#2-2-架构师的演化视角" class="headerlink" title="2.2 架构师的演化视角"></a>2.2 架构师的演化视角</h3><pre><code>1. 软件中会面临大量需求变更，使用的工具和技术也具有多样性。必须改掉从一开始就要设计出完美产品的想法，相反应该设计出一个合理的框架，在这个框架下可以慢慢演化出正确的系统。
2. 架构师应该像城市规划师那样专注在大方向上，只有很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前需求，还能够应对将来的变化。
</code></pre><h3 id="2-3-分区"><a href="#2-3-分区" class="headerlink" title="2.3 分区"></a>2.3 分区</h3><pre><code>1. 代码架构师---&gt;团队
</code></pre><h3 id="2-4-一个原则性的方法"><a href="#2-4-一个原则性的方法" class="headerlink" title="2.4 一个原则性的方法"></a>2.4 一个原则性的方法</h3><pre><code>做系统设计方面决定通常在于舍取，微服务中需要舍取更多。如数据存储技术，如何带来过呢更好的可伸缩性技术。系统种是否可接受两种技术栈，做某些决策所需要的信息获取。
</code></pre><h4 id="2-4-1-战略目标"><a href="#2-4-1-战略目标" class="headerlink" title="2.4.1 战略目标"></a>2.4.1 战略目标</h4><pre><code>公司的走向 客户的满意程度
</code></pre><h4 id="2-4-2-原则"><a href="#2-4-2-原则" class="headerlink" title="2.4.2 原则"></a>2.4.2 原则</h4><pre><code>目标-&gt;规则。组织上线周期，交付团队应该对整个软件生命周期有完全的控制权。
Heroku的12Factors原则
</code></pre><h4 id="2-4-3-实践"><a href="#2-4-3-实践" class="headerlink" title="2.4.3 实践"></a>2.4.3 实践</h4><pre><code>1. 通过相应的实践来保证与那则能够得到实施，这些实践知道我们如何完成任务。这些实践通常与技术相关，并且较为底层。任何开发人员都能够理解。这些实践包括代码规范，日志数据集中捕获，或者http/rest作为标准集成风格等。
2. 由于偏技术层面，其改变频率会高于原则。
3. 实践有时候会反映出组织内的一些限制。
4. 实践应该巩固原则
</code></pre><h4 id="2-4-4-将原则和实践相结合"><a href="#2-4-4-将原则和实践相结合" class="headerlink" title="2.4.4 将原则和实践相结合"></a>2.4.4 将原则和实践相结合</h4><pre><code>1.Http/Rest作为原则，而不是实践，
</code></pre><h4 id="2-4-5-真实世界的例子"><a href="#2-4-5-真实世界的例子" class="headerlink" title="2.4.5 真实世界的例子"></a>2.4.5 真实世界的例子</h4><h3 id="2-5-要求的标准"><a href="#2-5-要求的标准" class="headerlink" title="2.5 要求的标准"></a>2.5 要求的标准</h3><pre><code>1.系统允许多少可变性
2.我们需要识别出各个服务需要遵守的通用规则
3.给出一个好服务的例子来阐释好服务的特点
</code></pre><h4 id="2-5-1-监控"><a href="#2-5-1-监控" class="headerlink" title="2.5.1 监控"></a>2.5.1 监控</h4><pre><code>1. 能够清晰的描绘服务系统的健康状态非常关键。这是系统级别的而不是单个服务级别进行考虑的。
2. 在需要诊断一个跨服务问题或者想要了解更大趋势时，需要知道每个服务的健康状态。
3. 所有的服务使用相同的方式报告健康状态以及监控相关的数据。
4. 推送机制:每个服务主动把数据推送到某个集中的为止。使用Graphite来收集数据，使用Nagios来检测健康状态。总之尽量标准化。
5. 每个服务内的技术应该对外不透明，并且不要为了服务的具体实现而改变监控系统，日志功能和监控情况类似，需要集中式管理。
</code></pre><h4 id="2-5-2-接口"><a href="#2-5-2-接口" class="headerlink" title="2.5.2 接口"></a>2.5.2 接口</h4><h4 id="2-5-3-架构安全性"><a href="#2-5-3-架构安全性" class="headerlink" title="2.5.3 架构安全性"></a>2.5.3 架构安全性</h4><pre><code>1. 必须保证每个服务都可以应对下游服务的错误请求。
2. 如果下游错误请求的服务堆积，就会使系统脆弱。每个下游服务使用他们自己的连接池，进一步让每个服务使用一个断路器。
3. 返回码应该遵守一定的规则。
</code></pre><h3 id="2-6-代码治理"><a href="#2-6-代码治理" class="headerlink" title="2.6 代码治理"></a>2.6 代码治理</h3><pre><code>提供范例和服务代码模板
</code></pre><h4 id="2-6-1-范例"><a href="#2-6-1-范例" class="headerlink" title="2.6.1 范例"></a>2.6.1 范例</h4><pre><code>1. 编写文档 
2. 代码
</code></pre><h4 id="2-6-2-裁剪服务代码模板"><a href="#2-6-2-裁剪服务代码模板" class="headerlink" title="2.6.2 裁剪服务代码模板"></a>2.6.2 裁剪服务代码模板</h4><h3 id="2-7-技术债务"><a href="#2-7-技术债务" class="headerlink" title="2.7 技术债务"></a>2.7 技术债务</h3><pre><code>1. 为了发布一些紧急的特性，会忽略一些约束。这是另一个需要做的取舍。技术愿景有其本身的道理。
2. 偏离了这个愿景短期内会带来利益，但是长期看来需要付出代价。可以使用技术债务来理解这个取舍。
2. 架构师的职责就是从更高层次触发，理解如何做权衡。理解债务的层次及其对系统的影响非常重要。
3. 架构师应该能够提供一些温和的指导，然后让团队自行决定如何偿还这些技术债务。结构化，维护一个债务列表，定期回顾。
</code></pre><h3 id="2-8-例外管理"><a href="#2-8-例外管理" class="headerlink" title="2.8 例外管理"></a>2.8 例外管理</h3><pre><code>1. 如果系统偏离了原则和实践，就可以针对某个规则破例，然后记录，如果出现多次可以通过修改原则和实践的方式把我们的理解固化下来。
2. 如，在一般情况使用MySQL，在海量存储的场景应该使用**Cassandra**；
3. 于是就可以修改原则，在大多数场景使用MySQL做存储，在数据快速增长的场景，使用Cassandra。
</code></pre><h3 id="2-9-集中治理和领导"><a href="#2-9-集中治理和领导" class="headerlink" title="2.9 集中治理和领导"></a>2.9 集中治理和领导</h3><pre><code>1. 架构师的部分职责是治理，COBIT给出的定义:治理通过评估干系人的需求，当前情况下以及下一步的可能性来确保企业目标的达成，通过排优先级和做决策来设定方向。对于已经达成一致的方向和目标进行监督。
2. 架构师的职责是确保有一个技术愿景，治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。 
</code></pre><h2 id="3-如何建模服务"><a href="#3-如何建模服务" class="headerlink" title="3.如何建模服务"></a>3.如何建模服务</h2><h3 id="3-1-MusicCorp简介"><a href="#3-1-MusicCorp简介" class="headerlink" title="3.1 MusicCorp简介"></a>3.1 MusicCorp简介</h3><h3 id="3-2-什么样的服务是好服务"><a href="#3-2-什么样的服务是好服务" class="headerlink" title="3.2 什么样的服务是好服务"></a>3.2 什么样的服务是好服务</h3><h3 id="3-2-1-松耦合"><a href="#3-2-1-松耦合" class="headerlink" title="3.2.1 松耦合"></a>3.2.1 松耦合</h3><pre><code>1. 修改一个服务不需要修改另一个服务。
 2. 使用微服务，能够独立修改及部署单个服务而不需要修改修通的其他部分。
 3. 一个松耦合的服务应该尽可能少的直到与之协作的那些服务的信息。应该限制两个服务之间不同调用形式的数量。不仅是性能还有，过度通信导致的紧耦合。
</code></pre><h3 id="3-2-2-高内聚"><a href="#3-2-2-高内聚" class="headerlink" title="3.2.2 高内聚"></a>3.2.2 高内聚</h3><pre><code>1. 把相关的行为聚集在一起，把不相关的行为放在别处。
2. 如果想改变某个行为，最好能够只在一个地方修改，然后就可以尽快地发布。
3. 如果需要在很多不同的地方修改就需要同时发布多个微服务才能够交付这个功能。
4. 在很多个地方进行修改会很慢，同时部署多个服务风险也高。
5. 找到问题的边界就可以确保相关的行为可以放在同一个地方，并且他们会与其他边界以尽量松耦合的形式进行通信。
</code></pre><h3 id="3-3-限界上下文"><a href="#3-3-限界上下文" class="headerlink" title="3.3 限界上下文"></a>3.3 限界上下文</h3><pre><code>1. 领域驱动设计主要专注如何实现世界的领域进行建模。如通用语言，仓储，抽象等。其中引入了限界上下文文。
2. 任何一个给定的**领域都包含多个限界上下文**，这个上下文中的东西分成2部分，**一部份不需要与外部通信，另一部分则需要。**每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他上下文。
3. 另一个限界上下文定义：**一个由显式边界限定的特定职责**，如果想从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。、
</code></pre><h4 id="3-3-1-共享的隐藏模型"><a href="#3-3-1-共享的隐藏模型" class="headerlink" title="3.3.1 共享的隐藏模型"></a>3.3.1 共享的隐藏模型</h4><h4 id="3-3-2-模块和服务"><a href="#3-3-2-模块和服务" class="headerlink" title="3.3.2 模块和服务"></a>3.3.2 模块和服务</h4><pre><code>1. 同一个进程内使用模块来减少彼此之间的耦合也是一种选择。
2. 微服务应该清晰地和限界上下文呢保持一致。
</code></pre><h4 id="3-3-3-过早划分"><a href="#3-3-3-过早划分" class="headerlink" title="3.3.3 过早划分"></a>3.3.3 过早划分</h4><h3 id="3-4-业务功能"><a href="#3-4-业务功能" class="headerlink" title="3.4 业务功能"></a>3.4 业务功能</h3><h3 id="3-5-逐步划分上下文"><a href="#3-5-逐步划分上下文" class="headerlink" title="3.5 逐步划分上下文"></a>3.5 逐步划分上下文</h3><pre><code>1. 一开始接触一些粗粒度的限界上下文，这里面可能会包含一些嵌套限界上下文。
2. 当考虑微服务边界时，首先考虑比较大，粗粒度的那些上下文，当发现合适的缝隙后，再进一步划分出且套上下文。
</code></pre><h2 id="4-集成"><a href="#4-集成" class="headerlink" title="4.集成"></a>4.集成</h2><h3 id="4-1-集成技术"><a href="#4-1-集成技术" class="headerlink" title="4.1 集成技术"></a>4.1 集成技术</h3><pre><code>1. SOAP XML-RPC REST Protocol Buffers 
2. 易于使用，隐藏内部实现细节
</code></pre><h3 id="4-2-为用户创建接口"><a href="#4-2-为用户创建接口" class="headerlink" title="4.2 为用户创建接口"></a>4.2 为用户创建接口</h3><h3 id="4-3-共享数据库"><a href="#4-3-共享数据库" class="headerlink" title="4.3 共享数据库"></a>4.3 共享数据库</h3><h3 id="4-4-同步和异步"><a href="#4-4-同步和异步" class="headerlink" title="4.4 同步和异步"></a>4.4 同步和异步</h3><pre><code>1. 请求/响应：客户端发起一个请求，然后等待响应。
2. 异步通信:发起一个请求，然后注册一个回调，当服务端操作结束后，会调用该回调。
3. 基于事件的协作方式，客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收该消息，并且知道怎么做。
4. 基于事件的系统天生是异步，并且业务逻辑不是集中式的而是平均分布在不同的协作者中。
5. 基于事件的协作方式耦合性很低。客户端发布一个事件，但不需要知道谁或者什么会对此做出响应，也就是说不影响客户端的情况下，对该事件添加新的订阅。
</code></pre><h3 id="4-5-编排与协同"><a href="#4-5-编排与协同" class="headerlink" title="4.5 编排与协同"></a>4.5 编排与协同</h3><pre><code>1. 编排：依赖于某个中心大佬指导并驱动整个流程。
    1.让客户服务作为中心大脑
    2.过于依赖中心大脑
2. 协同：仅仅告知系统中各个部分各自的职责，而具体怎么做的细节留给他们自己，同时也会响应周围其他人。
    1. 协同可以降低系统的耦合度，并且可以更加灵活地对现有系统进行修改。但是需要额外的工作来对业务流程做跨服务的监控。
    2. 同步调用简单，如果想要请求/响应风格的语义，又想避免其在耗时业务上的困境，可以采用异步请求加回调的方式。
    3. 使用异步方式有利于协同方案的实施，从而大大减少服务间的耦合，这是能独立发布服务而追求的特性。
3. 针对请求/响应方式，可以考虑2中技术:RPC和REST
</code></pre><h3 id="4-6-远程过程调用"><a href="#4-6-远程过程调用" class="headerlink" title="4.6 远程过程调用"></a>4.6 远程过程调用</h3><pre><code>1. 允许你进行一个本地调用，但是实际结果由某个远程服务器产生。PRC种类繁多，其中一些依赖于接口定义（SOAP,Thrift,Protocol buffers等）。不同的技术栈可以通过接口定义轻松生成客户端和服务端的桩代码。
2. 用JAVA服务暴露一个SOAP接口，然后使用WSDL定义接口生成.net客户端的代码。
3. 很多技术本质上是二进制的，比如JAVA RMI,Thrift,protocol buffers等，SOAP使用XML作为消息格式。有些RPC实现与特定网络协议相绑定，同时也有不同的协议实现。
4. Tcp能够保证送达，UDP虽然不能保证送达，但是协议开销较小。
</code></pre><h3 id="4-7-REST"><a href="#4-7-REST" class="headerlink" title="4.7 REST"></a>4.7 REST</h3><pre><code>1. Rest是RPC的一种替代方案；
2. 资源，处于服务之内。服务可以根据请求内容创建消费对象的不同表现形式，一个资源的对外显示方式和内部存储方式之间没有耦合。
3. 例如，客户端可能会请求一个customer的json表示形式，而customer内部存储方式可以完全不同。客户端一旦得到该customer得表示，就可以发出请求对其进行修改，而服务器可以选择应答与否。
4. **Richardson的成熟度模型**
5. REST本身没有提及底层的协议，最常用的是http，或者usb，串口等等。
</code></pre><h4 id="4-7-1-Rest和Http"><a href="#4-7-1-Rest和Http" class="headerlink" title="4.7.1 Rest和Http"></a>4.7.1 Rest和Http</h4><pre><code>http的方法get,post可以很好和资源一起使用。Rest架构风格声明了一组对所有资源的标准方法，HTTP恰好也定义了一组方法供使用。GET使用幂等的方式获取资源，Post创建一个新资源。
</code></pre><h4 id="4-7-2-超媒体作为程序状态引擎"><a href="#4-7-2-超媒体作为程序状态引擎" class="headerlink" title="4.7.2 超媒体作为程序状态引擎"></a>4.7.2 超媒体作为程序状态引擎</h4><pre><code>1. 超媒体:有一块内容，该内容包含了指向其他内容的链接，而这些内容的格式可以不同，如文本，图像，声音等。你可以在任何一个网页上看到超媒体控制形式的链接，当你点击时可以看到相关的内容，
2. **Rest实战**
</code></pre><h3 id="4-8-试下基于事件的异步协作方式"><a href="#4-8-试下基于事件的异步协作方式" class="headerlink" title="4.8 试下基于事件的异步协作方式"></a>4.8 试下基于事件的异步协作方式</h3><h4 id="4-8-1-技术选择"><a href="#4-8-1-技术选择" class="headerlink" title="4.8.1 技术选择"></a>4.8.1 技术选择</h4><pre><code>1. 微服务发布事件机制和消费者接收事件机制。尽量让中间件保持简单，把业务逻辑放在自己的服务中。 
2. 使用HTTP来传播
</code></pre><h4 id="4-8-3-异步机构的复杂性"><a href="#4-8-3-异步机构的复杂性" class="headerlink" title="4.8.3 异步机构的复杂性"></a>4.8.3 异步机构的复杂性</h4><pre><code>1. 复杂性：不仅仅是对于消息发布订阅操作，对于非常耗时的异步请求/响应，需要考虑返回时怎么处理。该响应是否回到发送请求那个节点？如果是，节点停止服务怎么办?如果不是，是否需要把信息事先存储到其他地方，以便于做相应处理？
2. 如果API设计得当，短生命周期的异步操作很容易管理。但是需要思维的转换。
3. 灾难性故障转移
</code></pre><h3 id="4-9-服务即状态机"><a href="#4-9-服务即状态机" class="headerlink" title="4.9 服务即状态机"></a>4.9 服务即状态机</h3><h3 id="4-10-响应式扩展"><a href="#4-10-响应式扩展" class="headerlink" title="4.10 响应式扩展"></a>4.10 响应式扩展</h3><h2 id="5-分解单块系统"><a href="#5-分解单块系统" class="headerlink" title="5.分解单块系统"></a>5.分解单块系统</h2><h3 id="5-1-关键是接缝"><a href="#5-1-关键是接缝" class="headerlink" title="5.1 关键是接缝"></a>5.1 关键是接缝</h3><p>1.高内聚，低耦合。<br>2.限界上下文:组织内高内聚和低耦合的边界。</p>
<h3 id="5-2-分解项目"><a href="#5-2-分解项目" class="headerlink" title="5.2 分解项目"></a>5.2 分解项目</h3><ol>
<li>4个上下文<ul>
<li>产品目录：与正在销售商品相关的元数据</li>
<li>财务:账户，支付，退款等项目的报告</li>
<li>仓库:分发客户订单，处理退货，管理仓库等</li>
<li>推荐：推荐算法</li>
</ul>
</li>
<li>创建包结构来表示上下文，用IDE重构功能来自动完成代码移动。<h3 id="5-3-分解单块系统的原因"><a href="#5-3-分解单块系统的原因" class="headerlink" title="5.3 分解单块系统的原因"></a>5.3 分解单块系统的原因</h3></li>
<li>改变的速度</li>
<li>团队结构</li>
<li>安全</li>
<li>技术</li>
<li>依赖</li>
<li>数据库</li>
<li>找到问题的关键<h3 id="5-4-事务边界"><a href="#5-4-事务边界" class="headerlink" title="5.4 事务边界"></a>5.4 事务边界</h3></li>
<li>事务:要么全部做完，要么什么都不变。 </li>
<li>重试</li>
<li>快速失败</li>
<li>分布式事务<ol>
<li>事务管理器</li>
<li>事务运行在不同的进程种，通过网络进行通信</li>
<li>二阶段提交：投票阶段，很容易让所有参与者都等待中央协调进行的指令，从而容易导致系统中断。<h3 id="5-5-通过服务调用来获取数据"><a href="#5-5-通过服务调用来获取数据" class="headerlink" title="5.5 通过服务调用来获取数据"></a>5.5 通过服务调用来获取数据</h3><h3 id="5-6-数据导出"><a href="#5-6-数据导出" class="headerlink" title="5.6 数据导出"></a>5.6 数据导出</h3><h2 id="6-部署"><a href="#6-部署" class="headerlink" title="6.部署"></a>6.部署</h2><h3 id="6-1-持续集成"><a href="#6-1-持续集成" class="headerlink" title="6.1 持续集成"></a>6.1 持续集成</h3></li>
</ol>
</li>
<li>CI能够保证新提交的代码与已有代码进行集成，从而让所有人保持同步。CI服务器会检测到代码已提交并签出，然后花些时间来验证代码是否通过编译以及测试是否通过。</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/微服务设计读书笔记/">微服务设计读书笔记</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/28/Sentinel系列之源码解读/" title="Sentinel系列之源码" itemprop="url">Sentinel系列之源码</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-28T01:24:02.000Z" itemprop="datePublished"> Published 2018-08-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-源码模块"><a href="#1-源码模块" class="headerlink" title="1. 源码模块"></a>1. 源码模块</h2><ol>
<li>sentinel-adapter 接入<ol>
<li>sentinel-dubbo-adapter</li>
<li>sentinel-grpc-adapter</li>
<li>sentinel-web-servlet</li>
</ol>
</li>
<li>sentinel-benchmark</li>
<li>sentinel-core</li>
<li>sentinel-dashboard</li>
<li>sentinel-demo</li>
<li>sentinel-extension</li>
<li>sentinel-transport</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Sentinel/">Sentinel</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/28/Sentinel系列之起源/" title="Sentinel系列之起源" itemprop="url">Sentinel系列之起源</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-28T01:24:02.000Z" itemprop="datePublished"> Published 2018-08-28</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-什么是Sentinel"><a href="#1-什么是Sentinel" class="headerlink" title="1.什么是Sentinel"></a>1.什么是Sentinel</h2><blockquote>
<p>i.分布式系统的流量防卫兵；<br><br>ii.微服务架构中，服务与服务之间的稳定性变得越来越重要。Sentinel以流量为切入点，从流控，熔断，降级，系统负载保护等多个维度来提供服务稳定性支持；<br>iii.轻量级。</p>
</blockquote>
<h2 id="2-Sentinel功能"><a href="#2-Sentinel功能" class="headerlink" title="2.Sentinel功能"></a>2.Sentinel功能</h2><blockquote>
<p>i.流控，针对秒杀环境，对于突发流量可以控制在系统承受范围内；<br><br>ii.削峰填谷;<br><br>iii.实时熔断下游不可用应用;<br><br>iv.完备的监控功能:提供实时的监控功能，可以精确到秒级数据；<br><br>v.Sentinel提供简易的扩展点，快速定制逻辑，例如定制规则管理，适配数据源。</p>
</blockquote>
<h2 id="3-核心架构"><a href="#3-核心架构" class="headerlink" title="3.核心架构"></a>3.核心架构</h2><pre><code>核心库:不依赖任何框架/库，能够运行于所有java运行时环境，对Dubbo/Spring Cloud等框架有较好的支持。
控制台:基于SpringBoot开发，打包后直接运行，不需要额外的Tomcat应用容器。
</code></pre><h2 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4.基本概念"></a>4.基本概念</h2><h3 id="4-1-资源"><a href="#4-1-资源" class="headerlink" title="4.1 资源"></a>4.1 资源</h3><ol>
<li>资源是Sentinel的关键概念，可以是APP中的任意内容。如由应用程序提供的服务，或者由应用程序调用的其他应用提供的服务，或者一段代码。</li>
<li>只要通过Sentinel API定义的代码就是资源，能够被Sentinel保护起来。通常使用方法签名，URL，甚至服务名称作为资源名来标识资源。<h3 id="4-2-规则"><a href="#4-2-规则" class="headerlink" title="4.2 规则"></a>4.2 规则</h3>围绕资源的实时状态设定的规则，可以包括流量控制规则，熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</li>
</ol>
<h2 id="5-Sentinel功能合设计理念"><a href="#5-Sentinel功能合设计理念" class="headerlink" title="5.Sentinel功能合设计理念"></a>5.Sentinel功能合设计理念</h2><h3 id="5-1-流量控制"><a href="#5-1-流量控制" class="headerlink" title="5.1 流量控制"></a>5.1 流量控制</h3><p><strong>1.</strong> <strong>什么是流量控制</strong></p>
<blockquote>
<p>流控是网络传输中的常用概念，用于调整网络包的发送数据。<br><br>流控的目的是从系统的稳定性角度来考虑的，在处理请求的速度上，有很多讲究。<br><br>任意时间到来的请求是随机不可控的，但是系统的处理能力有限，需要根据系统的能力进行流控。<br><br>Sentinel作为一个适配器，可以根据需要把随机请求调整成合适的形状。<br></p>
</blockquote>
<p><strong>2.流控设计理念</strong><br></p>
<blockquote>
<p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系。<br><br>运行指标，如QPS,线程池,系统负载等。<br><br>控制效果，如直接限流，冷启动，排队等。<br><br><strong>Sentinel的设计理念是，自由选择控制的角度，进行灵活组合，达到想要的效果。</strong></p>
</blockquote>
<h3 id="5-2-熔断降级"><a href="#5-2-熔断降级" class="headerlink" title="5.2 熔断降级"></a>5.2 熔断降级</h3><p><strong>1.什么是熔断降级</strong></p>
<blockquote>
<p>核心还是保护系统稳定性，降低调用链路中的不稳定资源。由于调用关系的复杂性，如果链路中的部分资源不稳定，最终会导致请求发生堆积。<br><br>Sentinel和Hystrix原则一致：当调用链路中某个资源出现不稳定，例如表现timeout，异常比例升高的时候，则对这个资源调用进行限制，<strong>让某个请求快速失败</strong>，避免影响到其他资源，最终产生雪崩的效果。<br></p>
</blockquote>
<p><strong>2.熔断降级的设计理念</strong></p>
<blockquote>
<ul>
<li>限制手段上，Sentinel和HyStrix采取不同的方法；HyStrix通过线程池的方式，来依赖(在我们的概念中对应资源)进行了隔离。这样的好处是对资源和资源之间进行彻底的隔离。缺点是增加了线程切换的成本，还需要预留资源给各个线程池大小的分配。<br></li>
<li>Sentinel对于这个问题采用了两种手段：<br><ol>
<li>通过并发线程数进行限制:通过限制资源并发线程数量，来减少不稳定资源对其他资源的影响，这样没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，如响应时间变长，对资源的直接影响是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定数量之后，该资源的新请求就会被拒绝，堆积的线程完成后才开始接收请求。</li>
<li>通过响应时间对资源进行降级：除了对并发线程数进行控制意外，Sentinel还可以通过响应时间来快速降级不稳定资源，当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定时间窗口后才重新恢复。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="5-3-系统的过载保护"><a href="#5-3-系统的过载保护" class="headerlink" title="5.3 系统的过载保护"></a>5.3 系统的过载保护</h2><pre><code>系统入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理更多的请求。
</code></pre><h2 id="6-Sentinel是如何工作的"><a href="#6-Sentinel是如何工作的" class="headerlink" title="6.Sentinel是如何工作的"></a>6.Sentinel是如何工作的</h2><pre><code>1. 对主流框架提供适配或者显示的API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。
2. 根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel提供开放的接口，方便定义和改变规则。
3. Sentinel提供实时的监控系统，方便快速了解当前系统的状态。 
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Sentinel/">Sentinel</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/20/Druid源码解析之数据库连接池总论/" title="Druid源码解析之数据库连接池总论" itemprop="url">Druid源码解析之数据库连接池总论</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-20T10:17:52.000Z" itemprop="datePublished"> Published 2018-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-应用程序直接获取数据连接的缺点"><a href="#1-应用程序直接获取数据连接的缺点" class="headerlink" title="1.应用程序直接获取数据连接的缺点"></a>1.应用程序直接获取数据连接的缺点</h2><ol>
<li>用户每次请求都需要向数据库获得连接，数据库创建连接通常需要消耗大量资源，创建时间也较长。</li>
<li>大量得创建极大浪费数据库得资源，并且极易造成数据库服务器内存溢出，宕机。、</li>
</ol>
<h2 id="2-使用数据库连接池优化程序性能"><a href="#2-使用数据库连接池优化程序性能" class="headerlink" title="2.使用数据库连接池优化程序性能"></a>2.使用数据库连接池优化程序性能</h2><ol>
<li>数据库连接池的概念<ol>
<li>数据库连接是一种关键得有限得昂贵得资源，咋多用户网页程序中体现尤为突出。</li>
<li>对数据库连接的管理能力显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</li>
<li>数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li>
<li>数据库连接池在初始化时将创建一定数量的数据库连接池放到连接池中，这些数据库连接的数量由最小数据库连接数来设定。无论这些数据库连接是否被使用，连接池都将保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求连接数超过最大连接数量时，这些请求将会被加入到等待队列中。</li>
<li>数据库连接池的最小连接数和最大连接数的设置需要考虑一下几个因素：<ol>
<li>最小连接数:是连接池一直保持的数据库连接，所以如果应用程序对数据库连接使用量不大，将会有大量数据库连接资源被浪费；</li>
<li>最大连接数:是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响到以后的数据库操作。</li>
</ol>
</li>
</ol>
</li>
<li>编写数据库连接池<ol>
<li>实现java.sql.DataSource接口,DataSource接口定义了两个重载的getConnection方法:<ol>
<li>Connection getConnection();</li>
<li>Connection getConnection(String username, String password);</li>
</ol>
</li>
<li>实现DataSource接口，并实现连接池功能的步骤：<ol>
<li>在DataSource构造函数中批量创建与数据库的连接，并把创建的连接加入LinkedList对象中；</li>
<li>实现getConnection方法，让getConnection方法每次调用时，从LinkedList中去一个Connection返回给用户；</li>
<li>当用户使用完Connection,调用Connection.close()方法时，Collection对象应保证自己返回到LinkedList中，而不是把conn还给数据库。<strong>Collection保证将自己返回到LinkedList中</strong>；</li>
</ol>
</li>
<li>部分核心代码<br> `proxyConn = (Connection) Proxy.newProxyInstance(this.getClass().getClassLoader(),conn.getClass().getInterfaces(),new InvocationHandler(){<pre><code>public Object invoke(Object proxy,Method method,Object[] args) {
    if(method.getName().equals(&quot;close&quot;)) {
        pool.addLast(conn);
        return null;
    }
    return method.invoke(conn,args);
}
</code></pre> })` </li>
</ol>
</li>
<li>开源数据库连接池<ol>
<li>很多WEB服务器都提供了DataSource的实现，即连接池的实现。把DataSource的实现，按其英文含义称之为数据源，数据源中包含了数据库连接池的实现。</li>
<li>DBCP C3P0 使用了数据库连接池，就不需要在编写连接数据库代码了，直接从数据源获得数据库的连接。</li>
<li>DBCP数据源:tomcat采用该连接池</li>
<li>C3P0数据源:dbcp没有自动回收空闲连接的功能，c3p0有自动回收空闲连接功能</li>
<li>Tomcat数据源</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Druid-数据库连接池/">Druid 数据库连接池</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/20/计算机网络总结复习/" title="计算机网络总结复习" itemprop="url">计算机网络总结复习</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-20T08:09:39.000Z" itemprop="datePublished"> Published 2018-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="计算机网络复习"><a href="#计算机网络复习" class="headerlink" title="计算机网络复习"></a>计算机网络复习</h2><p>1.域名访问流程<br>    1.ip地址查找<br>        1.浏览器查找缓存，是否有ip地址，无则继续<br>        2.操作系统操作缓存，无则继续<br>        3.路由器查找缓存，无则继续<br>        4.本地服务器查找缓存，无则继续<br>        5.根-&gt;顶级-&gt;权威<br>        6.告知其ip地址<br>    2.主机获取ip地址端口建立tcp连接，3次握手<br>    3.浏览器发送请求报文<br>    4.服务器接收报文，并向客户机发出确认请求；<br>    5.客户机收到后，发送确认已接收，完成tcp建立<br>    6.浏览器发出http协议的get请求等；<br>    7.服务器响应，并指定文件发送给浏览器；<br>    8.浏览器显示所有页面<br>2.版本2<br>    1.浏览器输入URL<br>    2.浏览器查看缓存，如果请求资源新鲜，则显示（建立连接？）<br>    3.浏览器缓存<br>        1.如果未还缓存，发起新请求<br>        2.浏览器查看缓存，如果新鲜，返回给客户端<br>        3.浏览器解析URL获取协议，主机，端口号，path<br>        4.组装HTTP请求报文<br>        5.浏览器获取主机ip地址，过程如下：<br>            1.浏览器缓存<br>            2.操作系统缓存<br>            3.hosts文件缓存<br>            4.路由器缓存<br>            5.isp DNS缓存<br>            6.DNS递归查询<br>        6.打开socket与ip地址，建立tcp连接<br>        7.TCP建立后发送http请求报文<br>        8.服务器接受请求并解析，将请求转发到服务器程序<br>        9.检查是否缓存信息，以及缓存信息是否新鲜<br>        10.将请求信息返回给浏览器<br>        11.四次挥手<br>        12.资源缓存<br>    版本3<br>    1.浏览器先尝试从hosts文件获取对应的ip地址。如果没有，则使用DNS协议来获取IP.<br>        1.浏览器查找缓存，是否有ip地址，无则继续<br>        2.操作系统操作缓存，无则继续<br>        3.路由器查找缓存，无则继续<br>        4.本地服务器查找缓存，无则继续<br>        5.根-&gt;顶级-&gt;权威<br>        6.告知其ip地址<br>    2.使用TCP协议，建立tcp连接。<br>        前提：需要用到ip协议 ARP协议<br>        1.发送syn x<br>        2.服务器发送syn ack x+1 y<br>        3.客户端发送syn ack y+1<br>    3.使用Http协议请求网页内容<br>    版本4<br>    1.总论：<br>        i.域名解析成ip地址；<br>        ii.与目的主机进行tcp连接(三次握手);<br>        iii.发送与收取数据(浏览器与目的主机开始http访问过程);<br>        iv.与目的主机断开tcp连接;<br>    2.域名解析成ip地址<br>        i.浏览器向本机DNS模块发出DNS请求，DNS模块生成相关的DNS报文;<br>        ii.DNS模块将生成的DNS报文传递给传输层的UDP协议单元;<br>        iii.UDP协议单元将该书封装成UDP数据报，传递给网络层的IP协议单元;<br>        iv.IP协议单元将该数据封装成IP数据包，其目的ip地址为DNS服务器的ip地址;封装好的ip数据包将传递给数据链路层的协议单元<br>        v.发送时在ARP缓存中查询相关数据，如果没有就发送ARP广播(包含带查询的IP地址，收到广播的主机检验主机的IP,符合条件的主机将含有自己MAC地址的ARP包发送给ARP广播的主机)请求，等待ARP回应;<br>        vi.得到ARP回应后，将IP地址与路由的下一跳MAC地址对应信息写入ARP缓存表;写入缓存后，以路由下一跳的地址填充目的的MAC地址，以数据帧形式转发;转发可能进行多次;<br>        vii.DNS请求到达DNS服务器的数据链路层协议单元;DNS服务器的数据链路层协议单元解析数据帧，将内部的ip数据包传递给网络层IP协议单元；DNS服务器的IP协议单元解析IP数据包，将内部的UDP数据报传递给传输层UDP协议单元;DNS服务器的UDP协议单元解析收到的UDP数据报，将内部的DNS报文传递给DNS服务单元;<br>        viii.DNS服务单元将域名解析成对应IP地址，产生DNS响应报文;DNS回应报文-&gt;UDP-IP-MAC-&gt;我的主机;本地主机收到数据帧，将数据帧-&gt;IP-&gt;UDP-&gt;浏览器;将域名解析结果以域名和IP地址对用形式写入DNS缓存表；<br>    3.与目的主机进行tcp连接<br>        1.SYN seq = x;<br>        2.SYN ACK Ack=x+1;seq = y;<br>        3.ACK Ack = y+1;<br>    4.发送与收取数据(浏览器与目的主机开始HTTP访问过程)<br>        1.浏览器向域名发出GET方法报文;—&gt;HTTP请求<br>        2.报文通过TCP-&gt;IP(DNS)-&gt;MAC(ARP)-&gt;网关-&gt;目的主机；<br>        3.目的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据；—&gt;HTTP响应：从请求信息中获取客户机想要访问的主机名，从请求信息中获客户机想要访问的web应用。从请求信息中获取客户机要访问的web资源。（即各种文件，图片，视频，文本等）读取响应的主机下web应用，web资源，用读取的web资源数据，创建一个HTTP响应。<br>        4.该HTML通过TCP-&gt;IP-&gt;MAC-&gt;网关-&gt;我的主机<br>        5.我的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP-&gt;浏览器，浏览器以网页形式显示HTML内容。<br>    5.与目的主机断开TCP连接(四次挥手)<br>        1.浏览器向目的主机发出TCP连接结束的请求报文，此时进入FIN WAIT状态；该报文FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP(DNS)-&gt;MAC(ARP)-&gt;网关-&gt;目的主机;目的主机收到数据帧，通过IP-&gt;TCP,TCP协议单元回应结束应答报文；<br>        2.目的主机收到数据帧，通过IP-&gt;TCP,TCP协议单元回应结束应答报文；<br>        3.当前收到回应，因为目的主机还有数据要传，不急于断开连接；<br>        4.该报文中ACK标志设为1，表示收到结束请求；<br>        5.目的数据发送完所有数据后，向客户端发出TCP连接结束请求报文；该报文把FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP-&gt;MAC-&gt;网关-&gt;我的主机；<br>        6.客户端收到数据帧，通过IP-&gt;TCP，TCP协议单元回应结束应答报文，此时进入TimeWait状态；<br>        7.该报文中FIN均设为1，表示结束应答；<br>        8.目的主机关闭连接；Time Wait等待结束后。</p>
<p>3.TCP/UDP区别<br>    1.TCP 面向连接可靠运输协议 UDP面向非连接不可靠<br>    2.TCP报文段首部20字节，UDP报文段8字节<br>    3.TCP有拥塞控制和流量控制，而UDP没有<br>    4.TCP连接过程有3次握手，4次挥手，时延较大，UDP时延较小<br>    5.TCP是一对一连接 UDP可以一对一一对多<br>4.GET/POST的区别<br>    1.get请求会被缓存，保留在浏览器历史记录中，可作为收藏书签，不应再处理敏感数据时使用，有请求长度限制；<br>    2.post请求不会被缓存，不会保留书签和浏览器历史记录；<br>    3.对长度没要求；<br>5.DNS使用的协议<br>    1.既使用TCP也使用UDP,UDP报文长度最大512字节，当DNS查询超过512字节时，协议的TC标志出现删除标志，这时候使用TCP发送。<br>    2.区域传送时使用TCP:<br>        1.辅域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动。如有变动，执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP；<br>        2.TCP是一种可靠连接，保证了数据的准确性。<br>    3.域名解析使用UDP<br>6.幂等<br>7.Cookie和Session区别<br>    1.Cookie是一种能够让网站服务器把少量数据存储在客户端硬盘或内存，或是从客户端的硬盘读取数据的一种技术。当你浏览某网站时，由web服务器置于硬盘上的一个非常小的文本文件，他可以记录你的用户ID,密码，浏览过的网页，停留信息；<br>    2.Session:当用户请求来自应用程序的web页时，如果该用户还没有会话，则web服务器自动创建一个Session对象。当会话过期或者被抛弃后，服务器终止该会话。<br>    3.Session采用在服务器端保持状态的方案，cookie是在客户端保持状态的方案。由于服务器端保持状态的方案在客户端需要保持一个表示，所以session机制需要借助cookie机制来达到保存标识的目的。<br>    4.Session是服务器用来跟踪用户的一种手段，每个session都有一个唯一标识：SessionID;当服务器创建了Session时，给客户端发送的响应报文包含了SetCookie字段，其中有一个名为sid的键值对，这个键值SessionID,客户端收到后就把cookie保存到浏览器，并发之后发送的请求报表都包含SessionID。Http就通过Session和Cookie这两个发送一起合作来实现用户状态跟踪，Session用于服务端，Cookie用于客户端。<br>8.TCP粘包和拆包产生的原因<br>    1.应用程序写入数据的字节大小大于套接字发送缓冲区大小;<br>    2.进行MSS大小的TCP分段。MSS是最大报文段缩写。<br>    3.payLoad大于MTU进行ip分片。MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。如果IP层有一个数据包要传，而且数据的长度比链路层的MTU大，那么IP层就回进行分片，把数据报分成若干片，让每一个片都不超过MTU。IP分片可以发生在原始发送端主机上，也可以发生在中间路由器上。<br>9.TCP粘包拆包的解决策略<br>    1.消息定长<br>    2.在包尾部增加回车空格等特殊字符进行分割，如FTP；<br>    3.将消息分为消息头和消息尾；<br>    4.其他复杂的协议；<br>10.三次握手<br>    1.建立连接时，客户端发送syn包到服务器，并进入syn_Send状态，等待服务器确认；<br>    2.服务器收到Syn包，必须确认客户的syn，同时也发送自己的syn包，此时服务器进入syn_recv状态；<br>    3.客户端端收到SYN+ACK包，向服务器发送确认包ACK,客户端和服务器进入ESTABLISHED状态，完成3次握手。<br>    4.QA:<br>        i.为了保证服务端能够收到客户端信息并且能够做出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能够做出正确的应答而进行后二次握手；<br>        ii.三次握手的本质是信道不可靠，但是通信双方需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含了什么信息，三次通信是理论上的最小值，所以三次握手不是tcp本身的要求，而是为了满足:在不可靠信道上可靠地传输信息，本质需求是，信道不可靠，数据传输要可靠，三次是最小带价值；<br>        iii.为什么进行三次握手：为了防止已失效的链接请求报文又突然传送到服务端，因而产生错误。为了解决网络中存在延迟的重复分组问题。<br>        iv.例：client发出的第一个链接请求报文段并没有丢失，而是在某个网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达Server。本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文后，就误以为是client再次发出一个新的连接请求。于是就向client发出确认报文段，同一建立连接。假设不采用三次握手，那么server确认就建立连接了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发出数据，但server却认为新的运输连接已经建立，并一直等待Client发来数据。这样就浪费了server的资源。防止造成服务端资源浪费。<br>11.Socket<br>    1.网络通信必须的五种信息:连接使用的协议，本地主机的ip地址，本地进程的协议端口，远地主机的IP地址+端口;<br>    2.建立socket:一对套接字，一个运行于客户端，一个运行于服务端。连接分为3个过程：服务器监听，客户端请求，连接确认。<br>12.四次挥手<br>    1.客户端线发送FIN,进入FIN_WAIT状态<br>    2.服务端收到FIN,发送ACK,进入CLOSE_WAIT状态，客户端收到这个ACK,进入FIN_WAIT状态<br>    3.服务端发送FIN，进入LAST_ACK状态<br>    4.客户端收到FIN,发送ACK，进入TIME_WAIT状态，服务端收到ACK,进入CLOSE状态<br>    5.QA:<br>        i.TCP协议是一种面向连接可靠的基于字节流的运输层通信协议。TCP是双全工模式，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了。主机1告诉主机2，它的数据已经全部发送完毕了；但是这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2可以发送数据到主机1；当主机2发送FIN报文段时候，这个时候表示主机2也没有数据要发送了，就会告诉主机1，之后就断开。<br>        ii.服务端在Listen状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里面发送给客户端。而关闭连接时，当收到对方的FIN。<br>13.TCP如何保证可靠传输<br>    1.三次握手<br>    2.将数据截断为合理的长度。应用数据被分割成TCP认为最适合发送的数据块；按字节编号，合理分片；<br>    3.超时重发。当TCP发出一个段后，它启动一个定时器，如果不能及时收到一个确认就重发；<br>    4.对于收到的请求给出确认响应；<br>    5.校验出包有错，丢弃报文段，不给出响应；<br>    6.对于失序数据进行重新排序，然后才交给应用层；<br>    7.对于重复数据，能够丢弃重复数据；<br>    8.流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。<br>    9.拥塞控制，当网络拥塞时，减少数据的发送。<br>14.详细介绍HTTP<br>    1.1.0和2.0的区别<br>        1.多路复用，允许单一的http/2连接同时发起多重请求-响应消息。<br>        2.二进制分帧，位于应用层和传输层之间。<br>        3.首部压缩<br>        4.HTTP2.0支持服务器推送<br>15.HTTPS和HTTP<br>    1.https协议需要到CA申请证书；<br>    2.http时超文本传输协议，信息是铭文传输;https是具有安全性的ssl加密传输协议；<br>    3.http和https使用的是完全不同的连接方式，用的端口不一样，前者是80，后者是443;<br>    4.http的连接很简单，是无状态的；https协议由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议；</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/计算机网络/">计算机网络</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/17/手写Java集合类之SkipList/" title="手写Java集合类之SkipList" itemprop="url">手写Java集合类之SkipList</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-17T01:24:31.000Z" itemprop="datePublished"> Published 2018-08-17</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-SkipList原理"><a href="#1-SkipList原理" class="headerlink" title="1.SkipList原理"></a>1.SkipList原理</h2><ol>
<li>跳跃表使用概率均衡而不是使用强制性均衡，对于插入和删除结点比传统上的平衡树更为简洁。</li>
<li>传统向有序链表中插入一个结点所需时间是O(n),查找也是O(n),使用跳跃表可以减少查找所需时间为O(n/2)。</li>
<li>每个结点不单单只包含指向下一个结点的指针，可能包含很多个指向后续结点的指针，这样就可以跳过一些不必要的结点，从而加快查找，删除等操作。<strong>对于链表内每一个结点包含多少个指向后续元素的指针，这个过程是通过一个随机函数生成器得到。</strong></li>
<li>跳表的操作<ol>
<li>重要的数据结构定义</li>
<li>初始化表</li>
<li>查找</li>
<li>插入</li>
<li>删除</li>
<li>随机数生成器</li>
<li>释放表</li>
<li>性能比较</li>
</ol>
</li>
<li></li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/跳表-SkipList/">跳表 SkipList</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/16/计算机网络 第五章 网络层/" title="计算机网络 第五章 网络层" itemprop="url">计算机网络 第五章 网络层</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-16T09:50:28.000Z" itemprop="datePublished"> Published 2018-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层—&gt;将数据从端到端，是端到端的最底层；<br>    1.网络层必须知道网络拓扑结构，所有路由器与链路的集合，并且找出一条好路;<strong>路径规划</strong><br>    2.网络层要仔细选择路由器，避免某些通信线路和路由器负载过重;<strong>负载均衡</strong></p>
<h2 id="2-网络层设计问题"><a href="#2-网络层设计问题" class="headerlink" title="2.网络层设计问题"></a>2.网络层设计问题</h2><p>1.存储转发数据包交换<br>    1.ISP网络服务提供商的设备和客户端设备<br>    2.一台主机要发送一个数据包：存储-转发数据包交换<br>        1.需要将数据包传递给最近的路由器，路由器可能在它自己的LAN上，也可能在一条通向ISP的点到点链路上；<br>        2.在该数据包到达路由器，并且路由器链路层完成了对它校验和的验证之后，它先被存储在路由器上；<br>        3.沿着路径被转发到下一个路由器，直到到达目标主机；<br>2.提供给传输层的服务<br>    1.设计目标<br>        1.向上提供的服务应该独立于路由器技术；<br>        2.应该向传输层屏蔽路由器数量，类型和拓扑关系；<br>        3.传输层可用的网络地址应该有一个统一编码方案，甚至可以跨越LAN和WAN;<br>    2.面向连接和面向非连接 </p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/计算机网络-网络层/">计算机网络 网络层</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/16/Druid源码解析之SQL解析/" title="Druid源码解析之SQL解析" itemprop="url">Druid源码解析之SQL解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-08-16T06:18:27.000Z" itemprop="datePublished"> Published 2018-08-16</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Druid源码解析之SQL解析"><a href="#Druid源码解析之SQL解析" class="headerlink" title="Druid源码解析之SQL解析"></a>Druid源码解析之SQL解析</h2><p>概述：<br>    SQL解析可以分为三层：</p>
<pre><code>    - AST抽象语法树，语句解析-&gt; MySqlStatementParser:多个表达式和词组成完整的语句 
        - SQLParser
            - errorEndPos:解析出错记录位置
            - lexer:词法解析
            - dbType:数据库类型
        - SQLStatement
            - exprParser:表达式解析类；
            - SQLCreateTableParser:建表语句解析类，其他DDL语句在SQLStatement中；
            - parseValueSize:记录解析结果集大小；
            - keepComments:是否保留注释；
            - parseCompleteValues:是否全部解析完成。
        - MySqlStatementParser
            - 静态关键词
            - exprParser:针对MySQL语句的parser;
    - 表达式解析-&gt; MySqlExprParser:表达式由词组成，用来解析出不同表达式的含义
        - SQLExprParser 
            - AGGREGATE_FUNCTIONS 统计函数的关键词
            - aggregateFunctions 保存统计函数的关键词
        - MysqlExparser
            - AGGREGATE_FUNCTIONS 针对mysql统计函数的关键词

    - 词法解析-&gt; MySqlLexer:解析出每个词的词义,部分关键词含义
        -   symbols_l2
            features
            text:保存目前整个SQL语句
            pos:当前处理位置
            mark:当前处理此开始位置
            ch:当前处理字符
            buf:当前缓存的处理词
            bufPos:用于取出词的标记，当前从text中取出的词应该是mark位置开始
            token:当前位于的关键词
            keywods:所有关键词集合
            stringVal
            lines:总行数
            dbType:数据库类型

- SQL三个重要组成部分：Parser,AST,Visitor
    - Parser 由两部分组成
        - Lexer
        - 表达式
    - AST Parser的产物，语句经过词法分析，语法分析，其结构需要以一种计算机能读懂的方式表达出来，也就是抽象语法树。
    - Visitor 遍历这颗语法树，使用visitor模式，从根节点开始遍历，一直到最后一个叶子节点，在这个过程中，不断地收集信息到一个上下文中，整个遍历过程完成后，这棵树所表达的语法含义就被保存到上下文中。使用广度优先遍历方式。
</code></pre><ol>
<li><p>涉及到的类</p>
<ol>
<li>SQLStatementParser parser = new MySqlStatementParser(sql);</li>
<li><p>MySqlStatementParser执行父类SQLExprParser的方法，这个过程在静态代码块中定义了一系列字段；<br>static {<br> String[] strings = { “AVG”, “COUNT”, “MAX”, “MIN”, “STDDEV”, “SUM” };</p>
<pre><code>AGGREGATE_FUNCTIONS_CODES = FnvHash.fnv1a_64_lower(strings, true);
</code></pre><p> AGGREGATE_FUNCTIONS = new String[AGGREGATE_FUNCTIONS_CODES.length];<br> for (String str : strings) {</p>
<pre><code>long hash = FnvHash.fnv1a_64_lower(str);
int index = Arrays.binarySearch(AGGREGATE_FUNCTIONS_CODES, hash);
AGGREGATE_FUNCTIONS[index] = str;
</code></pre><p> }<br>}<br>//执行MySqlExprParser的构造方法</p>
<p>public MySqlExprParser(String sql){<br> this(new MySqlLexer(sql));<br> this.lexer.nextToken();<br>} </p>
<p>//Lexer构造方法-&gt;SymbolTable初始化</p>
<p>Map&lt;String, Token&gt; map = new HashMap&lt;String, Token&gt;();</p>
<p>this.lexer.nextToken();</p>
</li>
</ol>
</li>
</ol>
<p>3.SQLStatement sqlStatement = parser.parseStatement();</p>
<pre><code>- parseStatement()中通过lexer.token选择对应的方法；
- 如select-&gt;this.parseSelect();
- 构造MySqlSelectParser对象
MySqlSelectParser selectParser = createSQLSelectParser();
SQLSelect select = selectParser.select();
- select()方法
    - SQLSelect select = new SQLSelect();
    - 判断是否是with
    - 如果不是构造SQLSelectQuery
        - SQLSelectQuery query = query();query()方法内部
            - 判断token是否是lparen左括号;
            - 如果不是直接到MySqlSelectQueryBlock queryBlock = new MySqlSelectQueryBlock();并且设置父类的相关属性；
            - 如果token是select,判断查询缓存是否为空；如果不为空进行匹配；
                - selectListCache.match(laxer,queryBlock);
            - 如果token是select,执行laxer.nextTokenValue();执行下一个token解析；
            - Token token = lexer.token();得到下一个token后进行解析；
            - parseSelectList(SQLSelectQueryBlock queryBlock);
                - 构建selectList,final List&lt;SQLSelectItem&gt; selectList = queryBlock.getSelectList();
                - parseSelectItem();
                - expr = new SQLAllColumnExpr();
                - lexer.nextToken();
                - return new SQLSelectItem(expr, null, connectByRoot);
            - parseInto(queryBlock);
        - 将query设置到SQLSelect中;
        - SQLOrderBy orderBy = this.parseOrderBy();
</code></pre><p>4.MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();</p>
<pre><code>- 父类构造方法
 public SchemaStatVisitor(String dbType){
    this(new SchemaRepository(dbType), new ArrayList&lt;Object&gt;());
    this.dbType = dbType;
 }
- SchemaRepository类作为构造函数入参传入，初始化SchemaRepository；
- 初始化mysql相关：consoleVisitor = new MySqlConsoleSchemaVisitor();
- 初始化MySqlConsoleSchemaVisitor的父类MySqlASTVisitorAdapter的父类SQLASTVisitorAdapter；
</code></pre><p>5.sqlStatement.accept(visitor)方法</p>
<pre><code>- priVisitor(this);这是一个空方法0-0
- accept0(SQLASTVisitor visitor);
    - 执行实现类MySqlSchemaStateVisitor的visit(SQLSelectStatement x)；
        - repository.resolve(x);
            - 内部构造一个 SchemaResolveVisitor resolveVisitor = createResolveVisitor(options);
            - createResolveVisitor(SchemaResolveVisitor.Option ...);选择不同类型的数据库；
        - resolveVisitor.visit(stmt);
            - 内部执行 resolve(SchemaResolveVisitor visitor, SQLSelect x) 方法         
            - 创建context环境：SchemaResolveVisitor.Context ctx = visitor.createContext(x);
            - SQLSelectQuery query = x.getQuery();获取query;
            - 之后执行accept(visitor)方法；
</code></pre><p>6.总结：新建MySqlStatementParser</p>
<pre><code>- 内部新建一个MySqlExprParser-&gt;MySqlLexer-&gt;读取第一个有效词:lexer.nextToken();
- 新建一个MySqlLexer-&gt;执行父类Lexer构造方法-&gt;初始化关键词
- new Lexer(String input, CommentHandler commentHandler) 或 new Lexer(String input, boolean skipComment)
    - input 输入语句
    - commentHandler 注释处理器
    - scanChar();读取第一个字符
- 初始化Lexer后，回到MySqlExprParser构造器，初始化KeyWords集合;
- 之后回到MySqlStatementParser:调用父类SQLStatementParser方法初始化;
- new SQLParser(Lexer lexer, String dbType) 完成初始化。 
</code></pre><p>7.代码分析</p>
<pre><code>- `// 新建 MySQLParser
    SQLStatementParser parser = new MySqlStatementParser(sql);
    // 使用Parser解析生成AST，这里SQLStatement就是AST，解析结果是一个SQLStatement,是一个内部维护了树状逻辑结构的类
    SQLStatement statement = parser.parseStatement();

    // 使用visitor来访问AST
    MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
    statement.accept(visitor);
    `
- 词法分析
    - SQLStatementParser parser = new MySqlStatementParser(sql);
    - 语法分析是SQLParser,词法分析Lexer,在Parser中拥有一个Lexer;
    - Lexer有两个，Lexer和其子类MySqlLexer;Lexer作为词法分析器，内部具有词汇表，以keywords表示;
    - keywords是以key为单词，value为Token的字典型结构，Token是单词的类型;
    - MySqlLexer类，除了父类的keywords外还有自己的keywords;Lexer中维护的是通用的，而MySqlLexer除了有通用还有MySQL数据库SQL方言关键字集合。
    - Parser是Lexer的使用者；
    - Lexer需要具备一个函数，能够让命令者命令它解析一个单词，而且Lexer还必须提供一个函数，供使用者获取Lexer上一次解析到的单词亿级单词的类型。
    - 在Lexer中，nextToken()方法提供了解析一个单词的需求，被调用时，就按顺序从SQL语句的开头到结尾，解析出下一个单词;
    - token()方法，则返回上一次解析的单词的Token类型，如果Token类型是标识符(Identifier)，Lexer还提供一个stringVal()方法，让使用者拿到标识符值。
    - nextToken()内部充斥着if语句和switch语句，解析单词时候，是一个个字符地解析，这个方法每次扫描一个字符，都必须判断单词是否结束，用什么方式来验证这个单词等待。这个过程是状态机运作的过程，每解析到一个字符，都要判断当前的状态，以决定应该进入下一个什么状态。
- parseStatement()方法
    - if(lexer.token() == Token.XXX) return XXX;
    - 对应select类型的语句解析
        if (lexer.token() == Token.SELECT) {
            statementList.add(parseSelect());
            continue;
        }
    - parseSelect()方法
        public SQLStatement parseSelect() {
            MySqlSelectParser selectParser = new MySqlSelectParser(this.exprParser);

            SQLSelect select = selectParser.select();

            if (selectParser.returningFlag) {
                return selectParser.updateStmt;
            }

            return new SQLSelectStatement(select, JdbcConstants.MYSQL);
         }
        - 初始化一个针对MySQL Select语句的Parser,然后调用select()方法进行解析，把返回结果SQLSelect放到SQLSelectStatement里。而这个SQLSelectStatement就是AST抽象语法树，SQLSelect是他的第一个子节点。
 - MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
     - 有了AST语法树后，需要一个visitor来访问;
     - statement调用accept方法，以visitor作为参数，进行访问；statement的实际类型是SQLSelectStatement;
     - 在Druid中一条SQL语句中的元素，无论高层次还是低层次的元素，都是一个SQLObject,statement,expr,函数，字段，条件都是一种SQLObject。SQLObject是一个接口，accept方法由SQLObject定义，目的是为了让访问者在访问SQLObject时，告知访问者一些事情，在访问过程中手机关于SQLObject的一些信息。
     - accept()在SQLObjectImpl类实现
         public final void accept(SQLASTVisitor visitor) {
                if (visitor == null) {
                    throw new IllegalArgumentException();
                }

                visitor.preVisit(this);
                //真正执行的方法
                accept0(visitor);

                visitor.postVisit(this);
         }
         - 这是一个final方法，所有子类都要遵循这个模板，在accept()前后，visitor会进行一些操作，真正访问流程在acceptor0(visitor)中，这是一个抽象方法。
     - acceptor0(SQLASTVisitor visitor)
         protected void accept0(SQLASTVisitor visitor) {
            if (visitor.visit(this)) {
                acceptChild(visitor, this.select);
            }
            visitor.endVisit(this);
         }
        - 首先使用visitor访问自己，然后决定是否访问自己的子元素。
        - MySqlSchemaStateVisitor的visit()方法:初始化自己的aliasMap,之后返回true;
            public boolean visit(SQLSelectStatement x) {
                setAliasMap();
                return true;
            }
        - 然后递归访问子元素
    - SQLObject负责通知visitor要访问的元素，visitor负责访问相应元素前中后三个过程的逻辑处理。
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Druid-SQL解析/">Druid SQL解析</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <a class="extend prev" rel="prev" href="/"><span></span>Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/k8s/" title="k8s">k8s<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Sentinel/" title="Sentinel">Sentinel<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/消息队列/" title="消息队列">消息队列<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Druid-数据库连接池/" title="Druid 数据库连接池">Druid 数据库连接池<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/netty/" title="netty">netty<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Druid-SQL解析/" title="Druid SQL解析">Druid SQL解析<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SofaRPC/" title="SofaRPC">SofaRPC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringMVC/" title="SpringMVC">SpringMVC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringAOP/" title="SpringAOP">SpringAOP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Zookeeper/" title="Zookeeper">Zookeeper<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Dubbo-SPI/" title="Dubbo SPI">Dubbo SPI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Druid/" title="Druid">Druid<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/秒杀/" title="秒杀">秒杀<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/高并发/" title="高并发">高并发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/nacos/" title="nacos">nacos<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringCloud-微服务/" title="SpringCloud 微服务">SpringCloud 微服务<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/微服务设计读书笔记/" title="微服务设计读书笔记">微服务设计读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MySQL/" title="MySQL">MySQL<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Rocky ZhouJin QQ987415811">Rocky ZhouJin QQ987415811</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
