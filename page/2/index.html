<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">






  <link rel="canonical" href="http://yoursite.com/page/2/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Rocky for Everything</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rocky for Everything</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">慢慢喜欢你</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/消息队列之消息队列的设计/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/消息队列之消息队列的设计/" itemprop="url">
                  消息队列之消息队列的设计
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 16:46:53 / Updated at: 18:03:13" itemprop="dateCreated datePublished" datetime="2018-08-09T16:46:53+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列的设计"><a href="#消息队列的设计" class="headerlink" title="消息队列的设计"></a>消息队列的设计</h2><ul>
<li>使用场景<ul>
<li>业务解耦 最终一致性 广播 削峰填谷 流量控制</li>
<li>强一致性用RPC</li>
</ul>
</li>
<li>如何设计一个消息队列<ul>
<li>配备Broker来堆积消息，消息的转存，最简单的消息队列可以做成一个消息转发器，把一次RPC看成2次RPC。</li>
<li>首先Build一个整体数据流，P-B-C;</li>
<li>利用RPC将数据流串起来，然后考虑RPC的高可用，尽量做到<strong>无状态</strong>；</li>
<li>考虑如何承载消息堆积，并且在合适的时机投递消息，最加方式就是存储。存储的选型需要综合考虑性能和可靠性，开发维护成本等等。</li>
<li>为了广播功能，我们需要维护消费关系，利用ZK或其他。</li>
</ul>
</li>
<li><p>高级特性</p>
<ul>
<li><p>RPC通信协议</p>
<ul>
<li>消息队列就是2次RPC加一个转存。加上消费端的确认所以大概是3次。从而牵涉到负载均衡，服务发现，通信协议，序列化等。</li>
<li>利用现有的RPC框架。</li>
</ul>
</li>
<li><p>高可用</p>
<ul>
<li>所有的高可用都依赖于rpc和存储的高可用。</li>
<li>幂等</li>
</ul>
</li>
<li>服务端承载消息堆积的能力<ul>
<li>错峰流控最终可达</li>
<li>持久化非持久化</li>
</ul>
</li>
<li>消费关系解析<ul>
<li>点对点 </li>
<li>广播</li>
</ul>
</li>
</ul>
</li>
<li>更高特性<ul>
<li>可靠投递（最终一致性）<ul>
<li>完全不丢消息—&gt;消息重复—&gt;每次要发生不可靠的事情之前，先将消息落地，然后发送。当失败或者不知道成功失败时，消息状态时待发送，定时任务不停的轮询所有待发送消息，最终一定可达。</li>
<li>具体：<ul>
<li>Producer往broker发送消息之前，先落地；请求到server后，server确保数据落地后再告诉客户端发送成功。</li>
<li>支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都Ok才可以删除消息。</li>
<li>对于各种不确定(超时，宕机，消息没有送达，送达后没有落地，数据落地后没有回复)都属于消息没有送达。</li>
<li>重推消息所面临的就是消息重复。重复和丢失就像两个噩梦。</li>
</ul>
</li>
</ul>
</li>
<li>消费确认<ul>
<li>当Broker把消息投递给消费者后，消费者可以立即响应收到这个消息。但是这只是第一步，能否消费却不一定。或许是因为消费能力的问题，系统的符合已经不能处理这个消息；或者刚才状态机里面提到的消息不是想要的，主动要求重复。</li>
<li>消息的送达和消息的处理分开，实现了消息队列的本质。</li>
<li>对于reject和error，需要特别说明，滑动窗口/池</li>
</ul>
</li>
<li>重复消息和顺序消息<ul>
<li>顺序消息-&gt;发送方到服务方接收者都是单点单线程。</li>
<li>没有绝对的顺序消息。</li>
<li>在保证不丢消息的情况下，减少重复消息，不保证消息的投递顺序。</li>
<li>消息重复：如何鉴别，并幂等处理，如何减少重复消息的投递。</li>
<li>每个消息都有唯一身份。通过数据库/bloomfilter/分布式kv中的key都可以进行去重。</li>
<li>通过版本号识别消息重复，状态机识别</li>
</ul>
</li>
</ul>
</li>
<li><p>消息队列的事务 — RocketMQ</p>
<ul>
<li>2PC<ul>
<li>prepare阶段—投票阶段，协调者向参与者确认是否可以共同提交。</li>
<li>commit阶段—得到全部参与者的所有回到后，协调者向所有的参与者发布共同提交或者共同回滚的指令。</li>
<li>2pc的问题：超时状态，在发送完提交指令后，参与者没有收到提交或者回滚的指令时，此时不会是否资源。不足：同步阻塞 单点问题 数据不一致 保守</li>
</ul>
</li>
<li><p>3PC</p>
<ul>
<li>在commit之前增加了preCommit过程，使得在参与者收不到确认时，依然可以从容commit或者rollback,避免资源锁定太久而导致浪费。缺点：实现复杂 </li>
</ul>
</li>
<li><p>TCC补偿性事务</p>
<ul>
<li>分为try confirm cancel</li>
<li>事务管理器记录全局事务的推进状态，以及子事务的执行状态，负责推进各个子事务共同进行提交或者回滚。同时负责在子事务处理超时后不停重试，重试不成功后转手工处理，保证事务的最终一致性。</li>
<li>优点：在尝试阶段仅仅时业务系统做验测，并保留业务资源，并没有真正提交。TCC仅需要释放保留资源，降低补偿成本。隔离性高</li>
</ul>
</li>
<li>事务消息<ul>
<li>事务消息的本质：消费加积分业务</li>
</ul>
</li>
</ul>
</li>
<li>RocketMQ事务消息<ul>
<li>设计原则是为了解决Producer端的消息发送与本地事务执行的原子性问题。</li>
<li>RocketMQ的设计中broker与producer端的双向通信能力，使得broker天生可以作为一个事务协调者存在；</li>
<li>RocketMQ本身提供存储机制，为事务消息提供持久化能力；</li>
<li>RocketMQ的高可用机制以及可靠消息设计，为事务消息在系统发生异常时，依然能够保证事务达到最终一致性。</li>
</ul>
</li>
<li>RocketMQ事务消息设计<ul>
<li>事务消息作为一种异步确保型事务，将两个事务分支通过MQ进行异步解耦，RocketMQ事务消息的设计流程借鉴了两阶段提交理论。</li>
<li>过程：<ul>
<li>事务发起方首先发送prepare消息到MQ;</li>
<li>在发送prepare消息成功后执行本地事务;</li>
<li>根据本地事务执行结果返回commit或者是rollback;</li>
<li>如果消息是rollback，MQ将删除该prepare消息不进行下发，如果是commit消息，MQ将会把这个消息发送给consumer端。</li>
<li>如果执行本地事务过程中，执行端挂掉，或者超时，MQ将会不停地询问其同组的其他producer来获取状态。</li>
</ul>
</li>
<li>RocketMQ通过使用HalfTopic以及Operation Topic两个内部队列来存储事务消息推送状态。<ul>
<li>Half Topic对应队列中存放prepare消息，Operation Topic对应的队列则存放了prepare message对应的commit/rollback消息，消息体中则是prepare message对应的offset，服务端通过对比两个队列的差值来找到尚未提交的超时事务进行回查。</li>
</ul>
</li>
<li>从用户侧来说，用户需要分别实现本地事务执行，以及本地事务回查方法，只需要关注本地事务的执行状态即可。</li>
<li>在service层，对事物消息的两阶段提交进行了抽象，同时针对超时事务实现了回查逻辑，通过不断扫描当前事务推进状态，来不断反向请求Producer端获取超时事务的执行状态，在避免事务挂起的同时，也避免了Producer端的单点故障。</li>
<li>在存储层，RocketMQ通过Bridge封装了与底层队列存储的相关操作，用以操作两个对应的内部队列，用户也可以通过其他存储介质来实现自己的service，RocketMQ会通过ServiceProvider加载进来。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/消息队列之Kafka与RocketMQ的对比/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/消息队列之Kafka与RocketMQ的对比/" itemprop="url">
                  消息队列之Kafka与RocketMQ的对比
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 16:28:03 / Updated at: 16:47:23" itemprop="dateCreated datePublished" datetime="2018-08-09T16:28:03+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="消息队列之Kafka与RocketMQ的对比"><a href="#消息队列之Kafka与RocketMQ的对比" class="headerlink" title="消息队列之Kafka与RocketMQ的对比"></a>消息队列之Kafka与RocketMQ的对比</h2><ul>
<li>部署和模型<ul>
<li>部署<ul>
<li>RocketMQ 主从架构 一主多从 </li>
<li>Kafka 互为主从 一个Broker既可以是某个分区的主副本也可以是从副本</li>
</ul>
</li>
<li>存储模型<ul>
<li>Kafka:Topic_A的每个partition都有commitLog来存储消息，每个CommitLog有多个Segment,当Segment写满，或则Segment对应的index写满，或者Segment超时，就会重新创建一个Segment来存储该Partition的消息。每个Segment都有一个index文件，是一个稀疏索引，当Segment写入的消息超过一定数量后，往index写入一条记录。</li>
<li>RocketMQ:Topic_A有3各ConsummeQueue，两主一备，Broker_A,B,Master对外提供服务。Index可以根据key和temeStamp来查询。</li>
</ul>
</li>
</ul>
</li>
<li>有序消息<ul>
<li>kafka:都是一个topic多个partition场景，保证每个Partition里面的消息都是有序的。一个topic可以配置多个partition,producer在发送消息的时候，按照一定的策略选择partition来写消息，保证同一个订单的消息，写到同一个partition上。</li>
<li>RocketMQ:一个Topic可以有多个consumerQueue,每个queue里面消息是有序的。</li>
</ul>
</li>
<li>发送端负载均衡<ul>
<li>hash,随机缓存</li>
</ul>
</li>
<li>消费端负载均衡<ul>
<li>kafka当有consumer加入到comsumerGroup,会发送JoinGroup消息给Coordinator,Coordinator收集到所有的消息，会选择一个主Consumer，把执行的Comsumer消息以及Partition消息发送给他。然后同步告知其他Consumer</li>
</ul>
</li>
<li>数据可靠性<ul>
<li>kafka:支持同步/异步复制，异步刷盘</li>
</ul>
</li>
<li>消息投递的实时性<ul>
<li>kafka使用段轮询方式，实时性取决于轮询周期</li>
<li>RocketMQ使用长轮询，通过push方式实现</li>
</ul>
</li>
<li>消费失败重试<ul>
<li>Kafka不支持</li>
<li>RocketMQ支持定时重试</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/消息队列之RocketMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/消息队列之RocketMQ/" itemprop="url">
                  消息队列之RocketMQ
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 15:55:19 / Updated at: 16:27:18" itemprop="dateCreated datePublished" datetime="2018-08-09T15:55:19+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="RocketMQ-介绍"><a href="#RocketMQ-介绍" class="headerlink" title="RocketMQ 介绍"></a>RocketMQ 介绍</h2><ul>
<li>概述<ul>
<li>推模式</li>
<li>拉模式-长连接，低延迟</li>
</ul>
</li>
<li>组成<ul>
<li>NameServer:轻量级方式提供服务发现和路由功能，每个NameServer存有全量的路由信息，提供对等的读写服务，支持快速扩容。负责对数据源的管理，包括Topic和路由信息的管理，Broker启动的时候会去nameServer注册并定时发送心跳，Producer启动的时候会到NameServer上拉取Topic所属的broker具体地址，然后向具体的broker发送消息。</li>
<li>Producer:由用户进行分布式部署，消息由producer通过多种负载均衡策略发送到Broker集群，发送低延时，支持快速失败。</li>
<li>Consumer:由用户部署，支持push和pull两种消费模式，支持集群消费和广播消费，通过实时的消息订阅。</li>
</ul>
</li>
<li>消息模型<ul>
<li>Message</li>
<li>Topic</li>
<li>Queue</li>
<li>Group</li>
</ul>
</li>
<li>服务端整体架构设计<ul>
<li>最上层授权和认证部分，TCP基于自行研发的线路层协议，需要编解码以及序列化。</li>
<li>健康检查</li>
<li>流控和熔断措施，对系统进行流量保护，针对不同维度的流量控制</li>
<li>存储</li>
</ul>
</li>
<li>SDK架构图<ul>
<li>首先发现服务，需要找到发送消息或者接收消息具体的broker,以及broker上topic；</li>
<li>然后SDK还需要保持长连接活；</li>
<li>其次流量控制熔断机制</li>
<li>保证实现高科而用，需要提供补偿机制，重投和重复。</li>
<li>元信息通知更新消息。</li>
</ul>
</li>
<li><p>技术点</p>
<ul>
<li><p>消息的顺序</p>
<ul>
<li>RocketMQ全局保序，保证对通道的单一实例操作，单进程，单线程，线程读；</li>
<li>牺牲吞吐量</li>
</ul>
</li>
<li><p>消息去重：失败重传</p>
</li>
<li>分布式挑战：RocketMQ追求AP,通常情况下，通过降级，限流，熔断机制来保证洪峰下的可用性。金融级高频交易典型场景：CP机制，牺牲可用性来保证数据一致性。基于ZAB协议，利用分布式锁和通知机制来保证多副本数据的一致性。</li>
</ul>
</li>
<li>优化<ul>
<li>JVM停顿 GC 线程池 CPU 内存 网卡</li>
</ul>
</li>
<li><p>对比</p>
<ul>
<li>Kafak和RocketMQ都是磁盘消费队列模式，对于同一个消费组，一个分区只支持一个线程新消费消息，过少的分区会导致消费速度大大落后于消息生成速度。在实际的生产环境中，一个topic会设置成多个分区的模式来支持多个消费者。</li>
<li>分区增大性能下降的原因:Kafka的每个topic，每个分区都会对应一个物理文件，当topic增加时，消息分散的落盘策略会导致磁盘I/O竞争激烈。而RocketMQ所有的消息都保持在同一个物理物件中，topic和分区数对rocketMQ也支持逻辑上的划分，不会增大太多影响。</li>
<li><p>容量保证的策略：降级，限流，熔断</p>
<ul>
<li>降级：暂停边缘服务，保证核心服务的资源。</li>
<li>在有限资源情况下，所提供的单位时间服务能力是有限的，如果超过了承受能力，可能会带来整个服务的停顿。应用的Crash，进而风险传递给服务调用方造成整个系统的服务能力丧失，进而引发雪崩。</li>
<li><p>典型的限流算法:漏桶算法和令牌算法</p>
<ul>
<li>漏桶算法 一个桶以恒定的速率滴出，上方滴入速率超过滴出速率，就会导致水桶溢出过载。</li>
<li>令牌桶算法 令牌以恒定速率放入桶，桶内令牌数有上限，每个请求会获取一个令牌，如果没有令牌了，则这个请求时过载的。</li>
<li>信号量</li>
</ul>
</li>
<li><p>熔断：在分布式系统中，如果调用的远程服务或者资源由于某种原因无法使用时，没有过载保护就会导致请求资源阻塞在服务器上等待从而消耗掉系统或服务器资源。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/分布式学习之高并发总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/分布式学习之高并发总结/" itemprop="url">
                  分布式学习之高并发总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 15:26:21 / Updated at: 15:53:48" itemprop="dateCreated datePublished" datetime="2018-08-09T15:26:21+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="分布式学习之高并发总结"><a href="#分布式学习之高并发总结" class="headerlink" title="分布式学习之高并发总结"></a>分布式学习之高并发总结</h2><ul>
<li><p>千万级高并发总结：</p>
<ol>
<li>所有的性能提升，最终落在CPU,内存，IO，网络这4块。</li>
<li>抽象能力，分类能力，算法</li>
<li>客户端-&gt;接入层-&gt;后台（搜索，平台，大数据）</li>
<li>RPC</li>
<li>消息中间件：两个模块之间的交互异步化，同时把不均匀的请求流量输出为匀速的输出流量，异步化解耦和流量削峰。</li>
<li>配置管理：灰度发布，服务降级</li>
<li>无状态：将有状态的东西剥离到数据层</li>
<li>分布式服务追踪解决的问题：通过唯一id</li>
</ol>
</li>
<li><p>高并发实时后台服务架构</p>
<ol>
<li>流控：扩容 ddos攻击 nginx</li>
<li>负载均衡</li>
<li>接入层：校验登陆态 无状态的横向扩展</li>
<li>逻辑层：<ol>
<li>前轻后重 RPC服务来提供和实现</li>
<li>缩短关键业务流程</li>
<li>降低单个接口处理耗时—代码架构系统部署</li>
<li>同步变异步：同步接口转化为异步接口 保证吞吐量 I/O多路复用</li>
<li>隔离:逻辑层具备业务隔离能力，整体隔离，内部隔离</li>
</ol>
</li>
<li>存储层<ol>
<li>数据快速访问 一致性安全问题 缓存 分库分表</li>
<li>数据如何同步备份</li>
</ol>
</li>
</ol>
</li>
<li>高并发与实时处理技术<ul>
<li>高并发下缓存治理<ul>
<li>I/O是导致IT系统无法完成高并发的主要原因。</li>
<li>解决I/O速度问题就是将计算结果临时存储，也就是缓存。</li>
<li>缓存治理的困难<ul>
<li>应用无感的合理使用缓存</li>
<li>对现有缓存乱使用的迁移</li>
<li>缓存研发方案—缓存场景隔离化，数据量分配的合理化以及缓存的分离。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>常见并发同步案例分析</p>
<ul>
<li><p>订票系统案例</p>
<ul>
<li>锁同步：程序层面，多个线程进来，只有一个一个访问。锁有两个层面，一个是java的对象锁，用于线程同步；另一个是数据库锁，如果是分布式系统，只能用数据库端的锁来实现。</li>
<li>乐观锁和悲观锁 乐观锁在不锁定表的情况，利用业务来控制解决并发问题。保证并发可读+数据存储的排他性+保证性能同时解决并发带来的脏数据问题。</li>
</ul>
</li>
<li><p>股票交易</p>
<ul>
<li>表拆分 按业务拆分 时间轴分区</li>
<li>缓存</li>
</ul>
</li>
<li><p>高并发提高访问效率手段</p>
<ul>
<li>瓶颈：服务带宽 web线程连接数 数据库连接查询</li>
<li>增加带宽，DNS域名解析 负载均衡 前置代理服务器 数据库查询优化，读写分离，分表。</li>
<li>复制在高并发的情况：尽量使用缓存，用户缓存，信息缓存，大量减少与数据库的交换，提高性能。 找出性能瓶颈，减少额外开销，优化查询语句。单台机器的瓶颈。</li>
</ul>
</li>
</ul>
</li>
<li>1500万QPS背后的高性能，高可用实时搜索系统架构演变</li>
<li>12306如何实现流量并发的关键技术<ul>
<li>关键技术<ul>
<li>利用云计算资源分担系统查询业务，弹性扩展</li>
<li>双中心运行架构</li>
<li>带宽保证</li>
<li>防恶意抢票</li>
<li>应急方案</li>
</ul>
</li>
<li>设计思路    <ul>
<li>关联数据节点设计</li>
<li>将数据移到内存</li>
</ul>
</li>
</ul>
</li>
<li>金融环境高并发方案</li>
<li></li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/分布式学习之秒杀系统架构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/分布式学习之秒杀系统架构/" itemprop="url">
                  分布式学习之秒杀系统架构
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 15:07:08 / Updated at: 15:22:33" itemprop="dateCreated datePublished" datetime="2018-08-09T15:07:08+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##秒杀系统架构##<br>1.秒杀系统特点</p>
<pre><code>- 瞬时并发量大，大量用户会在同一时间进行抢购，网站瞬时流量访问激增；
- 库存少：访问请求数量远远大于库存数量，只有少部分用户能够秒杀成功。
- 业务流程简单：业务流程比较简单，下单减库存。
</code></pre><p>2.技术难点</p>
<pre><code>- 对现有业务的冲击
- 高并发应用负载高
- 突然增加网络与服务带宽
- 直接下但
- 控制商品页面购买按钮高亮
- 下单前置检查
</code></pre><p>3.架构思想</p>
<pre><code>- 限流：限制大部分用户流量，只有少部分用户能够进入后端服务器
- 削峰：秒杀开始一瞬间，会有大量用户冲击进来，会有一个瞬时流量峰值。通过缓存或者MQ中间件来解决。
- 异步处理：异步处理模式可以极大提高系统并发量
- 内存缓存：最大瓶颈是数据库的读写，下单扣减库存，属于磁盘IO,性能低，把部分数据业务逻辑转移到内存缓存，效率极大提升。
</code></pre><p>4.优化</p>
<pre><code>客户端优化
- 秒杀页面优化：页面整体静态化，将静态化页面发送到CDN边缘节点上，压力分散的作用。
- 防止提前下单：在静态页面加入一个JS,这个js文件包含活动是否开启的标志以及开始时动态下单页面的url参数，同时这个js不会被cdn缓存，会一直请求后端服务。并且很小，活动快要开始时，通过后台接口修改这个js使之生效。
api接入层优化
- 限制用户维度访问频率
- 限制商品维度访问频率
soa服务器层优化
-后端流量控制，通过消息队列，异步处理，提高并发等方式解决，对于超过系统水位线的请求，使用fail-fast原则拒绝掉。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/Zookeeper系列之分布式事务总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/Zookeeper系列之分布式事务总结/" itemprop="url">
                  Zookeeper系列之分布式事务总结
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 11:44:54 / Updated at: 13:31:42" itemprop="dateCreated datePublished" datetime="2018-08-09T11:44:54+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##1.分布式事务解决方案##</p>
<ul>
<li><p>基于XA协议的两阶段提交方案</p>
<ul>
<li>第一阶段：表决阶段，所有参与者将本事务能否成功的信息反馈发送给协调者；</li>
<li>第二阶段是执行阶段，协调者根据所有参与者的反馈，通知所有参与者，一致地在所有分支上提交或者回滚。</li>
<li>本地资源管理器 事务协调器</li>
<li>借助数据库的XA协议协调数据库资源，借助数据库的MVCC特性达到一致性读写。</li>
</ul>
</li>
<li><p>TCC方案</p>
<ul>
<li>将整个业务逻辑的每个分支显示的分成了Try,Confirm,Cancel三个操作。</li>
<li>Try部分完成业务的准备工作，Confirm部分完成业务的提交，Cancel部分完成事务的回滚。</li>
<li>事务开始时，业务应用会向事务协调器注册启动事务。之后业务应用会调用所有服务的try接口，完成一阶段准备。之后事务协调器会根据try接口返回情况，决定调用confirm接口或者cancel接口。如果接口调用失败会进行重试。 </li>
<li>优点：应用自己定义数据库操作的粒度，使得降低锁冲突，提升吞吐量。</li>
<li>缺点：<ul>
<li>对应用的侵入性强。业务逻辑的每个分支都需要实现try,confirm,cancel。入侵大</li>
<li>实现难度大。需要按照网络状态，系统故障等不同的失败原因实现不同的回滚策略。为了满足一致性要求，confirm和cancel接口必须实现幂等。</li>
</ul>
</li>
</ul>
</li>
<li>基于消息的最终一致性方案<ul>
<li>消息一致性方案是通过消息中间件保证上下游应用数据操作的一致性。</li>
<li>基本思路: 将本地操作和发送消息放在一个事务中，保证本地操作和消息发送要么两者都成功或者都失败。下游应用向消息系统订阅该消息，收到后执行相应操作。</li>
<li>本质：将分布式事务转换为两个本地事务，依靠下游业务得重试机制达到最终一致性。</li>
</ul>
</li>
<li>FMT:无入侵得分布式事务解决方案，该模式下只需要关注一阶段操作，框架会自动解析SQL语义生成二阶段提交和回滚操作，使分布式事务得接入更便捷。</li>
<li>蚂蚁金服的分布式事务解决方案DTX<ul>
<li>整体架构：<ul>
<li>以Base理论的最终一致性为基础，以两阶段提交为基本执行框架。整体架构上分为3部分：客户端，资源管理器，事务管理器</li>
<li>客户端：通过事务管理器来开启结束分布式事务，通过资源管理器编排分布式事务活动。</li>
<li>资源管理器：负责具体资源的准备，提交和回滚操作，并在整个执行过程中记录事务日志，向事务管理器汇报事务日志和资源执行状态。</li>
<li>事务协调器：负责协调分布式事务的执行:开启分布式事务，记录资源管理器提交的事务日志和资源状态，决定分布式事务最终使提交还是回滚。</li>
</ul>
</li>
<li>DTX执行<ul>
<li>DTX按照两阶段提交的方式执行分布式事务，在第一阶段，客户端首先通过事务管理器开启分布式事务；分布式事务开启后，客户端在分布式事务内编排事务内资源，依次执行各个资源的一阶段准备操作，每个资源的准备操作执行情况资源管理器都会向事务管理器汇报，资源编排结束之后，客户端会通知事务管理器分布式事务一阶段结束。</li>
<li>在第二阶段，事务管理器会根据事务所有资源的一阶段执行情况，决定整个分布式事务最终是提交还是回滚，进而驱动所有资源二阶段的提交/回滚。 </li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/Redis缓存系列之数据库缓存一致性问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/Redis缓存系列之数据库缓存一致性问题/" itemprop="url">
                  缓存系列之数据库缓存一致性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 11:40:48" itemprop="dateCreated datePublished" datetime="2018-08-09T11:40:48+08:00">2018-08-09</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/09/缓存系列之数据库缓存一致性问题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/09/缓存系列之数据库缓存一致性问题/" itemprop="url">
                  Redis系列之数据库缓存一致性问题
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-09 11:40:48 / Updated at: 15:04:41" itemprop="dateCreated datePublished" datetime="2018-08-09T11:40:48+08:00">2018-08-09</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Redis缓存数据库一致性问题##</p>
<ul>
<li>数据一致性处理<ul>
<li>当多个进程同时操作同一个数据，会产生资源争抢，数据一致性的问题。</li>
<li>高并发情况下，涉及到写操作时，不能直接操作数据库，大量并发连接会导致mysql请求会阻塞，大量的insert update请求到，会导致无数的行锁和表锁，最后堆积很多，触发too many connections错误。</li>
</ul>
</li>
<li>消息队列<ul>
<li>将票数资源存入redis中，将请求存入消息队列，list会阻塞，但是依次处理，导致等待时间较长。</li>
</ul>
</li>
<li>加锁<ul>
<li>排他锁，乐观锁，悲观锁</li>
<li>排他锁：进行写时，禁止一切读写；</li>
<li>乐观锁：在写的时候，默认没有资源竞争，维护一个Version号，等处理后对照version号，一致则提交，否则回滚。</li>
<li>悲观锁：在写的时候，别人也再写。采用数据库提供的锁机制：在写操作的时候(insert update)myisam采用表锁，innodb根据主键与否来决定是行锁还是表锁。读操作采用MVCC版本控制。</li>
</ul>
</li>
<li>需求起因<ul>
<li>假设先写数据库，再淘汰缓存:第一步写数据库成功，第二步淘汰缓存失败，则BD中是新数据，Cache中是旧数据，数据不一致。</li>
<li>假设先淘汰缓存，再写数据库：第一步淘汰缓存成功，第二步写数据库失败，则缓存中无数据，数据库中是旧数据。</li>
<li>先淘汰缓存，再写数据库</li>
</ul>
</li>
<li>数据不一致原因<ul>
<li>先操作缓存，再数据库成功之前，如果有读请求发生，可能导致旧数据入缓存，引发数据不一致。</li>
<li>写流程：<ul>
<li>先淘汰缓存</li>
<li>再写DB</li>
</ul>
</li>
<li>读流程<ul>
<li>先读cache,如果数据命中hit则返回；</li>
<li>如果数据未命中miss则读DB;</li>
<li>将DB中读取出来的数据入缓存。</li>
</ul>
</li>
</ul>
</li>
<li>问题解决思路—串行化</li>
<li>Redis数据库与缓存一致性解决方案<ul>
<li>数据库与缓存读写模式策略—写完数据库后是否需要马上更新缓存还是直接删除缓存？<ul>
<li>如果写数据库的值与更新到缓存值是一样的，不需要经过任何计算可以马上更新缓存，但是对于写数据频繁而读数据少的场景并不合适这个解决方案。</li>
<li>如果写数据库的值与更新缓存的值不一致，写入缓存中的数据需要经过几个表的关联计算后得到的结果插入缓存中，那么没必要立即更新缓存，删除缓存即可，等到查询的时候把计算结果插入到缓存中即可。</li>
<li>一般的策略是当更新数据时，先删除缓存，再更新数据库。</li>
</ul>
</li>
<li>数据库与缓存双写情况下导致数据不一致问题<ul>
<li>场景1：当更新数据时，如更新某商品的库存，当前商品的库存为100，而现在为99，先更新数据库改成99，然后删除缓存，发现删除缓存失败，这时数据库存99，而缓存存100，导致缓存数据库不一致。</li>
<li>解决方案：这种情况先删除缓存，再更新数据库。<strong>如果缓存删除失败就不更新数据库</strong>，如果说缓存删除成功，而数据库更新失败，那查询到的是数据库的旧数据，不会造成缓存数据库不一致的情况。</li>
<li>场景2：在高并发情况下，如果当删除出完缓存的时候，这是去更新数据库，但是还没有更新完，这时另一个请求来查询，发现缓存没有，就去数据查。数据库中100，查到后加入缓存，插入完缓存后，原来那个数据库的线程把数据库更新为99，导致缓存数据库不一致。</li>
<li>场景2解决：<ul>
<li>读请求时长阻塞</li>
<li>请求并发量过高</li>
<li>多服务实例部署的请求路由</li>
<li>热点商品的路由问题，导致请求倾斜</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/08/Spring源码解析之AOP实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/08/Spring源码解析之AOP实现/" itemprop="url">
                  Spring源码解析之SpringAOP实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-08 14:50:15 / Updated at: 21:56:08" itemprop="dateCreated datePublished" datetime="2018-08-08T14:50:15+08:00">2018-08-08</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-SpringAOP概述"><a href="#1-SpringAOP概述" class="headerlink" title="1.SpringAOP概述"></a>1.SpringAOP概述</h2><ul>
<li>常见AOP技术:事务管理，安全检查，缓存，对象池管管理。<ol>
<li>静态代理：AspectJ，使用AOP框架提供的命令进行编译，从而在编译阶段生成AOP代理类，编译时增强；在编译时自动得到一个新类，这个类具有增强原来类的功能。性能更优。</li>
<li>动态代理：SpringAOP，在运行时借助于JDK动态代理，Cglib等技术在内存中临时生成AOP动态代理类，运行时增强。不需要在编译时增强，而是运行时生成目标类的代理类，该代理类要么与目标接口是相同的接口，要么是目标类的子类。采用运行时动态地，在内存中临时生成代理类。</li>
<li>AOP代理是由AOP框架生成了一个代理对象，该对象作为目标对象使用。AOP代理包含了对目标对象的全部方法，差别在于对于特定切入点添加了增强处理，并回调了目标对象的方法。</li>
<li>Cglib生成代理类:<ol>
<li>Enhancer en = new Enhance();</li>
<li>en.setsuperClass(Chinese.class);</li>
<li>en.setCallback(new AroundAvice());</li>
<li>return (Chinese) en.create();</li>
</ol>
</li>
<li>Advice PointCut Advisor(Adivce PointCut)</li>
</ol>
</li>
</ul>
<h2 id="2-Spring-AOP的设计与实现"><a href="#2-Spring-AOP的设计与实现" class="headerlink" title="2.Spring AOP的设计与实现"></a>2.Spring AOP的设计与实现</h2><ul>
<li>动态代理特性:为任意java对象创建代理对象，通过ReflectionAPI来实现。</li>
<li>InvocationHandler-&gt;invoke(Object proxy,Method method, Object[] args)<ul>
<li>第一个参数是代理对象</li>
<li>第二个参数是Method方法对象，代表被调用的方法</li>
<li>第三个参数是被调用方法中的参数</li>
</ul>
</li>
</ul>
<ul>
<li>应用场景：日志和事务</li>
<li><p>建立AopProxy代理对象</p>
<ul>
<li>设计原理：代理对象的生成，通过配置和调用ProxyFactoryBean来完成。ProxyFactoryBean封装了代理对象的生成，包括Jdk动态代理和Cglib两种方式。</li>
</ul>
</li>
<li><p>配置ProxyFactoryBean</p>
<ul>
<li>定义通知器Advisor(Advice,PointCut)来定义一个Bean定义了需要对目标对象进行增强的切面行为，也就是Advice通知。</li>
<li>定义ProxyFactoryBean，封装了AOP功能的主要类。需要设定与Aop实现相关的重要属性，如proxyInterface,interceptorNames(通知器名)和target等。</li>
</ul>
</li>
<li>ProxyFactoryBean生成AopProxy代理对象<ul>
<li>在ProxyFactoryBean中，通过interceptorNames属性来配置已经定义好的通知器Advisor；</li>
<li>在ProxyFactoryBean中，需要为target目标对象生成Proxy代理对象，为AOP横切面的编织做好准备工作。</li>
<li>ProxyBeanFactory的AOP实现需要依赖JDK或者CGLIB提供的Proxy特性。从FactoryBean中已getObject()方法作为入口完成。</li>
<li>getObject()方法是FactoryBean实现的接口，对于target目标对象的增强处理，通过getObject()方法来封装，这些增强是AOP功能的实现提供服务的。</li>
<li>getObject()方法首先会对通知器链进行初始化，通知器链封装一系列拦截器，所有拦截器都从配置中读取，为代理对象生成做准备。</li>
<li>生成代理对象时，需要对singleton和prototype进行区分。</li>
<li>ProxyFactoryBean#initializeAdvisorChain(){第一次通过ProxyFactoryBean去获取对象的时候，完成初始化后，会读取配置中出现的所有通知器，将通知器的名字交给容器的getBean方法}-&gt;getSingletonInstance(){根据AOP框架来判断需要代理的接口}-&gt;getProxy()-&gt;createAopProxy(){返回AopProxy代理对象，分别为JdkDynamicProxy和Cglib2AopProxy}-&gt;isInterface(){jdk动态代理}-&gt;createCglibProxy(){非接口}。</li>
</ul>
</li>
<li>JDK生成AopProxy代理对象<ul>
<li>首先从Advised对象中取得代理对象的代理接口配置，然后调用Proxy的newInstance()生成Proxy代理对象。并指明三个参数，类装载器代理接口，Proxy回调方法所在的对象，这个对象需要实现InvocationHandler的invoker方法，提供代理对象回调的入口。</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/07/Spring源码系列之SpringMVC容器加载初始化过程解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/07/Spring源码系列之SpringMVC容器加载初始化过程解析/" itemprop="url">
                  Spring源码系列之SpringMVC容器加载初始化过程解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-07 22:55:37 / Updated at: 23:51:55" itemprop="dateCreated datePublished" datetime="2018-08-07T22:55:37+08:00">2018-08-07</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##SpringMVC在Web环境中的加载##</p>
<p>###1.概述###<br>    SpringIoC是一个独立的模块，并不是直接在Web容器中发挥作用，如果需要在Web容器环境建立使用IoC容器,需要为SpringIoC设计一个启动过程，把IoC容器导入，并在Web容器中建立。在这个过程中，一方面是web容器的启动，另一方面是通过设计特定的web容器拦截器，将IoC容器以拦截的形式载入到web容器中，并将其初始化。而SpringMVC是在IoC容器的基础上建立的MVC运行机制，从而响应Web容器传递的Http请求。</p>
<p> Tomcat容器中web.xml部署<br>-<br>    <servlet><br>        <servlet-name><br>        <servlet-class><br>        <load-on-startup><br>    </load-on-startup></servlet-class></servlet-name></servlet><br>    <servlet-mapping><br>        <servlet-name></servlet-name><br>        <url-pattern>/*</url-pattern><br>    </servlet-mapping><br>    <context-param><br>        <param-name>contextConfigLocation</param-name><br>        <param-value>/WEB-INF/applicationContext.xml</param-value><br>    </context-param><br>    <listener><br>        <listener-class><br>            ContextLoaderListener<br>        </listener-class><br>    </listener></p>
<ul>
<li>这里部署了SpringMVC与Tomcat的接口。首先定义了一个Servlet对象；</li>
<li>同时部署了了这个Servlet对应的URL映射，这些URL映射为这个Servlet指定了需要处理的Http请求</li>
<li>context-param参数的配置用来指定Spring IoC容器读取Bean定义的xml文件。在这个xml文件中读取到Spring的配置。</li>
<li>ContextLoaderListener作为SpringMVC的启动类，被定义为一个监听器，这个监听器与Web服务器的生命周期相关，由ContextLoaderListener监听器负责完成IoC容器在web环境中的启动工作。</li>
<li>ContextLoaderListener和DispatcherServlet提供了在Web容器中对的Spring,这些接口与web容器耦合是通过ServletContext实现。</li>
<li>这个ServletContext为Spring的IoC容器提供了一个宿主环境，在宿主环境中，SpringMVC建立起一个IoC容器的体系。</li>
<li>这个体系通过ContextLoaderListener的初始化建立，建立IoC体系后，把DispatcherServlet作为SpringMVC处理web请求的转发器建立起来，从而完成响应Http请求的准备。</li>
</ul>
<p>##2.上下文在web容器中的启动##</p>
<ol>
<li><p>IoC容器启动的基本过程</p>
<ul>
<li>IoC容器的启动就是上下文建立过程，与ServletContext相伴而生，是IoC容器在Web环境中的具体表现之一；</li>
<li>ContextLoaderListener启动的上下文是根上下文。在根上下文的基础上还有一个与WebMVC相关的上下文来保持控制器需要的MVC对象，上下文的体系是由ContextLoader来完成。</li>
<li>contextInitialized()-&gt;ContextLoaderListener#initWebApplicationContext()-&gt;ContextLoader#loadParentContext()-&gt;XmlWebApplicationContext#refresh();</li>
<li>在ContextLoader中，完成了两个IoC容器的建立，一个是Web容器中建立起来的双亲IoC容器，另一个是生成响应的WebApplicationContext并将其初始化。</li>
</ul>
</li>
<li>Web容器中的上下文设计—WebApplicationContext</li>
<li>ContextLoader设计与实现<ul>
<li>Spring承载的web应用而言，可以在Web应用程序启动时载入IoC容器(WebApplicationContext)，这个功能由ContextLoaderListener来实现，是在web.xml中配置的监听器。这个监听器通过ContextLoader来完成实际的IoC容器初始化工作。</li>
<li>ContextLoader是Spring应用程序在web容器中的启动器。</li>
<li>这个监听器是启动根IoC容器并载入到web容器的主要功能模块，也是整个SpringWeb应用加载IoC的第一个地方。</li>
<li>首先从Servlet事件中得到ServletContext,然后读取配置在web.xml中的相关属性，接着实例化WebApplicationContext,完成其初始化过程。</li>
<li>这个被初始化的第一个上下文是根上下文，这个根上下文载入后，被绑定到web应用的ServletContex上。任何需要访问根上下文的应用程序代码都可以从WebApplicationContextUtils的静态方法中得到。</li>
<li>在ContextLoaderListener中，实现的是ServletContextListener接口，这个接口的方法回结合Web容器的生命周期被调用。ServletContextListener是ServletContext的监听者。如果ServletContext发生了变化，会触发相应的事件，做出预先设计的响应。</li>
</ul>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Rocky ZhouJin</p>
              <p class="site-description motion-element" itemprop="description">个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rocky ZhouJin</span>

  

  
</div>




  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
