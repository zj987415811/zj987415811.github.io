<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Rocky for Everything</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
  
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Rocky for Everything</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">个人博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Docker系列之入门介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/04/Docker系列之入门介绍/" class="article-date">
  <time datetime="2018-09-04T08:09:26.349Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <hr>
<p>title: Docker系列之入门介绍<br>date: 2018-09-04 16:09:26<br>tags: Docker</p>
<p>循序渐进学docker笔记<br>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/04/Docker系列之入门介绍/" data-id="cjptalgdi0004y4zjsdzn7x2n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Dubbo系列之Dubbo可扩展性SPI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/" class="article-date">
  <time datetime="2018-09-03T02:07:36.000Z" itemprop="datePublished">2018-09-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/">Dubbo系列之Dubbo可扩展性SPI</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-Dubbo扩展机制"><a href="#1-Dubbo扩展机制" class="headerlink" title="1. Dubbo扩展机制"></a>1. Dubbo扩展机制</h2><ul>
<li>任何系统都是从小系统不断完善的，应当关注当下的需求，然后不断对系统进行迭代。</li>
<li>代码层面，需要适当的对关注点进行抽象和隔离，在不断添加和特性时，仍然能保持良好的结构和可维护性，同时允许第三方开发者对其功能及进程扩展。</li>
<li>对扩展性的追求甚至超过了性能。</li>
<li>良好的扩展性<ul>
<li>作为框架的维护这，在添加新功能的时候，只需要添加一些新的代码，而不用大量修改现有代码，符合开闭原则</li>
<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架源码，在自己工程中添加代码即可。<h2 id="2-可扩展的集中解决方案"><a href="#2-可扩展的集中解决方案" class="headerlink" title="2. 可扩展的集中解决方案"></a>2. 可扩展的集中解决方案</h2></li>
</ul>
</li>
<li>通常有：<ul>
<li>Factory模式</li>
<li>IoC容器</li>
<li>OSGI容器</li>
</ul>
</li>
<li>Dubbo参考了Java原生的SPI机制，并进行一定扩展，以满足Dubbo需求。<h2 id="3-Java-SPI机制"><a href="#3-Java-SPI机制" class="headerlink" title="3. Java SPI机制"></a>3. Java SPI机制</h2></li>
</ul>
<ol>
<li>Java SPI(Service Provider Interface)是JDK一种动态加载扩展点的实现。</li>
<li>在ClassPath的META-INF/services目录下放置一个接口同名的文本文件，内容为接口的实现类，多个实现类用换行符分割。</li>
<li>缺点：<ul>
<li>需要遍历所有的实现，并实例化，然后才能在循环中找到我们需要的实现。</li>
<li>配置文件中只是需要简单的列出所有扩展实现，没有命名，很难定位。</li>
<li>扩展如果依赖其他扩展就做不到自动注入和装配。</li>
<li>不提供类似于Spring IOC和AOP功能。</li>
<li>很难和其他框架集成。<h2 id="4-Dubbo扩展点机制"><a href="#4-Dubbo扩展点机制" class="headerlink" title="4. Dubbo扩展点机制"></a>4. Dubbo扩展点机制</h2></li>
</ul>
</li>
<li>扩展点—Java接口</li>
<li>扩展—扩展点的实现类</li>
<li>扩展实例—扩展点实现类的实例</li>
<li>扩展自适应实例—扩展代理类</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/" data-id="cjptalgd60000y4zj0bmcruyw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Dubbo-SPI/">Dubbo SPI</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-微服务系列之深入理解SpringCloud与微服务构建" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/29/微服务系列之深入理解SpringCloud与微服务构建/" class="article-date">
  <time datetime="2018-08-29T08:25:35.000Z" itemprop="datePublished">2018-08-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/29/微服务系列之深入理解SpringCloud与微服务构建/">微服务系列之深入理解SpringCloud与微服务构建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><ol>
<li>系统的架构决定了系统能否满足业务，技术，组织，灵活，可扩展性等多种要求，同时肩负起了解放程序员生产力的作用。</li>
<li>微服务框架:服务注册和发现===Eureka组件，负载均衡Ribbon组件，熔断器Hystrix组件，路由网关Zuul组件，SpringCloud配置中心，服务链路追踪等内容。</li>
<li>微服务提出者Martin Fowler</li>
</ol>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/29/微服务系列之深入理解SpringCloud与微服务构建/" data-id="cjptalgep001iy4zj2ilfhdnf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SpringCloud-微服务/">SpringCloud 微服务</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-微服务系列之源初" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/微服务系列之源初/" class="article-date">
  <time datetime="2018-08-28T03:10:23.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/微服务系列之源初/">微服务系列之源初</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>近期安排主要路线：</p>
<ul>
<li>微服务-&gt;service mesh-&gt;dubbo相关源码<br></li>
<li>设计模式-&gt;主流框架设计模式总结</li>
<li>微服务系列主要以微服务设计+深入理解SpringCloud与微服务构建这两本书的读书笔记为主。
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/28/微服务系列之源初/" data-id="cjptalgen001gy4zjj07fzopt" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/微服务设计读书笔记/">微服务设计读书笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Sentinel系列之起源" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/Sentinel系列之起源/" class="article-date">
  <time datetime="2018-08-28T01:24:02.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/Sentinel系列之起源/">Sentinel系列之起源</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-什么是Sentinel"><a href="#1-什么是Sentinel" class="headerlink" title="1.什么是Sentinel"></a>1.什么是Sentinel</h2><blockquote>
<p>i.分布式系统的流量防卫兵；<br><br>ii.微服务架构中，服务与服务之间的稳定性变得越来越重要。Sentinel以流量为切入点，从流控，熔断，降级，系统负载保护等多个维度来提供服务稳定性支持；<br>iii.轻量级。</p>
</blockquote>
<h2 id="2-Sentinel功能"><a href="#2-Sentinel功能" class="headerlink" title="2.Sentinel功能"></a>2.Sentinel功能</h2><blockquote>
<p>i.流控，针对秒杀环境，对于突发流量可以控制在系统承受范围内；<br><br>ii.削峰填谷;<br><br>iii.实时熔断下游不可用应用;<br><br>iv.完备的监控功能:提供实时的监控功能，可以精确到秒级数据；<br><br>v.Sentinel提供简易的扩展点，快速定制逻辑，例如定制规则管理，适配数据源。</p>
</blockquote>
<h2 id="3-核心架构"><a href="#3-核心架构" class="headerlink" title="3.核心架构"></a>3.核心架构</h2><pre><code>核心库:不依赖任何框架/库，能够运行于所有java运行时环境，对Dubbo/Spring Cloud等框架有较好的支持。
控制台:基于SpringBoot开发，打包后直接运行，不需要额外的Tomcat应用容器。
</code></pre><h2 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4.基本概念"></a>4.基本概念</h2><h3 id="4-1-资源"><a href="#4-1-资源" class="headerlink" title="4.1 资源"></a>4.1 资源</h3><ol>
<li>资源是Sentinel的关键概念，可以是APP中的任意内容。如由应用程序提供的服务，或者由应用程序调用的其他应用提供的服务，或者一段代码。</li>
<li>只要通过Sentinel API定义的代码就是资源，能够被Sentinel保护起来。通常使用方法签名，URL，甚至服务名称作为资源名来标识资源。<h3 id="4-2-规则"><a href="#4-2-规则" class="headerlink" title="4.2 规则"></a>4.2 规则</h3>围绕资源的实时状态设定的规则，可以包括流量控制规则，熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</li>
</ol>
<h2 id="5-Sentinel功能合设计理念"><a href="#5-Sentinel功能合设计理念" class="headerlink" title="5.Sentinel功能合设计理念"></a>5.Sentinel功能合设计理念</h2><h3 id="5-1-流量控制"><a href="#5-1-流量控制" class="headerlink" title="5.1 流量控制"></a>5.1 流量控制</h3><p><strong>1.</strong> <strong>什么是流量控制</strong></p>
<blockquote>
<p>流控是网络传输中的常用概念，用于调整网络包的发送数据。<br><br>流控的目的是从系统的稳定性角度来考虑的，在处理请求的速度上，有很多讲究。<br><br>任意时间到来的请求是随机不可控的，但是系统的处理能力有限，需要根据系统的能力进行流控。<br><br>Sentinel作为一个适配器，可以根据需要把随机请求调整成合适的形状。<br></p>
</blockquote>
<p><strong>2.流控设计理念</strong><br></p>
<blockquote>
<p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系。<br><br>运行指标，如QPS,线程池,系统负载等。<br><br>控制效果，如直接限流，冷启动，排队等。<br><br><strong>Sentinel的设计理念是，自由选择控制的角度，进行灵活组合，达到想要的效果。</strong></p>
</blockquote>
<h3 id="5-2-熔断降级"><a href="#5-2-熔断降级" class="headerlink" title="5.2 熔断降级"></a>5.2 熔断降级</h3><p><strong>1.什么是熔断降级</strong></p>
<blockquote>
<p>核心还是保护系统稳定性，降低调用链路中的不稳定资源。由于调用关系的复杂性，如果链路中的部分资源不稳定，最终会导致请求发生堆积。<br><br>Sentinel和Hystrix原则一致：当调用链路中某个资源出现不稳定，例如表现timeout，异常比例升高的时候，则对这个资源调用进行限制，<strong>让某个请求快速失败</strong>，避免影响到其他资源，最终产生雪崩的效果。<br></p>
</blockquote>
<p><strong>2.熔断降级的设计理念</strong></p>
<blockquote>
<ul>
<li>限制手段上，Sentinel和HyStrix采取不同的方法；HyStrix通过线程池的方式，来依赖(在我们的概念中对应资源)进行了隔离。这样的好处是对资源和资源之间进行彻底的隔离。缺点是增加了线程切换的成本，还需要预留资源给各个线程池大小的分配。<br></li>
<li>Sentinel对于这个问题采用了两种手段：<br><ol>
<li>通过并发线程数进行限制:通过限制资源并发线程数量，来减少不稳定资源对其他资源的影响，这样没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，如响应时间变长，对资源的直接影响是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定数量之后，该资源的新请求就会被拒绝，堆积的线程完成后才开始接收请求。</li>
<li>通过响应时间对资源进行降级：除了对并发线程数进行控制意外，Sentinel还可以通过响应时间来快速降级不稳定资源，当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定时间窗口后才重新恢复。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="5-3-系统的过载保护"><a href="#5-3-系统的过载保护" class="headerlink" title="5.3 系统的过载保护"></a>5.3 系统的过载保护</h2><pre><code>系统入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理更多的请求。
</code></pre><h2 id="6-Sentinel是如何工作的"><a href="#6-Sentinel是如何工作的" class="headerlink" title="6.Sentinel是如何工作的"></a>6.Sentinel是如何工作的</h2><pre><code>1. 对主流框架提供适配或者显示的API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。
2. 根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel提供开放的接口，方便定义和改变规则。
3. Sentinel提供实时的监控系统，方便快速了解当前系统的状态。 
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/28/Sentinel系列之起源/" data-id="cjptalged0012y4zj4i7qyk2y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sentinel/">Sentinel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Sentinel系列之源码解读" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/28/Sentinel系列之源码解读/" class="article-date">
  <time datetime="2018-08-28T01:24:02.000Z" itemprop="datePublished">2018-08-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/28/Sentinel系列之源码解读/">Sentinel系列之源码</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-源码模块"><a href="#1-源码模块" class="headerlink" title="1. 源码模块"></a>1. 源码模块</h2><ol>
<li>sentinel-adapter 接入<ol>
<li>sentinel-dubbo-adapter</li>
<li>sentinel-grpc-adapter</li>
<li>sentinel-web-servlet</li>
</ol>
</li>
<li>sentinel-benchmark</li>
<li>sentinel-core</li>
<li>sentinel-dashboard</li>
<li>sentinel-demo</li>
<li>sentinel-extension</li>
<li>sentinel-transport</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/28/Sentinel系列之源码解读/" data-id="cjptalgdn0009y4zjo2of55y5" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Sentinel/">Sentinel</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Druid源码解析之数据库连接池总论" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/20/Druid源码解析之数据库连接池总论/" class="article-date">
  <time datetime="2018-08-20T10:17:52.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/Druid源码解析之数据库连接池总论/">Druid源码解析之数据库连接池总论</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-应用程序直接获取数据连接的缺点"><a href="#1-应用程序直接获取数据连接的缺点" class="headerlink" title="1.应用程序直接获取数据连接的缺点"></a>1.应用程序直接获取数据连接的缺点</h2><ol>
<li>用户每次请求都需要向数据库获得连接，数据库创建连接通常需要消耗大量资源，创建时间也较长。</li>
<li>大量得创建极大浪费数据库得资源，并且极易造成数据库服务器内存溢出，宕机。、</li>
</ol>
<h2 id="2-使用数据库连接池优化程序性能"><a href="#2-使用数据库连接池优化程序性能" class="headerlink" title="2.使用数据库连接池优化程序性能"></a>2.使用数据库连接池优化程序性能</h2><ol>
<li>数据库连接池的概念<ol>
<li>数据库连接是一种关键得有限得昂贵得资源，咋多用户网页程序中体现尤为突出。</li>
<li>对数据库连接的管理能力显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</li>
<li>数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li>
<li>数据库连接池在初始化时将创建一定数量的数据库连接池放到连接池中，这些数据库连接的数量由最小数据库连接数来设定。无论这些数据库连接是否被使用，连接池都将保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求连接数超过最大连接数量时，这些请求将会被加入到等待队列中。</li>
<li>数据库连接池的最小连接数和最大连接数的设置需要考虑一下几个因素：<ol>
<li>最小连接数:是连接池一直保持的数据库连接，所以如果应用程序对数据库连接使用量不大，将会有大量数据库连接资源被浪费；</li>
<li>最大连接数:是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响到以后的数据库操作。</li>
</ol>
</li>
</ol>
</li>
<li>编写数据库连接池<ol>
<li>实现java.sql.DataSource接口,DataSource接口定义了两个重载的getConnection方法:<ol>
<li>Connection getConnection();</li>
<li>Connection getConnection(String username, String password);</li>
</ol>
</li>
<li>实现DataSource接口，并实现连接池功能的步骤：<ol>
<li>在DataSource构造函数中批量创建与数据库的连接，并把创建的连接加入LinkedList对象中；</li>
<li>实现getConnection方法，让getConnection方法每次调用时，从LinkedList中去一个Connection返回给用户；</li>
<li>当用户使用完Connection,调用Connection.close()方法时，Collection对象应保证自己返回到LinkedList中，而不是把conn还给数据库。<strong>Collection保证将自己返回到LinkedList中</strong>；</li>
</ol>
</li>
<li>部分核心代码<br> `proxyConn = (Connection) Proxy.newProxyInstance(this.getClass().getClassLoader(),conn.getClass().getInterfaces(),new InvocationHandler(){<pre><code>public Object invoke(Object proxy,Method method,Object[] args) {
    if(method.getName().equals(&quot;close&quot;)) {
        pool.addLast(conn);
        return null;
    }
    return method.invoke(conn,args);
}
</code></pre> })` </li>
</ol>
</li>
<li>开源数据库连接池<ol>
<li>很多WEB服务器都提供了DataSource的实现，即连接池的实现。把DataSource的实现，按其英文含义称之为数据源，数据源中包含了数据库连接池的实现。</li>
<li>DBCP C3P0 使用了数据库连接池，就不需要在编写连接数据库代码了，直接从数据源获得数据库的连接。</li>
<li>DBCP数据源:tomcat采用该连接池</li>
<li>C3P0数据源:dbcp没有自动回收空闲连接的功能，c3p0有自动回收空闲连接功能</li>
<li>Tomcat数据源</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/20/Druid源码解析之数据库连接池总论/" data-id="cjptalge1000py4zjd93bp97s" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Druid-数据库连接池/">Druid 数据库连接池</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络总结复习" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/20/计算机网络总结复习/" class="article-date">
  <time datetime="2018-08-20T08:09:39.000Z" itemprop="datePublished">2018-08-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/20/计算机网络总结复习/">计算机网络总结复习</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="计算机网络复习"><a href="#计算机网络复习" class="headerlink" title="计算机网络复习"></a>计算机网络复习</h2><p>1.域名访问流程<br>    1.ip地址查找<br>        1.浏览器查找缓存，是否有ip地址，无则继续<br>        2.操作系统操作缓存，无则继续<br>        3.路由器查找缓存，无则继续<br>        4.本地服务器查找缓存，无则继续<br>        5.根-&gt;顶级-&gt;权威<br>        6.告知其ip地址<br>    2.主机获取ip地址端口建立tcp连接，3次握手<br>    3.浏览器发送请求报文<br>    4.服务器接收报文，并向客户机发出确认请求；<br>    5.客户机收到后，发送确认已接收，完成tcp建立<br>    6.浏览器发出http协议的get请求等；<br>    7.服务器响应，并指定文件发送给浏览器；<br>    8.浏览器显示所有页面<br>2.版本2<br>    1.浏览器输入URL<br>    2.浏览器查看缓存，如果请求资源新鲜，则显示（建立连接？）<br>    3.浏览器缓存<br>        1.如果未还缓存，发起新请求<br>        2.浏览器查看缓存，如果新鲜，返回给客户端<br>        3.浏览器解析URL获取协议，主机，端口号，path<br>        4.组装HTTP请求报文<br>        5.浏览器获取主机ip地址，过程如下：<br>            1.浏览器缓存<br>            2.操作系统缓存<br>            3.hosts文件缓存<br>            4.路由器缓存<br>            5.isp DNS缓存<br>            6.DNS递归查询<br>        6.打开socket与ip地址，建立tcp连接<br>        7.TCP建立后发送http请求报文<br>        8.服务器接受请求并解析，将请求转发到服务器程序<br>        9.检查是否缓存信息，以及缓存信息是否新鲜<br>        10.将请求信息返回给浏览器<br>        11.四次挥手<br>        12.资源缓存<br>    版本3<br>    1.浏览器先尝试从hosts文件获取对应的ip地址。如果没有，则使用DNS协议来获取IP.<br>        1.浏览器查找缓存，是否有ip地址，无则继续<br>        2.操作系统操作缓存，无则继续<br>        3.路由器查找缓存，无则继续<br>        4.本地服务器查找缓存，无则继续<br>        5.根-&gt;顶级-&gt;权威<br>        6.告知其ip地址<br>    2.使用TCP协议，建立tcp连接。<br>        前提：需要用到ip协议 ARP协议<br>        1.发送syn x<br>        2.服务器发送syn ack x+1 y<br>        3.客户端发送syn ack y+1<br>    3.使用Http协议请求网页内容<br>    版本4<br>    1.总论：<br>        i.域名解析成ip地址；<br>        ii.与目的主机进行tcp连接(三次握手);<br>        iii.发送与收取数据(浏览器与目的主机开始http访问过程);<br>        iv.与目的主机断开tcp连接;<br>    2.域名解析成ip地址<br>        i.浏览器向本机DNS模块发出DNS请求，DNS模块生成相关的DNS报文;<br>        ii.DNS模块将生成的DNS报文传递给传输层的UDP协议单元;<br>        iii.UDP协议单元将该书封装成UDP数据报，传递给网络层的IP协议单元;<br>        iv.IP协议单元将该数据封装成IP数据包，其目的ip地址为DNS服务器的ip地址;封装好的ip数据包将传递给数据链路层的协议单元<br>        v.发送时在ARP缓存中查询相关数据，如果没有就发送ARP广播(包含带查询的IP地址，收到广播的主机检验主机的IP,符合条件的主机将含有自己MAC地址的ARP包发送给ARP广播的主机)请求，等待ARP回应;<br>        vi.得到ARP回应后，将IP地址与路由的下一跳MAC地址对应信息写入ARP缓存表;写入缓存后，以路由下一跳的地址填充目的的MAC地址，以数据帧形式转发;转发可能进行多次;<br>        vii.DNS请求到达DNS服务器的数据链路层协议单元;DNS服务器的数据链路层协议单元解析数据帧，将内部的ip数据包传递给网络层IP协议单元；DNS服务器的IP协议单元解析IP数据包，将内部的UDP数据报传递给传输层UDP协议单元;DNS服务器的UDP协议单元解析收到的UDP数据报，将内部的DNS报文传递给DNS服务单元;<br>        viii.DNS服务单元将域名解析成对应IP地址，产生DNS响应报文;DNS回应报文-&gt;UDP-IP-MAC-&gt;我的主机;本地主机收到数据帧，将数据帧-&gt;IP-&gt;UDP-&gt;浏览器;将域名解析结果以域名和IP地址对用形式写入DNS缓存表；<br>    3.与目的主机进行tcp连接<br>        1.SYN seq = x;<br>        2.SYN ACK Ack=x+1;seq = y;<br>        3.ACK Ack = y+1;<br>    4.发送与收取数据(浏览器与目的主机开始HTTP访问过程)<br>        1.浏览器向域名发出GET方法报文;—&gt;HTTP请求<br>        2.报文通过TCP-&gt;IP(DNS)-&gt;MAC(ARP)-&gt;网关-&gt;目的主机；<br>        3.目的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据；—&gt;HTTP响应：从请求信息中获取客户机想要访问的主机名，从请求信息中获客户机想要访问的web应用。从请求信息中获取客户机要访问的web资源。（即各种文件，图片，视频，文本等）读取响应的主机下web应用，web资源，用读取的web资源数据，创建一个HTTP响应。<br>        4.该HTML通过TCP-&gt;IP-&gt;MAC-&gt;网关-&gt;我的主机<br>        5.我的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP-&gt;浏览器，浏览器以网页形式显示HTML内容。<br>    5.与目的主机断开TCP连接(四次挥手)<br>        1.浏览器向目的主机发出TCP连接结束的请求报文，此时进入FIN WAIT状态；该报文FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP(DNS)-&gt;MAC(ARP)-&gt;网关-&gt;目的主机;目的主机收到数据帧，通过IP-&gt;TCP,TCP协议单元回应结束应答报文；<br>        2.目的主机收到数据帧，通过IP-&gt;TCP,TCP协议单元回应结束应答报文；<br>        3.当前收到回应，因为目的主机还有数据要传，不急于断开连接；<br>        4.该报文中ACK标志设为1，表示收到结束请求；<br>        5.目的数据发送完所有数据后，向客户端发出TCP连接结束请求报文；该报文把FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP-&gt;MAC-&gt;网关-&gt;我的主机；<br>        6.客户端收到数据帧，通过IP-&gt;TCP，TCP协议单元回应结束应答报文，此时进入TimeWait状态；<br>        7.该报文中FIN均设为1，表示结束应答；<br>        8.目的主机关闭连接；Time Wait等待结束后。</p>
<p>3.TCP/UDP区别<br>    1.TCP 面向连接可靠运输协议 UDP面向非连接不可靠<br>    2.TCP报文段首部20字节，UDP报文段8字节<br>    3.TCP有拥塞控制和流量控制，而UDP没有<br>    4.TCP连接过程有3次握手，4次挥手，时延较大，UDP时延较小<br>    5.TCP是一对一连接 UDP可以一对一一对多<br>4.GET/POST的区别<br>    1.get请求会被缓存，保留在浏览器历史记录中，可作为收藏书签，不应再处理敏感数据时使用，有请求长度限制；<br>    2.post请求不会被缓存，不会保留书签和浏览器历史记录；<br>    3.对长度没要求；<br>5.DNS使用的协议<br>    1.既使用TCP也使用UDP,UDP报文长度最大512字节，当DNS查询超过512字节时，协议的TC标志出现删除标志，这时候使用TCP发送。<br>    2.区域传送时使用TCP:<br>        1.辅域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动。如有变动，执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP；<br>        2.TCP是一种可靠连接，保证了数据的准确性。<br>    3.域名解析使用UDP<br>6.幂等<br>7.Cookie和Session区别<br>    1.Cookie是一种能够让网站服务器把少量数据存储在客户端硬盘或内存，或是从客户端的硬盘读取数据的一种技术。当你浏览某网站时，由web服务器置于硬盘上的一个非常小的文本文件，他可以记录你的用户ID,密码，浏览过的网页，停留信息；<br>    2.Session:当用户请求来自应用程序的web页时，如果该用户还没有会话，则web服务器自动创建一个Session对象。当会话过期或者被抛弃后，服务器终止该会话。<br>    3.Session采用在服务器端保持状态的方案，cookie是在客户端保持状态的方案。由于服务器端保持状态的方案在客户端需要保持一个表示，所以session机制需要借助cookie机制来达到保存标识的目的。<br>    4.Session是服务器用来跟踪用户的一种手段，每个session都有一个唯一标识：SessionID;当服务器创建了Session时，给客户端发送的响应报文包含了SetCookie字段，其中有一个名为sid的键值对，这个键值SessionID,客户端收到后就把cookie保存到浏览器，并发之后发送的请求报表都包含SessionID。Http就通过Session和Cookie这两个发送一起合作来实现用户状态跟踪，Session用于服务端，Cookie用于客户端。<br>8.TCP粘包和拆包产生的原因<br>    1.应用程序写入数据的字节大小大于套接字发送缓冲区大小;<br>    2.进行MSS大小的TCP分段。MSS是最大报文段缩写。<br>    3.payLoad大于MTU进行ip分片。MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。如果IP层有一个数据包要传，而且数据的长度比链路层的MTU大，那么IP层就回进行分片，把数据报分成若干片，让每一个片都不超过MTU。IP分片可以发生在原始发送端主机上，也可以发生在中间路由器上。<br>9.TCP粘包拆包的解决策略<br>    1.消息定长<br>    2.在包尾部增加回车空格等特殊字符进行分割，如FTP；<br>    3.将消息分为消息头和消息尾；<br>    4.其他复杂的协议；<br>10.三次握手<br>    1.建立连接时，客户端发送syn包到服务器，并进入syn_Send状态，等待服务器确认；<br>    2.服务器收到Syn包，必须确认客户的syn，同时也发送自己的syn包，此时服务器进入syn_recv状态；<br>    3.客户端端收到SYN+ACK包，向服务器发送确认包ACK,客户端和服务器进入ESTABLISHED状态，完成3次握手。<br>    4.QA:<br>        i.为了保证服务端能够收到客户端信息并且能够做出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能够做出正确的应答而进行后二次握手；<br>        ii.三次握手的本质是信道不可靠，但是通信双方需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含了什么信息，三次通信是理论上的最小值，所以三次握手不是tcp本身的要求，而是为了满足:在不可靠信道上可靠地传输信息，本质需求是，信道不可靠，数据传输要可靠，三次是最小带价值；<br>        iii.为什么进行三次握手：为了防止已失效的链接请求报文又突然传送到服务端，因而产生错误。为了解决网络中存在延迟的重复分组问题。<br>        iv.例：client发出的第一个链接请求报文段并没有丢失，而是在某个网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达Server。本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文后，就误以为是client再次发出一个新的连接请求。于是就向client发出确认报文段，同一建立连接。假设不采用三次握手，那么server确认就建立连接了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发出数据，但server却认为新的运输连接已经建立，并一直等待Client发来数据。这样就浪费了server的资源。防止造成服务端资源浪费。<br>11.Socket<br>    1.网络通信必须的五种信息:连接使用的协议，本地主机的ip地址，本地进程的协议端口，远地主机的IP地址+端口;<br>    2.建立socket:一对套接字，一个运行于客户端，一个运行于服务端。连接分为3个过程：服务器监听，客户端请求，连接确认。<br>12.四次挥手<br>    1.客户端线发送FIN,进入FIN_WAIT状态<br>    2.服务端收到FIN,发送ACK,进入CLOSE_WAIT状态，客户端收到这个ACK,进入FIN_WAIT状态<br>    3.服务端发送FIN，进入LAST_ACK状态<br>    4.客户端收到FIN,发送ACK，进入TIME_WAIT状态，服务端收到ACK,进入CLOSE状态<br>    5.QA:<br>        i.TCP协议是一种面向连接可靠的基于字节流的运输层通信协议。TCP是双全工模式，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了。主机1告诉主机2，它的数据已经全部发送完毕了；但是这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2可以发送数据到主机1；当主机2发送FIN报文段时候，这个时候表示主机2也没有数据要发送了，就会告诉主机1，之后就断开。<br>        ii.服务端在Listen状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里面发送给客户端。而关闭连接时，当收到对方的FIN。<br>13.TCP如何保证可靠传输<br>    1.三次握手<br>    2.将数据截断为合理的长度。应用数据被分割成TCP认为最适合发送的数据块；按字节编号，合理分片；<br>    3.超时重发。当TCP发出一个段后，它启动一个定时器，如果不能及时收到一个确认就重发；<br>    4.对于收到的请求给出确认响应；<br>    5.校验出包有错，丢弃报文段，不给出响应；<br>    6.对于失序数据进行重新排序，然后才交给应用层；<br>    7.对于重复数据，能够丢弃重复数据；<br>    8.流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。<br>    9.拥塞控制，当网络拥塞时，减少数据的发送。<br>14.详细介绍HTTP<br>    1.1.0和2.0的区别<br>        1.多路复用，允许单一的http/2连接同时发起多重请求-响应消息。<br>        2.二进制分帧，位于应用层和传输层之间。<br>        3.首部压缩<br>        4.HTTP2.0支持服务器推送<br>15.HTTPS和HTTP<br>    1.https协议需要到CA申请证书；<br>    2.http时超文本传输协议，信息是铭文传输;https是具有安全性的ssl加密传输协议；<br>    3.http和https使用的是完全不同的连接方式，用的端口不一样，前者是80，后者是443;<br>    4.http的连接很简单，是无状态的；https协议由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议；</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/20/计算机网络总结复习/" data-id="cjptalgqk002my4zji7qnqhhl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络/">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-手写Java集合类之SkipList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/17/手写Java集合类之SkipList/" class="article-date">
  <time datetime="2018-08-17T01:24:31.000Z" itemprop="datePublished">2018-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/17/手写Java集合类之SkipList/">手写Java集合类之SkipList</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-SkipList原理"><a href="#1-SkipList原理" class="headerlink" title="1.SkipList原理"></a>1.SkipList原理</h2><ol>
<li>跳跃表使用概率均衡而不是使用强制性均衡，对于插入和删除结点比传统上的平衡树更为简洁。</li>
<li>传统向有序链表中插入一个结点所需时间是O(n),查找也是O(n),使用跳跃表可以减少查找所需时间为O(n/2)。</li>
<li>每个结点不单单只包含指向下一个结点的指针，可能包含很多个指向后续结点的指针，这样就可以跳过一些不必要的结点，从而加快查找，删除等操作。<strong>对于链表内每一个结点包含多少个指向后续元素的指针，这个过程是通过一个随机函数生成器得到。</strong></li>
<li>跳表的操作<ol>
<li>重要的数据结构定义</li>
<li>初始化表</li>
<li>查找</li>
<li>插入</li>
<li>删除</li>
<li>随机数生成器</li>
<li>释放表</li>
<li>性能比较</li>
</ol>
</li>
<li></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/17/手写Java集合类之SkipList/" data-id="cjptalgem001ey4zjiikn3nn4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/跳表-SkipList/">跳表 SkipList</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-计算机网络 第五章 网络层" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/08/16/计算机网络 第五章 网络层/" class="article-date">
  <time datetime="2018-08-16T09:50:28.000Z" itemprop="datePublished">2018-08-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/08/16/计算机网络 第五章 网络层/">计算机网络 第五章 网络层</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层—&gt;将数据从端到端，是端到端的最底层；<br>    1.网络层必须知道网络拓扑结构，所有路由器与链路的集合，并且找出一条好路;<strong>路径规划</strong><br>    2.网络层要仔细选择路由器，避免某些通信线路和路由器负载过重;<strong>负载均衡</strong></p>
<h2 id="2-网络层设计问题"><a href="#2-网络层设计问题" class="headerlink" title="2.网络层设计问题"></a>2.网络层设计问题</h2><p>1.存储转发数据包交换<br>    1.ISP网络服务提供商的设备和客户端设备<br>    2.一台主机要发送一个数据包：存储-转发数据包交换<br>        1.需要将数据包传递给最近的路由器，路由器可能在它自己的LAN上，也可能在一条通向ISP的点到点链路上；<br>        2.在该数据包到达路由器，并且路由器链路层完成了对它校验和的验证之后，它先被存储在路由器上；<br>        3.沿着路径被转发到下一个路由器，直到到达目标主机；<br>2.提供给传输层的服务<br>    1.设计目标<br>        1.向上提供的服务应该独立于路由器技术；<br>        2.应该向传输层屏蔽路由器数量，类型和拓扑关系；<br>        3.传输层可用的网络地址应该有一个统一编码方案，甚至可以跨越LAN和WAN;<br>    2.面向连接和面向非连接 </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/16/计算机网络 第五章 网络层/" data-id="cjptalgeu001oy4zjzhayyahh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/计算机网络-网络层/">计算机网络 网络层</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    <!-- Featured Tags -->

  
    <!-- Short About -->
<section class="visible-md visible-lg">
    <h5><a href="/about/">ABOUT ME</a></h5>
    <div class="short-about">

        

        

        <!-- SNS Link -->
        <ul class="list-inline">
            
            
            

            

            

            
            
            
            
        </ul>
    </div>
</section>

  
    
  <h5>RECENT POSTS</h3>
  <div class="widget">
    <ul>
      
        <li>
          <a href="/2018/11/20/大复习之深度解析RPC与Restful/">大复习之深度解析RPC与Restful</a>
        </li>
      
        <li>
          <a href="/2018/11/05/大讲座讲座笔记/">大讲座笔记系列</a>
        </li>
      
        <li>
          <a href="/2018/10/11/Netty系列之Netty实战读书笔记/">Netty系列之Netty实战读书笔记</a>
        </li>
      
        <li>
          <a href="/2018/10/10/docker系列之doker核心原理解读/">docker系列之doker核心原理解读</a>
        </li>
      
        <li>
          <a href="/2018/10/08/docker系列深入篇/">docker系列深入篇</a>
        </li>
      
    </ul>
  </div>

  
    <!-- Friends Blog -->

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/09/">September 2018</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a><span class="archive-list-count">26</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Rocky ZhouJin QQ987415811<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>



<script src="/js/script.js"></script>

  </div>
</body>
</html>