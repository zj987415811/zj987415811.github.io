
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Rocky for Everything</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Rocky ZhouJin QQ987415811">
    

    
    <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">

    
    <link rel="alternative" href="/atom.xml" title="Rocky for Everything" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Rocky for Everything" title="Rocky for Everything"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Rocky for Everything">Rocky for Everything</a></h1>
				<h2 class="blog-motto">慢慢喜欢你</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/11/Netty系列之Netty实战读书笔记/" title="Netty系列之Netty实战读书笔记" itemprop="url">Netty系列之Netty实战读书笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-10-11T12:21:43.000Z" itemprop="datePublished"> Published 2018-10-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="第一章-Netty—异步和事件驱动"><a href="#第一章-Netty—异步和事件驱动" class="headerlink" title="第一章 Netty—异步和事件驱动"></a>第一章 Netty—异步和事件驱动</h2><ol>
<li>netty是一款异步的事件驱动的网络应用程序框架，支持快速地开发可维护的高性能面向协议的服务器和客户端。</li>
<li><p>核心组件</p>
<ul>
<li>Channel</li>
<li>回调</li>
<li>Future</li>
<li>事件和ChannelHandler  <h2 id="第三章-Netty的组件和设计"><a href="#第三章-Netty的组件和设计" class="headerlink" title="第三章 Netty的组件和设计"></a>第三章 Netty的组件和设计</h2><h3 id="3-1-Channel-EventLoop-ChannelFuture"><a href="#3-1-Channel-EventLoop-ChannelFuture" class="headerlink" title="3.1. Channel,EventLoop,ChannelFuture"></a>3.1. Channel,EventLoop,ChannelFuture</h3></li>
</ul>
<ol>
<li><p>Channel</p>
<ol>
<li>基本的I/O操作（bind(),connect(),read(),write()）依赖于底层网络传输所提供的原语。在java网络编程中，基本构造是class socket。Netty的Channel接口提供的API大大降低了直接使用socket类的复杂性。</li>
</ol>
</li>
<li><p>EventLoop接口:定义了核心抽象，用于处理连接生命周期中所发生的事件。</p>
<ol>
<li>一个EventLoopGroup包含一个或多个EventLoop</li>
<li>一个EventLoop在它的生命周期内之和一个Thread绑定</li>
<li>所有由EventLoop处理的IO事件都将在它专有的Thread上被处理</li>
<li>一个Channel在他的生命周期内只注册于一个EventLoop;</li>
<li>一个EventLoop可能会被分配给一个或多个Channel。</li>
</ol>
</li>
<li>ChannelFuture<ol>
<li>所有的I/O操作都是异步的，一个操作可能不会立即返回，需要一种用于在之后某个时间点确定其结果的方法。</li>
<li>Netty提供了ChannelFuture接口，其addListener()方法注册一个ChannelFutureListener,以便在某个操作完成时得到通知。<h3 id="3-2-ChannalHandler和ChannelPipeline"><a href="#3-2-ChannalHandler和ChannelPipeline" class="headerlink" title="3.2. ChannalHandler和ChannelPipeline"></a>3.2. ChannalHandler和ChannelPipeline</h3></li>
</ol>
</li>
</ol>
</li>
<li>ChannelHandler接口<ol>
<li>充当了所有处理入站和出战数据的应用程序逻辑容器。</li>
<li>ChannelHandler由网络事件触发，用于几乎所有的的事件动作。</li>
<li>Netty以适配器的形式提供了大量默认的ChannelHandler实现，用于简化程序处理逻辑的开发过程。ChannelPipeline中的每个ChannelHandler将负责将事件转发到链中的下一个ChannelHandler。这些适配器就会执行这个操作。</li>
<li>适配器类：一些适配器类可以将编写自定义ChannelHandler所需要的努力降低，提供了定义在对应接口中所有方法的默认实现。如：ChannelHandlerAdapter,ChannelInboundHandlerAdapter,ChannelOutboundHandlerAdapter,ChannelDuplexHandler.</li>
<li></li>
</ol>
</li>
<li>ChannelPipeline接口<ol>
<li>为ChannelHandler链提供容器，并定义了用于在该链上传播入站和出战事件流的API。</li>
<li>当Channel被创建时，它会被自动地分配到它专属的ChannelPipline。</li>
<li>ChannelHandler安装到ChannelPipeline中的过程：<ol>
<li>一个ChannelInitializer的实现被注册到ServerBootstrap中；</li>
<li>当ChannelInitializer.initChannel()方法被调用时，ChannelInitializer将在ChannelPipeline中安装一组自定义的ChannelHandler;</li>
<li>ChannelInitializer将它自己从ChannelPipeline中移除。</li>
</ol>
</li>
<li>ChannelHandler是专为支持广泛的用途而设计的。可以是来往ChannelPipline事件的任何代码的通用容器。</li>
<li>使得<strong>事件流经ChannelPipline</strong>是ChannelHandler的工作。在应用程序的初始化或引导阶段被安装。这些对象接收事件，执行他们所实现的处理逻辑，并将数据传递给链中的下一个ChannelHandler。他们的执行顺序由被添加的顺序所决定的。也就是说ChannelPipeline是ChannelHandler的编排器顺序。</li>
<li>Netty中有2种发送消息的方式，可以直接写到Channel中，也可以写到和ChannelHandler相关联的ChannelHandlerContext对象中。前一种方式导致消息从ChannelPipeline的尾端开始流动，而后者导致消息从ChannelPipeline中的下一个ChannelHandler开始流动。</li>
</ol>
</li>
<li>编码器，解码器和ChannelHandler子类SimpleChannelInboundHandler-ChannelInboundHandlerAdapter。</li>
<li>编码器和解码器</li>
<li>抽象类SimpleChannelInboundHandler<ol>
<li>用ChannelHandler来接收解码消息，并对该数据应用业务逻辑。</li>
<li>只需扩展基类SimpleChannelInboundHandler<t>,T是要处理的消息的Java类型。在这个ChannelHandler中要重写基类的一个或者多个方法，并且获取一个到ChannelHandlerContext的引用，将这个引用作为输入参数传递给ChannelHandler的所有方法。</t></li>
<li>在这种类型的ChannelHandler中，最重要的方法是channelRead0(ChannelHandlerContext context,T);<h3 id="3-3-引导"><a href="#3-3-引导" class="headerlink" title="3.3 引导"></a>3.3 引导</h3></li>
</ol>
</li>
<li>Netty的引导类为应用程序的网络配置提供了容器，如将一个进程绑定到某个指定的端口，或者将一个进程连接到另一个运行在某个指定主机的指定端口进程。</li>
<li>客户端和服务器</li>
</ol>
<h2 id="第四章-传输"><a href="#第四章-传输" class="headerlink" title="第四章 传输"></a>第四章 传输</h2><h3 id="4-1-传输API"><a href="#4-1-传输API" class="headerlink" title="4.1 传输API"></a>4.1 传输API</h3><ol>
<li>核心是interface Channel,用于所有的IO操作。</li>
<li>每个Channel都会分配一个ChannelPipeline和ChannelConfig。ChannelConfig包含该Channel所有的配置设置，并且支持热更新。同时也有可能是实现ChannelConfig的子类型。</li>
<li>Channel是独一无二，并且保证顺序，需要将其生命为Comparable的子接口。同时返回不同的散列码。如果相同就会抛错。</li>
<li>ChannelPipline持有所有将应用于入站和出战数据以及事件的ChannelHandler实例。这些ChannelHandler实现了应用程序用于处理状态变化以及数据处理的逻辑。</li>
<li>ChannelHandler典型用途：<ol>
<li>将数据从一种格式转化为另一种格式；</li>
<li>提供异常通知；</li>
<li>提供Channel变为活动或者非活动；</li>
<li>提供Channel注册到EventLoop或者从EventLoop注销时的通知。</li>
<li>提供用于相关的自定义事件通知。</li>
</ol>
</li>
<li>通过根据需要添加或者移除Channel实例来修改ChannelPipeline。<h3 id="4-2-内置的传输"><a href="#4-2-内置的传输" class="headerlink" title="4.2 内置的传输"></a>4.2 内置的传输</h3></li>
<li>Netty内置了一些可开箱即用的传输。NIO，Epoll,OiO,Local,Embedded</li>
<li>NIO<ol>
<li>提供了一个所有I/O操作全异步的实现。利用了自身NIO子系统被引入JDK时候可用的基本选择权的API;选择器背后的概念就是一个注册表，将可以请求在Channel的状态发生变化时得到通知。可能的变化有：<ol>
<li>新的Channel连接已经完成；</li>
<li>Channel连接已经完成；</li>
<li>Channel有已经就绪的可供读取的数据；</li>
<li>Channel可用于写数据。</li>
</ol>
</li>
<li>OP_ACCEPT:请求在接受新连接并创建Channel时获得通知；OP_CONNECT:请求在建立一个连接时获得通知；OP_READ:请求当数据已经就绪，可以从Channel中读取时获得通知。OP_WRITE:请求当可以向Channel中写更多数据时获得通知，这处理了套接字缓冲区被完全填满时得情况，这种情况通常发生在数据的发送速度比远程节点可处理的数据更快的时候。</li>
<li>流程<ol>
<li>新的Channel注册到选择器；</li>
<li>选择器处理状态变化的通知；</li>
<li>之前已注册的Channel;</li>
<li>Selector.select()将会阻塞，直到接收到新的状态或者配置超时时间已过；</li>
<li>检测状态是否变化，处理所有状态变化；</li>
<li>在选择器运行同一线程中执行其他任务。    </li>
</ol>
</li>
<li>零拷贝<ol>
<li>在NIO和Epoll传输时使用的特性。可以快速高效地将数据文件从文件系统移动到网络接口，而不需要复制到内核空间，如在FTP或者HTTP中有显著性能提升。</li>
<li>只能传输原始文件。</li>
</ol>
</li>
</ol>
</li>
<li>Epoll<h2 id="第5章-ByteBuf"><a href="#第5章-ByteBuf" class="headerlink" title="第5章 ByteBuf"></a>第5章 ByteBuf</h2><h3 id="5-1-ByteBuf的API"><a href="#5-1-ByteBuf的API" class="headerlink" title="5.1 ByteBuf的API"></a>5.1 ByteBuf的API</h3></li>
<li>ByteBuf<ol>
<li>被用户自定义的缓冲区类型扩展；</li>
<li>通过内置的复合缓冲区类型实现了透明的零拷贝；</li>
<li>容量可以按需增长；</li>
<li>在读写之间切换不需要调用ByteBuffer的flip()方法；</li>
<li>读写使用了不同的索引；</li>
<li>支持方法的链式调用；</li>
<li>支持引用计数；</li>
<li>支持池化。<h3 id="5-2-ByteBuf类—Netty数据容器类"><a href="#5-2-ByteBuf类—Netty数据容器类" class="headerlink" title="5.2 ByteBuf类—Netty数据容器类"></a>5.2 ByteBuf类—Netty数据容器类</h3></li>
</ol>
</li>
<li>工作原理<ol>
<li>ByteBuf维护了两个不同的索引：一个用于读取，一个用于写入。当从ByteBuf读取时，其readerIndex将会被递增已经被读取的字节数。当写入ByteBuf时，writeIndex也会被递增。</li>
<li>read和write开头的ByteBuf方法，将会推进其对应的索引，而名称以set或get开头的操作则不会。后面的这些方法将在作为了一个参数传入的一个相应索引上执行操作。<ol start="3">
<li>可以指定ByteBuf的最大容量，试图移动索引超过这个值将会触发一个异常。</li>
</ol>
</li>
</ol>
</li>
<li>ByteBuf的使用模式<ol>
<li>堆缓冲区<ol>
<li>最常用的是ByteBuf模式是将数据存储在JVM的堆空间中。这种模式称为支数组。能够在没有池化的情况下快速的分配和释放。</li>
<li>bytebuf.array();</li>
</ol>
</li>
<li>直接缓冲区<ol>
<li>在JDK1.4中，引入了ByteBuf允许JVM实现通过本地调用来分配内存。避免了每次调用本地I/O操作之前，将缓冲区的内容复制到中间缓冲区。</li>
<li>直接缓冲区内容将驻留在常规的会被垃圾回收的堆之外。如果在堆上分配的缓冲区，在通过套接字发送它之前，jvm会在内部将缓冲区复制到直接缓冲区中。</li>
<li>缺点：<ol>
<li>分配和释放较为昂贵。</li>
</ol>
</li>
</ol>
</li>
<li>复合缓冲区<ol>
<li>多个ByteBuf提供一个聚合视图。根据需要添加或者删除ByteBuf实例。</li>
<li>ByteBuf通过CompositeByteBuf实现这个模式，提供了一个将多个缓冲区表示为单个合并缓冲区的虚拟表示。<h3 id="5-3-字节级操作"><a href="#5-3-字节级操作" class="headerlink" title="5.3 字节级操作"></a>5.3 字节级操作</h3></li>
</ol>
</li>
</ol>
</li>
<li>随机访问索引<ol>
<li>与普通java字节数组一样，ByteBuf索引从零开始。</li>
</ol>
</li>
<li>顺序访问索引<ol>
<li>ByteBuf同时具有读索引和写索引</li>
</ol>
</li>
<li>可丢弃字节</li>
<li>可读字节</li>
<li>可写字节</li>
<li>索引管理</li>
<li>查找操作</li>
<li>派生缓冲区</li>
<li>读写<h3 id="5-4-ByteBufHolder接口"><a href="#5-4-ByteBufHolder接口" class="headerlink" title="5.4 ByteBufHolder接口"></a>5.4 ByteBufHolder接口</h3></li>
<li>除了数据负载之外，还需要存储各种属性值。</li>
<li>为了处理这些情况，有了ByteBufHolder。<h3 id="5-5-ByteBuf分配"><a href="#5-5-ByteBuf分配" class="headerlink" title="5.5 ByteBuf分配"></a>5.5 ByteBuf分配</h3></li>
<li>按需分配:ByteBufAllocator接口<ol>
<li>池化</li>
<li>PoolByteBufAllocator:池化了ByteBuf的实例以提高性能并最大限度地减少内存碎片。实现使用了jemalloc的高效方法来分配内存。</li>
<li>UnpooledByteBufAllocator：每次返回一个新实例。</li>
</ol>
</li>
<li>Unpooled缓冲区<ol>
<li>提供了静态的辅助方法来创建未池化的ByteBuf实例。</li>
<li>非网络组件。</li>
</ol>
</li>
<li>ByteBufUtil类<ol>
<li>通用API，静态辅助方法。外部实现。</li>
<li>hexdump()以16进制打印ByteBuf内容<h3 id="5-6-引用计数"><a href="#5-6-引用计数" class="headerlink" title="5.6 引用计数"></a>5.6 引用计数</h3></li>
</ol>
</li>
<li>引用计数:一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。</li>
<li>实现了ReferenceCounted。</li>
<li>背后涉及到跟踪到某个特定对象的活动引用数量。</li>
</ol>
<h2 id="第6章-ChannelHandler和ChannelPipeline"><a href="#第6章-ChannelHandler和ChannelPipeline" class="headerlink" title="第6章 ChannelHandler和ChannelPipeline"></a>第6章 ChannelHandler和ChannelPipeline</h2><h3 id="6-1-ChannelHandler"><a href="#6-1-ChannelHandler" class="headerlink" title="6.1 ChannelHandler"></a>6.1 ChannelHandler</h3><ol>
<li>Channel生命周期<ol>
<li>Channel已经被定义，但还未注册到EventLoop,Channel处于活动状态，可以接收和发送数据，没有连接到远程节点。</li>
<li>正常生命周期:ChannelRegistered—&gt;ChannelActive—&gt;ChannelInactive—&gt;ChannelUnregistered。</li>
</ol>
</li>
<li>ChannelHandler生命周期<ol>
<li>在添加或者从ChannelPipeline移除这些操作的方法中都会接受一个ChannelHandlerContext参数。</li>
<li>生命周期方法<ol>
<li>handlerAdded():当把ChannelHandler添加到ChannelPipeline中时被调用。</li>
<li>handlerRemoved():当从ChannelPipeline中移除ChannelHandler时被调用。</li>
<li>exceptionCaught():当处理过程中在ChannelPipeline中有错误产生时被调用。</li>
</ol>
</li>
<li>ChannelHandler的两个重要子接口<ol>
<li>ChannelInboundHandler</li>
<li>CHannelOutboundHandler</li>
</ol>
</li>
</ol>
</li>
<li>ChannelInboundHandler接口<ol>
<li>channelRegistered():已经注册到EventLoop并且能够处理I/O时被调用。</li>
<li>channelUnregistered():从EventLoop注销并且无法处理任何I/O时被调用。</li>
<li>channelActive():处于活动状态被调用，并且已经连接绑定并且就绪。</li>
<li>channelInactive():离开活动状态并且不再连接它的远程节点时被调用。</li>
<li>channelReadComplete():当上一个读操作完成时被调用。</li>
<li>channelRead():读取数据时被调用。</li>
<li>channelWritablityChanged():写状态发生变化时被调用。</li>
<li>userEventTriggered();</li>
<li>当某个ChannelInboundHandler的实现重写了channelRead()方法时，此时就会负责显示的释放和池化的ByteBuf实例相关的内存。Netty提供了ReferenceCountUtil.release();</li>
</ol>
</li>
<li>ChannelOutboundHandler<ol>
<li>出站操作和数据将由ChannelOutboundHandler处理。它的方法将被Channel,ChannelPipeline以及ChannelHandlerContext调用。</li>
<li>ChannelOutboundHandler的可以按需推迟操作或者事件，从而可以通过一些复杂的方法来处理请求。</li>
<li>bind():当请求将channel绑定到本地地址时被调用。</li>
<li>connect():当请求将Channel连接到远程节点时被调用；</li>
<li>disconnect():当请求将Channel从远程节点断开时被调用；</li>
<li>close():关闭请求；</li>
<li>deregister():当请求将Channel从EventLoop注销时被调用；</li>
<li>read():当请求通过Channel读取更多数据时被调用；</li>
<li>flush():当请求通过Channel将入队数据冲刷到远程节点时被调用；</li>
<li>write():当请求通过Channel将数据写入到远程节点时被调用。</li>
<li>ChannelPromise与ChannelFuture</li>
</ol>
</li>
<li>ChannelHandler适配器<ol>
<li>可以使用ChannelInboundHandlerAdapter和ChannelOutboundAdapter作为ChannelHandler起点。这两个适配器分别提供了ChannelInboundHandler和ChannelOutboundHandler的基本实现。通过扩展抽象类ChannelHandlerAdapter。获得共同的超接口ChannelHandler的方法。</li>
<li>提供的方法体调用了相关联的ChannelHandlerContext,从而将事件转发到ChannelPipeline中的下一个ChannelHandler中。</li>
</ol>
</li>
<li>资源管理<ol>
<li>当调用ChannelInboundHandler.channelRead()或者ChannelOutboundHandler.write()处理数据时，需要保证资源不会泄露。netty中通过引用计数来处理池化的ByteBuf。</li>
<li>Netty提供ResourceLeakDetector来检测内存泄漏。</li>
<li>内存泄露级别：<ol>
<li>disabled 禁用泄露检测</li>
<li>simple 使用1%的默认采样率检测并报告任何发现的泄露，这是默认级别。</li>
<li>advance 使用默认采样率，报告所发现的任何泄露以及对应的消息被访问的位置。</li>
<li>paranoid 每次访问都会堆消息进行采样。<h3 id="6-2-ChannelPipeline接口"><a href="#6-2-ChannelPipeline接口" class="headerlink" title="6.2 ChannelPipeline接口"></a>6.2 ChannelPipeline接口</h3></li>
</ol>
</li>
</ol>
</li>
<li>ChannelPipeline是一个拦截流经Channel的入站和出站事件的ChannelHandler实例链。</li>
<li>每一个新创建的Channel都会被分配到一个新的ChannelPipeline，Channel不能附加到另一个ChannelPipeline，也不能分离其当前的。</li>
<li>根据事件的起源，事件将会被ChannelInboundHandler或者ChannelOutboundHandler处理，随后调用ChannelHandlerContext实现，他将转发给同一个超类型的下一个ChannelHandler。</li>
<li>ChannelHandlerContext<ol>
<li>ChannelHandlerContext使得ChannelHandler能够和它的ChannelHandler以及其他的ChannelHandler交互。ChannelHandler可以通知其所属的ChannelPipeline中的下一个ChannelHandler,甚至动态修改所属的ChannelPipeline。</li>
<li>ChannelHandlerContext具有丰富的用于处理事件和执行I/O操作的API。</li>
</ol>
</li>
<li>修改ChannelPipeline<ol>
<li>ChannelPipeline的API公开了用于调用入站和出站操作的附加方法。用于通知ChannelInboundHandler在ChannelPipeline中所发生的事件。</li>
<li>ChannelPipeline保存了与Channel相关联的ChannelHandler；</li>
<li>ChannelPipeline可以根据需要，通过添加或删除ChannelHandler来动态修改；</li>
<li>ChannelPipeline有丰富的API调用，以响应入站和出出站事件。<h3 id="6-3-ChannelHandlerContext接口"><a href="#6-3-ChannelHandlerContext接口" class="headerlink" title="6.3 ChannelHandlerContext接口"></a>6.3 ChannelHandlerContext接口</h3></li>
</ol>
</li>
<li>代表了ChannelHandler和ChannelPipeline之间的关联，有ChannelHandler添加到ChannelPipeline中时，都会创建ChannelHandlerContext。</li>
<li>主要功能是管理他所关联的ChannelHandler和在同一个ChannelPipeline中的其他ChannelHandler之间的交互。</li>
</ol>
<h2 id="第7章-EventLoop和线程模型"><a href="#第7章-EventLoop和线程模型" class="headerlink" title="第7章 EventLoop和线程模型"></a>第7章 EventLoop和线程模型</h2><ol>
<li>线程模型<ol>
<li>指定了操作系统，编程语言，框架或应用程序上下文中的线程管理关键方面。何时以及如何创建线程将对应用程序代码执行产生显著的影响。</li>
<li>基本的线程池化模式：<ol>
<li>从池的空闲线程列表中选择一个Thread,并且指派它去运行一个已提交的任务。</li>
<li>当任务完成时，该Thread返回给该列表，使其可以被重用。</li>
</ol>
</li>
</ol>
</li>
<li>EventLoop接口<ol>
<li>运行任务来处理在连接生命周期内发生的事件是任何网络框架的基本功能。—事件循环。</li>
</ol>
</li>
<li>任务调度</li>
<li>实现细节<ol>
<li>Netty性能的卓越性取决于当前执行的Thread的身份确定。确定是否是分配给当前Channel以及它的EventLoop的那个线程。负责处理Channel的整个生命周期内的所有事件。</li>
<li>如果调用线程正式支撑EventLoop的线程，那么所提交的代码块将会被执行。否则EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中。当EventLoop下次处理它的事件时，它会执行任务队列中那些任务/事件。</li>
<li>EventLoop调度：<ol>
<li>将要在EventLoop执行的任务；</li>
<li>在把任务传递给execute方法之后，执行检查以确定当前线程是否就是分配给EventLoop的那个线程。</li>
<li>如果就是相同的线程，则你在EventLoop中，可以直接执行任务。</li>
<li>如果线程不是EventLoop那个线程，则将任务放入队列以便EventLoop下一次处理它的事件时执行。</li>
</ol>
</li>
</ol>
</li>
<li>EventLoop/线程的分配<ol>
<li>服务于Channel的I/O和事件的EventLoop包含在EventLoopGroup中，根据不同的传输实现，EventLoop的创建和分配方式不同。</li>
<li>异步传输</li>
<li>阻塞传输<h2 id="第8章-引导"><a href="#第8章-引导" class="headerlink" title="第8章 引导"></a>第8章 引导</h2></li>
</ol>
</li>
<li>引导一个程序是指：对她进行配置，并使其运行起来的过程。<h3 id="8-1-Bootstrap类"><a href="#8-1-Bootstrap类" class="headerlink" title="8.1 Bootstrap类"></a>8.1 Bootstrap类</h3></li>
<li>包括一个抽象的父类和两个具体的引导子类。服务器致力于使用一个父Channel来接受来自客户端的连接，并创建子Channel以用于他们之间通信。</li>
<li>客户端将最可能只需要一个单独的，没有父channel的channel来用于所有网络交互。</li>
<li>引导类:Cloneable<ol>
<li>有时候创建需要多个具有类似配置或则完全相同配置的Channel。为了支持这种模式而又不需要为每个Channel都创建并配置一个新的引导类实例，AbstractBootstrap被标记为Cloneable。在一个已经配置完成的引导类实例上调用clone()方法将返回另一个可以立即使用的引导类实例。</li>
<li>这是浅拷贝。后者将在所有克隆Channel实例之间共享。</li>
</ol>
</li>
<li>引导客户端和无连接协议</li>
</ol>
<h3 id="8-2-引导客户端和无连接协议"><a href="#8-2-引导客户端和无连接协议" class="headerlink" title="8.2 引导客户端和无连接协议"></a>8.2 引导客户端和无连接协议</h3><ol>
<li>group():用于处理Channel所有事件得EventLoopGroup;</li>
<li>channel():</li>
<li>Bootstrap类会在bind()方法被调用后创建一个新的Channel,在这之后调用connect()方法建立连接。</li>
</ol>
<h3 id="8-3-引导服务器"><a href="#8-3-引导服务器" class="headerlink" title="8.3 引导服务器"></a>8.3 引导服务器</h3><ol>
<li>ServerBootstrap类<ol>
<li>group():设置ServerBootstrap要用得EventLoopGroup,用于ServerChannel和被接受的子Channel的I/O处理。</li>
<li>channel():</li>
<li>channelFactory()</li>
<li>bind():绑定ServerChannel并返回一个ChannelFuture,其将会在绑定操作完成后收到通知。</li>
</ol>
</li>
<li>引导服务器</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/netty/">netty</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/10/docker系列之doker核心原理解读/" title="docker系列之doker核心原理解读" itemprop="url">docker系列之doker核心原理解读</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-10-10T13:47:14.000Z" itemprop="datePublished"> Published 2018-10-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-docker背后的内核知识"><a href="#1-docker背后的内核知识" class="headerlink" title="1. docker背后的内核知识"></a>1. docker背后的内核知识</h2><ol>
<li>docker容器本质上是宿主机上的<strong>进程</strong>。<ol>
<li>通过namespaces实现了资源隔离。</li>
<li>通过cgroups实现了资源限制。</li>
<li>通过写时复制实现高效文件操作。</li>
</ol>
</li>
<li>通过namespace资源隔离<ol>
<li>chroot—文件系统被隔离</li>
<li>在分布式环境下进行通信和定位，容器使用独立的IP，端口，路由等。—网络的隔离</li>
<li>容器需要一个独立的主机名，以便在网络中识别自己。—进程间通信也需要隔离—开发者权限—用户权限</li>
<li>容器中的应用需要有进程号，需要与宿主机的PID进行隔离。</li>
<li>6项隔离：<ul>
<li>主机名与域名</li>
<li>信号量，消息队列，内存共享</li>
<li>进程编号</li>
<li>网络设备，网络栈，端口</li>
<li>挂载点</li>
<li>用户用户组</li>
</ul>
</li>
<li>同一个namespace下的进程可以相互感知彼此的变化</li>
</ol>
</li>
<li><p>namespaceAPI的4种方式</p>
<ol>
<li>通过clone()在创建新进程的同时创建namespace，是Linux系统调用fork()的一种实现方式，通过flags来控制。</li>
<li>查看/proc/[pid]/ns文件：如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，/proc/[pid]/ns里面设置这些link，一旦link文件被打开，只要打开文件描述符存在，那么/uts。</li>
<li>setnx()加入一个已经存在的namespace</li>
<li>通过unshare()在原先进程上进行namespace隔离</li>
<li>fork()系统调用<ul>
<li>程序调用fork()函数时，系统会创建新的进程，为其分配资源，将原来进程的所有值都复制到新进程种，只有少数数值与原来进程值不同，相当于复制了本身。<br>4.6种namespace</li>
</ul>
</li>
<li>UTS namespace 主机名和域名隔离</li>
<li>IPC namespace 进程间通信:信号量，消息队列，共享内存。申请IPC资源申请一个全局唯一的32位ID,包含了系统IPC标识符以及实现POSIX消息队列的文件系。同一个IPC namespace下进程彼此可见，不同IPC namespace下进程相互不可见。</li>
<li>PID namespace PID重新编号<ol>
<li>PID namespace种的init进程</li>
<li>信号与init进程</li>
<li>挂载proc文件系统</li>
<li>unshare()和setns()</li>
</ol>
</li>
<li>mount namespace 通过隔离文件系统挂载点对隔离文件系统提供支持。共享挂载</li>
<li>network namespace <ol>
<li>网络设备</li>
<li>IPv4</li>
<li>IPv6</li>
<li>IP路由器</li>
<li>防火墙</li>
<li>/proc/net目录</li>
<li>/sys/class/net目录</li>
<li>套接字</li>
</ol>
</li>
<li>user namespace:隔离了安全相关的标识符和属性，包括用户ID,用户组ID,root目录,key以及特殊权限。<ol>
<li>一个物理的网络设备最多存在于一个network namespace中，可以通过创建veth pair(虚拟网络设备对：有两端，类似于管道，如果数据从一段传入另一端也能接收到，反之亦然) </li>
<li>在不同的network namespace间创建通道</li>
<li>一般情况下，物理网络设备都分配在最初的root namespace中。如果有多块物理网卡，可以把其中一块或者多块分配给新创建network namespace。</li>
<li>当新创建的network namespace被释放时，就会返回root namespace。而把网络独立出来，给外部用户一种透明的感觉，彷佛在与一个独立网络实体进行通信。</li>
<li>为了达到该目的，容器的经典的做法就是创建一个veth pair,一端放置在新的namespace中，命名位eth0,一端放在原先的namespace中连接物理网络设备，再通过把多个设备接入网桥或者进行路由转发，来实现通信的目的。</li>
<li>在建立起veth pair之前，通过管道与新旧namespace进行通信。在docker deamon启动容器的，假设容器初始化的进程称为init。Docker deamon在主机上负责创建这个veth pair,把一端绑定到docker0网桥上，另一端接入新建的network space进程中。这个过程执行期间，Docker deamon和init就通过pipe进行通信。具体来说，Docker deamon完成veth pair的创建之前，init的管道的另一端循环等待，直到管道另一端传来docker deamon关于veth设备的信息，并关闭管道。init才结束等待的过程，并把它eth0启动起来。</li>
</ol>
</li>
<li>user namespaces</li>
</ol>
</li>
<li><p>cgroup资源限制</p>
<ol>
<li>限制资源，为资源设置权重，计算使用量，操控任务启停。</li>
<li>cgroups是linux内核提供的一种机制，这种机制可以根据需求把一些列系统任务以及子任务整合到按资源划分等级的不同组内，从而为系统资源管理提供一个统一框架。</li>
<li>cgroups可以限制，记录任务组所使用的物理资源（CPU,memory,IO），为容器实现虚拟化提供了基本保证，是构建Docker等一些列虚拟化管理工具的基石。</li>
<li>cgroups的4个特点：<ol>
<li>cgroups的API以一个伪文件系统的方式实现，用户态的程序可以通过文件操作实现cgroups的组织管理；</li>
<li>cgroups的组织管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroups，从而实现资源再分配和管理；</li>
<li>所有资源管理的功能都以子系统的方式实现，接口统一；</li>
<li>子任务创建之初与父任务处于同一个cgroups的控制组。</li>
</ol>
</li>
<li>本质上来说，cgroups是内核附加在程序上的一系列钩子，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</li>
<li>cgroups的作用<ol>
<li>目的是：为不同用户层面的资源管理，提供一个统一化接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups提供四大功能：</li>
<li>资源限制：对任务使用的资源总额进行限制，设定应用运行时使用内存上限，超过额度就发出OOM；</li>
<li>优先级分配：通过分配CPU时间片数量及磁盘IO带宽大小，实际是控制任务的优先级；</li>
<li>资源统计：统计系统的资源使用量，如CPU使用时长，内存用量等；</li>
<li>任务控制：对任务执行挂起，恢复等操作。</li>
</ol>
</li>
<li>cgroups术语表<ol>
<li>task</li>
<li>cgroup</li>
<li>subsystem</li>
<li>hierarchy</li>
</ol>
</li>
<li>组织结构与基本规则<ol>
<li>传统任务管理，实际上是先启动init任务作为根节点，再由init节点创建子任务作为子节点，而子节点又可以创建新的子节点。</li>
</ol>
</li>
</ol>
</li>
<li>docker架构概览<ol>
<li>使用传统的client-server架构模式，用户通过docker client与docker daemon建立通信，并将请求发送给后者。</li>
<li>APIServer用于接收来自docker client的请求后，根据不同的请求分发给docker daemon的不同模块执行相应的工作。</li>
<li>docker通过driver模块来实现对docker容器执行环境的定制。</li>
<li>当需要创建docker容器，可以从docker registry中下载镜像，并通过镜像管理graphdriver将下载的镜像以graph形式存储在本地；</li>
<li>当需要为Docker容器创建网络环境时，则通过网络管理驱动networkdriver创建并配置execdriver来完成。</li>
<li>libcontainer是一个独立的容器管理包，networkdriver和execdriver都通过libcontainer来实现对容器的具体操作，利用uts,ipc,pid,network,mount,user等namespace实现容器之间的资源隔离和利用cgroup实现对容器的资源限制。</li>
<li>当运行容器的命令执行完毕后，该容器就具有独立的文件系统，安全且相互隔离的运行环境。</li>
</ol>
</li>
<li>模块介绍<ol>
<li>docker daemon <ol>
<li>响应来自docker client的请求，然后将这些请求翻译成系统调用完成容器管理操作；</li>
<li>该进程会在后台启动一个API server,负责接收Docker client发送的请求；</li>
<li>接收到的请求将通过docker daemon内部的一个路由分发调度，再由具体的函数来执行请求。</li>
</ol>
</li>
<li>docker client <ol>
<li>用来向指定的docker daemon发起请求，执行相应的容器管理操作。</li>
<li>可以是docker命令行工具，也可以是任何遵循docker api的客户端。</li>
<li>graph组件负责维护已下载的镜像信息以及他们之间的关系，大部分docker相关的操作会有graph组件来完成。</li>
<li>graph通过镜像层和每层的元数据来记录这些镜像的信息，用户发起的镜像管理操作最终都转换成了graph对这些层和元数据的操作。</li>
</ol>
</li>
<li>graphdb<ol>
<li>通过graphdb记录它所维护的所有容器节点以及他们之间的link关系，用一个图结构来及逆行保存。</li>
<li>Graph是一个基于SQLite的最简单版本的图形数据库，能够为调用者提供节点增删遍历连接所有父子节点的查询；</li>
<li>这些节点对应的就是一个容器，而节点间的边就是docker link关系。</li>
<li>每创建一个容器，就会再graphdb里添加一个几点，而当我们为某个容器设置了link操作后，就会创建一个父子关系，即一条边。</li>
</ol>
</li>
<li>driver<ol>
<li>docker daemon负责将用户请求转化成系统调用，进而创建和管理容器的核心进程。为了将这些系统调用抽象成统一的操作接口方便调用者使用，docker把这些操作分类成容器管理驱动，网络管理驱动，文件存储驱动3种。分别对应execdriver,networkdriver和graphdriver。</li>
<li>execdriver是对Linux操作系统的namespace,cgroups,apparmor,SELinux等容器运行所需的系统操作进行一层二次封装，其本质作用类似于LXC,功能更全面。</li>
<li>networkDriver是对容器网络环境进行封装，对于容器来说，网络设备比较独立，并且允许用户进行更多配置。分配通信所需的ip,服务访问的端口和容器与宿主机之间的端口映射，设置hosts,resolv.conf,iptables等。</li>
<li>graphdriver是所有与容器镜像相关操作的最终执行者。graphdriver会在docker工作目录下维护一组与镜像层对应的目录，并记下容器和镜像之间关系等元数据。用户对镜像的操作最终会被映射成这些目录文件以及元数据的增删查改，从而屏蔽掉不同文件存储实现对于上层调用者的影响。 </li>
</ol>
</li>
<li>client和daemon</li>
<li>libcontainer</li>
</ol>
</li>
<li>docker镜像管理<ol>
<li>bootfs:底层引导文件系统，包括bootloader和操作系统内核，类似于linux引导文件系统。</li>
<li>rootfs:包含了一个操作系统运行所需的文件系统，如目录系统，配置，工具。<ol>
<li>传统的Linux操作系统内核启动时，首先时挂载一个只读的rootfs,当系统检测其完整性之后，再将其切换为读写模式。</li>
<li>在docker daemon为docker容器挂载rootfs时，将其设为只读模式。</li>
<li>在挂载完毕后，利用联合挂载技术在已有只读rootfs上再挂载一个读写层。</li>
<li>可读写层处于docker容器文件系统的最顶层，其下可能联合挂载多个只读层，只有docker容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并隐藏只读层种的老版本文件，这技术称为写时复制。</li>
<li>联合挂载技术:在一个挂载点同时挂载多个文件系统，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层文件和目录。</li>
<li>实现这种联合挂载技术的文件系统同城称为联合文件系统（UNFS）;</li>
<li>当需要修改镜像内的某个文件时，只对处于文件上方的读写层进行变动，不覆盖下层已有文件系统的内容，已有文件在只读层中的原始版本依然存在，但会被读写层中的新版本文件所隐藏，当docker commit这个修改过的容器文件系统为一个新的镜像时，保存内容仅为最上层读写文件系统中被更新过的文件。</li>
</ol>
</li>
<li>docker镜像相关的概念<ol>
<li>registry</li>
<li>repository</li>
<li>index</li>
<li>graph</li>
<li>dockerfile            </li>
</ol>
</li>
</ol>
</li>
<li>Docker存储驱动<ol>
<li>存储驱动根据操作系统底层的支持提供了针对某种文件系统的初始化操作以及对镜像层的增删改查和差异比较等操作。</li>
<li>映射设备，映射表和目标设备。</li>
</ol>
</li>
<li>docker数据卷<ol>
<li>读时复制的缺点    <ol>
<li>容器中的文件在宿主机上存在形式复杂，不能在宿主机上很方便地对容器中的文件进行访问。</li>
<li>多个容器之间数据无法共享。</li>
<li>当删除容器时，容器产生的数据将丢失。</li>
</ol>
</li>
<li>引入数据卷机制。<ol>
<li>存在于一个或多个容器中的特定文件或文件夹，这个目录能够独立于联合文件系统的形式在宿主机中存在，并为数据的共享与持久化提供便利。</li>
<li>volume在创建时就会初始化，在容器运行时可以使用其中的文件。</li>
<li>在不同的容器之间共享和重用。</li>
<li>数据的操作不会影镜像本身。</li>
<li>生存周期独立于容器生存周期，即使删除容器，v仍会存在。  </li>
</ol>
</li>
<li>数据卷原理<ol>
<li>本质是容器中的一个特殊目录。在容器的创建过程中，这个挂载点会被挂载到一个宿主机上的指定目录，这个挂载彷佛是绑定挂载。 </li>
<li>创建volume:不论用户使用何种方式创建或运行一个待volume的容器，volume的来源只有3种，从容器挂载，从宿主机挂载和从其他容器共享。docker daemon首先需要根据用户指定的volume类型，判断并新建出对应的mount对象。daemon针对mount对象执行如下操作：<ol>
<li>解析参数并生存Mount列表，每一个Mount描述一个volume和容器的对应关系或是一个容器与其它容器共享volume的情况。</li>
<li>初始化所有的Mount,这一过程在创建容器时执行，即在宿主机和容器文件目录下创建上述Mount对象种所需的路径。</li>
<li>将Mount对象传递给libcontainer，按照Mount对象中指定的路由，mount参数，读写标志执行所有的mount操作，完成从宿主机到容器内挂载点的映射</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>docker网络管理<ol>
<li>服务虚拟化，存储虚拟化，网络虚拟化</li>
<li>docker网络基础<ol>
<li>docker0网桥<ol>
<li>这台多的网卡会在内核路由表上添加一条达到相应网络的静态路由。eth0是容器与外界通信的网卡。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/docker/">docker</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/08/docker系列深入篇/" title="docker系列深入篇" itemprop="url">docker系列深入篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-10-08T11:00:51.000Z" itemprop="datePublished"> Published 2018-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1. 数据卷"></a>1. 数据卷</h2><ol>
<li>网络通信和文件读写</li>
<li>数据卷用于存储文件数据的特殊模块</li>
<li>数据卷：一个挂载在容器内文件系统中的文件或目录。</li>
<li>使用docker create或者docker run创建容器时，可以通过-v参数向容器中挂载一个数据卷。</li>
<li>使用docker rm -v /path删除数据卷<h2 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h2><h2 id="3-制作镜像"><a href="#3-制作镜像" class="headerlink" title="3. 制作镜像"></a>3. 制作镜像</h2><h2 id="4-网络进阶"><a href="#4-网络进阶" class="headerlink" title="4. 网络进阶"></a>4. 网络进阶</h2></li>
<li>Network Namespaces<ol>
<li>docker的容器技术是基于Linux Kernel提供的Linux Container。在Linux Container中，包含了能够隔离程序进程的Namespaces，在Namespaces技术里，存在一个用于隔离程序对网络信息调用的子模块—Network Namespaces。</li>
<li>每个被NetWork Namespaces隔离的空间都拥有自己的网络设备，ip地址，录用表，防火墙，端口表等。     </li>
</ol>
</li>
<li>Veth Pair<ol>
<li>一个虚拟的网络通道，将通道一段的数据传输到另外一段。实现了容器所隔离的网络环境与容器外部的网络通信。</li>
<li>Veth Pair提供两个端点，只能连接某两个网络终端。</li>
</ol>
</li>
<li>Linux Bridge把Veth Pair的一端都连接到宿主机中某个网桥所构成的交换机中，把容器连接不同的外部网络的任务由Veth Pair转移到网桥上。</li>
<li>Iptables<ol>
<li>用于管理网络过滤的程序，能够根据指定的规则，对位于Linux内核中的netfilter进行操作，实现对网络信息包的过滤功能。</li>
<li>利用Iptables可以实现端口的映射，让宿主机外部访问到容器的端口是通过端口映射来实现。<br>5.Docker网络主要由Network Namespaces,Veth Pair,Linux Bridge,Iptables等技术实现。</li>
<li>Network Namespaces:实现了网络资源隔离，对隔离环境提供了网络设备，协议栈，路由表，防火墙，/proc/net目录，/sys/class/net目录，端口表等网络配置。</li>
<li>Veth Pair:实现了打穿隔离环境的网络传输数据通道。在Docker中，它的一段连接到容器的虚拟网卡上，另一端连接到宿主机专用的网桥上，通过这种方式实现了Docker容器与外部网络的互通。</li>
<li>linux bridge:在置在宿主机中的网桥，起到网络交换机的作用。容器网络通过Veth Pair连接到网桥，能够在容器间转发网络数据。</li>
<li>Iptables:  用于提供网络数据透传，NAT功能，实现docker网络防火墙等网络安全防护的需求。<br>6.网络模型</li>
<li>CNM Container Network Model<ol>
<li>Sandbox 网络沙盒 </li>
<li>Endpoint 端点</li>
<li>NetWork 网络</li>
</ol>
</li>
<li>docker中的网络<ol>
<li>默认网络   </li>
<li>自定义网络</li>
<li>容器与外部通信</li>
</ol>
</li>
<li>网络实践<ol>
<li>管理容器网络</li>
<li>容器连接网络</li>
<li>配置docker0网桥</li>
<li>自定义网桥</li>
<li>配置DNS</li>
<li>使用IPV6<h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5.安全"></a>5.安全</h2></li>
</ol>
</li>
</ol>
</li>
<li>命名空间隔离<ol>
<li>仅仅让不同的命名空间独立享有进程信息，网络信息等。</li>
</ol>
</li>
<li>资源控制组    <ol>
<li>主要功能是CPU,内存,硬盘IO等程序访问的计算机资源进行控制。</li>
<li>docker中，每个容器都拥有一个独立的控制组策略集，用来控制容器中每个程序对计算机资源的访问和调用。</li>
<li>通过控制组:<ol>
<li>资源限制</li>
<li>优先化</li>
<li>用量报告</li>
</ol>
</li>
</ol>
</li>
<li>内核能力机制     </li>
<li>资源使用限制                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/docker/">docker</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/29/Netty系列之netty体系和概念/" title="Netty系列之netty体系和概念" itemprop="url">Netty系列之netty体系和概念</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-29T07:09:05.000Z" itemprop="datePublished"> Published 2018-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/29/k8s系列之k8s核心原理/" title="k8s系列之k8s核心原理" itemprop="url">k8s系列之k8s核心原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-29T06:22:49.000Z" itemprop="datePublished"> Published 2018-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="第2章-Kubernetes核心原理"><a href="#第2章-Kubernetes核心原理" class="headerlink" title="第2章 Kubernetes核心原理"></a>第2章 Kubernetes核心原理</h2><h3 id="1-Kubernetes-API-Server分析"><a href="#1-Kubernetes-API-Server分析" class="headerlink" title="1.Kubernetes API Server分析"></a>1.Kubernetes API Server分析</h3><ol>
<li>功能和地位    </li>
</ol>
<ul>
<li>提供了集群管理的API接口；</li>
<li>成为集群内各个功能模块之间数据交互和通信的中心枢纽；</li>
<li>拥有完备的集群安全机制。</li>
</ul>
<ol start="2">
<li>如何访问K8S API<ol>
<li>K8S API通过K8S apiserver进程提供服务，运行于master节点。该进程有2个端口：<ol>
<li>本地端口<ol>
<li>该端口用于接收Http请求；</li>
<li>默认值为8080，可以通过修改–insecure-port值来修改默认值。</li>
<li>默认ip地址是localhost,通过修改–insecure-bing-address的值来修改该IP地址；</li>
<li>非认证或授权的Http请求通过该端口访问API Server。</li>
</ol>
</li>
<li>安全端口</li>
</ol>
</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/k8s/">k8s</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/27/k8s系列之入门/" title="k8s系列之入门" itemprop="url">k8s系列之入门</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-27T08:02:12.000Z" itemprop="datePublished"> Published 2018-09-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="第一章-Kubernetes入门"><a href="#第一章-Kubernetes入门" class="headerlink" title="第一章 Kubernetes入门"></a>第一章 Kubernetes入门</h1><ol>
<li>K8S是什么<ol>
<li>大规模集群管理系统，基于容器技术，实现资源管理的自动化，以及跨多个数据中心得资源利用率最大化。</li>
<li>TCP通信协议进行交互。</li>
<li>完备得分布式系统支撑平台，具有完备得集群管理能力，多层次得安全防护和准入机制，多租户应用支撑能力，透明的服务注册和服务发现机制，内建智能负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力，可扩展的资源自动调度机制，多粒度的资源配额管理能力，完善的管理工具，如开发，部署测试，运维监控等各个环节。</li>
</ol>
</li>
<li>K8S基础<ol>
<li>Service是分布式集群架构的核心，一个Service对象拥有如下关键特征：<ol>
<li>拥有一个唯一指定的名字；</li>
<li>拥有一个虚拟ip和端口号；</li>
<li>能够提供某种远程服务能力；</li>
<li>被映射到了提供这种服务能力的一组容器应用上。</li>
</ol>
</li>
<li>Service的服务进程目前都基于Socket通信方式对外提供服务，如redis,Memcache,MySql,WebServer,或者一个特定的TCP server进程。Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的IP+PORT访问点，从来连接到指定的Service上。</li>
<li>强大的隔离功能，K8S设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器。为了建立Service和Pod间的关联关系，K8S给Pod贴上一个Label，给运行MySQL的Pod贴上name=mysql标签。</li>
<li>Pod在节点中运行，节点可以是物理机，可以是云中的一个虚拟机，每个Pod里面运行着一个特殊的Pause容器，其他容器运行业务容器，这些业务容器工厂Pause容器的网络栈和Volume挂载卷，因而通信和数据交换更为高效。因此密切相关的服务进程放入同一个Pod中。</li>
<li>集群管理:将集群中机器划分为一个Master节点和一群工作节点，Master上运行着集群管理相关的一组进程kube-apiserver,kube-controller-manager和kube-scheduler,这些进程实现了整个集群资源管理，Pod调度，弹性伸缩，安全控制，系统监控和纠错等管理功能，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的APP,在Node上K8S管理的最小运行单元式Pod。Node上运行着Kubelet,kube-proxy服务进程，这些服务进程负责Pod的创建，启动监控，重启销毁以及软件模式的负载均衡。</li>
</ol>
</li>
<li>使用K8S的原因<ol>
<li>IT从来都是技术驱动的。</li>
<li>简化团队，架构师专注于系统服务组件的提炼，开发专注于业务代码，运维负责K8S的部署和运维。</li>
<li>全面拥抱微服务，微服务架构的核心是将一个巨大的单体应用分解维很多小的相互连接的微服务，一个微服务背后有多个实例副本在支撑，副本数量随着系统的负荷变化而进行调整，内嵌的负载均衡器在这里发挥重要作用。</li>
<li>很方便的搬迁到公有云上。</li>
<li>超强的横向扩容能力。<br>4.K8S基本概念和术语</li>
<li>Node—相对于master而言的的工作主机。每个node上运行用于启动和管理的Pod服务-Kubelet，并能够被Master管理。在node上运行的是服务进程包括Kubelet,Kube-proxy,docker deamon。</li>
<li>Node的信息:<ol>
<li>Node地址：主机Ip地址+NodeID</li>
<li>Node运行状态:Pending,Running,Terminated三种状态</li>
<li>Node Condition(条件):描述Running状态Node的运行条件，Read—健康状态，可以接收从Master发来的创建Pod指令。</li>
<li>Node系统容量:描述Node可用的系统资源，包括CPU,内存数量，最大可调度Pod数量等。</li>
<li>其他:内核版本，K8S版本，docker版本，操作系统名称。</li>
</ol>
</li>
<li>Pod<ol>
<li>最基本的操作单元，包含一个或多个紧密相关的容器。是被容器化的环境看作应用层的逻辑宿主机，一个Pod中的多个容器应用是紧耦合的。Pod在node上被创建，启动或者销毁。</li>
<li>在Pod上封装Node的原因:Docker容器之间的通信收到Docker网络机制的限制，只能通过Link方式才能访问另一个容器提供的服务。大量容器之间的Link是一种重量级连接。通过Pod将多个容器组合在一个虚拟的主机内，可以通过Localhost就能通信。</li>
<li>一个Pod中的应用容器共享同一组资源：<ol>
<li>PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID;</li>
<li>网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围；</li>
<li>IPC命名空间：Pod中的多个容器能够使用SystemV IPC或者POSIX消息队列进行通信；</li>
<li>UTS命名空间：Pod中的多个容器共享一个主机名；</li>
<li>Volumes（共享存储卷）:pod中的各个容器可以访问在Pod级别定义的Volumes。</li>
</ol>
</li>
<li>Pod定义通过Yml或者json格式配置文件来完成。</li>
<li>Pod的生命周期是通过Replication Controller来管理的。Pod的生命周期过程包括:在模板进行定义，然后分到Node上运行，在Pod所含容器运行结束后Pod也结束。在整个过程中，Pod处于一下4种状态之一：<ol>
<li>Pending:Pod定义正确，提交Master，但其包含的容器镜像还未完全创建。通常Master对Pod进行调度需要一些时间，之后Node对镜像进行下载也需要一些时间。</li>
<li>Running:Pod已被分配到某个Node上，但其包含的所有容器镜像都已经创建完成，并成功运行起来。</li>
<li>Suceeded:Pod中所有所有容器都成功结束，并且不会重启，这是Pod最终状态。</li>
<li>Failed:Pod中所有容器都结束了，但至少一个容器以失败状态结束的，这是Pod的一种最终状态。</li>
</ol>
</li>
</ol>
</li>
<li>Label(标签)<ol>
<li>Label以key/value键值对的形式附加到各种对象上，如Pod,Service,RC,Node等。Label定义了这些对象的可识别属性，用来对它们进行管理和选择。Label可以在创建对象时附加到对象上，也可以在对象创建后通过API进行管理。</li>
<li>在为对象定义好Label后，其他对象就可以使用Label Selector选择器来定义其作用的对象。<br> “Labels”:{<pre><code>&quot;key1&quot;:&quot;value1&quot;,
&quot;key2&quot;:&quot;value2&quot;
</code></pre> }    </li>
<li>Label Selector时，看作SQL查询语句种的where查询条件的语法。<br>5.Replication Controller(RC)</li>
<li>用于定义Pod副本的数量。在Master内，Controller Manager进行通过RC的定义来完成Pod的创建，监控，启停等操作。</li>
</ol>
</li>
<li>Service<ol>
<li>Pod都会分配一个单独的IP地址，但是会随着Pod的销毁而消失。如果一组Pod组成一个集群来提供服务，如何访问；</li>
<li>一个Service可以看作一组提供相同服务的Pod对外访问接口。Service作用于那些Pod是通过Label Selector来定义的。</li>
<li>Pod的IP地址和Service的Cluster的IP地址<ol>
<li>Pod的IP地址是Docker Daemon根据docker0网桥的IP地址段进行分配的，但是Service的ClusterIP地址是K8s系统种的虚拟IP地址，由系统动态分配。service的ClusterIP地址相对于Pod的IP地址来说相对稳定，Service被创建时被分配一个IP地址，销毁该Service之前，这个IP地址都不会再变化了。Pod在K8S集群中生命周期较短，ReplicationController销毁，再次创建，会分配一个新的IP地址。</li>
</ol>
</li>
<li>外部访问Service<ol>
<li>Service对象在ClusterIPRange池中分配的IP只能在内部访问，所以其他Pod都可以无障碍地访问到它。如果这个Service作为前端服务，准备为集群外的客户端提供服务，就需要分配公共IP;</li>
<li>K8S支持两种对外提供服务的Service的type定义:NodePort和LoadBalancer</li>
<li>NodePort</li>
<li>LoadBalancer</li>
</ol>
</li>
</ol>
</li>
<li>Volume(存储卷)<ol>
<li>Volume是Pod中能够被多个容器访问的共享目录。K8S的Volume概念与Docker的Volume比较类似。</li>
<li>Volume类型<ol>
<li>EmptyDir:一个EmptyDir Volume是在Pod分配到Node时创建得。从它的名称就可以看出，初始为空。同一个Pod中所有容器可以读些EmptyDir中得相同文件。当Pod从Node上移除时，EmptyDir中得数据也会永久被删除。<ol>
<li>用途:临时空间，例如用于某些应用程序运行时所需得临时目录，且无须永久保留。长时间任务的中间过程CheckPoint临时保存目录。一个容器需要从另一个容器中获取数据的目录。</li>
<li>tmpfs</li>
</ol>
</li>
<li>hostPath:在Pod上挂载宿主机上的文件或目录。<ol>
<li>容器应用程序生成的日志文件需要永久保存</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Namespace<ol>
<li>Namespace是k8s系统中另一个非常重要的概念，通过将系统内部的对象分配到不同的Namespace中，形成逻辑上分组的不同项目，小组，用户组，便于不同的分组在共享使用整个集群的同时还能被分别管理。</li>
</ol>
</li>
<li>Annotation</li>
</ol>
</li>
<li>K8S总体架构<ol>
<li>k8s集群由两类节点组成:Master和Node,Master上运行etcd,API Server,Controller Manager和Scheduler四个组件，后三个组件构成了K8S的总控中心，负责对集群中所有资源进行管控和调度。</li>
<li>在每个Node上运行Kubelet,Proxy和Docker Daemon三个组件，负责对本节点上的Pod的生命周期进行管理，以实现服务代理的功能。</li>
<li>所有节点上都可以运行Kubectl命令行工具，提供了K8S的集群管理工具集。</li>
<li>etcd是高可用的key/value存储系统，用于持久化存储集群中所有的资源对象，如Node,Service,Pod,RC,Namespace等。API Server则提供了操作etcd的封装接口API，以Rest方式提供服务，这些API基本上都是集群中资源对象的增删改查及监听资源变化的接口，如创建Pod,创建RC,监听Pod的变化等接口。API Server是连接其他所有服务组件的枢纽。</li>
<li>RC与相关Service创建完整流程<ol>
<li>通过Kubectl提交一个创建RC的请求，该请求通过APIServer被写入etcd;</li>
<li>此时Controller Manager通过API Server的监听资源变化的接口监听到这个RC事件，分析之后，发现当前集群中没有Pod实例。</li>
<li>于是根据RC的Pod模板定义生成一个Pod对象，通过API Server写入etcd中，接下来此事件被Scheduler发现，执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，这个过程称为绑定（Pod Binding）。</li>
<li>通过API Server将这一结果写入到etcd中，随后目标Node上运行的Kubelet进程通过API Server检测到这个新生的Pod并按照定义，启动改Pod并负责其下半生，直到Pod的生命走到尽头。</li>
<li>通过Kubetcl提交一个映射到该Pod的Service的创建请求，Controller Manager会通过Label标签查询到相关联的Pod实例，然后生成Service的EndPoints信息并通过API Server写入到etcd中。</li>
<li>接下来所有Node上运行的Proxy进程通过API Server查询并监听Service对象与其对应的Endpoints信息，建立一个软件方式负载均衡器来实现service访问到后端Pod的流量转发功能。</li>
</ol>
</li>
<li>组件的功能<ol>
<li>API Server:提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，通过相关的资源数据”全量查询”+”变化监听”，这些组件可以实时地完成相关业务功能，如某个新的Pod一旦被提交到API Server中，C M就会立即发现并开始调度。</li>
<li>Controller Manager:集群内部的管理控制中心，其主要目的是实现K8S集群自动检测和恢复的自动化工作，比如根据RC的定义完成Pod的复制或移除，以确保Pod实例数符合RC副本的定义；根据Service与Pod的管理关系，完成服务的EndPoints对象的创建和更新；其他诸如Node的发现，管理和状态监控，死亡容器所占磁盘空间及本地缓存的镜像文件的清理工作也是由Controller Manager完成的。</li>
<li>Scheduler:集群的调度器，负责Pod在集群节点中的调度分配。</li>
<li>Kubelet:负责本Node节点上的Pod创建，修改，监控，删除等全生命周期管理，同事Kubelet定时上报本节点的状态信息到API Server里。</li>
<li>Proxy:实现了Service的代理及软件模式的负载均衡器。</li>
<li>客户端通过Kubectl命令行工具或Kubetcl Proxy来访问K8S系统，在K8S集群内部的客户端可以直接使用Kubetcl命令管理集群。Kubectl Proxy是APIServer的一个反向代理，在K8s集群外部的客户端可以通过Kubectl Proxy来访问API Server。</li>
<li>API Server内部有一套完备的安全机制，包括认证，授权，以及准入控制等相关模块，APIServer在收到Rest请求后，会首先执行认证授权和准入控制的相关逻辑，过滤掉非法请求，然后将请求发送给API Server中的REST服务模块去执行资源的具体操作逻辑。</li>
<li>Node节点运行的K8S服务内嵌了一个cAdvisor服务，用于实时监控Docker上运行的容器指标。</li>
</ol>
</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/k8s/">k8s</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/25/设计模式系列之设计模式基础/" title="设计模式系列之设计模式基础" itemprop="url">设计模式系列之设计模式基础</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-25T12:05:09.000Z" itemprop="datePublished"> Published 2018-09-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h2><pre><code>在软件开发中，经过验证的，用于解决特定环境下，重复出现的、特定问题的解决方案。
</code></pre><p><strong>看完后思考，思考后应用，然后再看，再思考，再应用。</strong></p>
<h2 id="2-常见设计模式"><a href="#2-常见设计模式" class="headerlink" title="2.常见设计模式"></a>2.常见设计模式</h2><ol>
<li>简单工厂</li>
<li>外观模式</li>
<li>适配器模式</li>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>抽象工厂模式</li>
<li>生成器模式</li>
<li>原型模式</li>
<li>中介者模式</li>
<li>代理模式</li>
<li>观察者模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>组合模式</li>
<li>模板方法模式</li>
<li>策略模式</li>
<li>状态模式</li>
<li>备忘录模式</li>
<li>亨元模式</li>
<li>解释器模式</li>
<li>装饰模式</li>
<li>职责链模式</li>
<li>桥接模式</li>
<li>访问者模式</li>
</ol>
<p>##3. 讲述结构  ##</p>
<ol>
<li>场景问题<ol>
<li>某个实际应用</li>
<li>不用模式的解决方案</li>
<li>存在问题</li>
</ol>
</li>
<li>解决方案<ol>
<li>某个模式来解决</li>
<li>模式结构和说明</li>
<li>模式的实例代码</li>
<li>使用模式来重写示例</li>
</ol>
</li>
<li>模式讲解<ol>
<li>认识某个模式</li>
<li>针对各个重点难点功能，实际应用结合的讨论和示例</li>
<li>模式的优缺点</li>
<li>思考模式</li>
<li>相关模式</li>
</ol>
</li>
</ol>
<p>++++++============================++++++++</p>
<h2 id="第二章-简单工厂"><a href="#第二章-简单工厂" class="headerlink" title="第二章 简单工厂"></a>第二章 简单工厂</h2><p>-相关：单例，原型，生成器模式</p>
<h3 id="1-场景问题"><a href="#1-场景问题" class="headerlink" title="1. 场景问题"></a>1. 场景问题</h3><pre><code>1. 接口回顾
2. 接口用处
3. 接口思想
4. 接口好处
5. 接口和抽象类
    1. 优先使用接口
    2. 既要定义子类的行为，又要具有公共的功能时使用抽象类
</code></pre><h3 id="2-面向接口编程"><a href="#2-面向接口编程" class="headerlink" title="2.面向接口编程"></a>2.面向接口编程</h3><p>1.分层<br>    表现层 逻辑层 数据层<br>2.接口是被其隔离部分的外观:通过接口来进行交互<br>3.组件:能完成一定功能得封装体。小到一个类，大到一个系统，都可以称为组件，一个小的系统放到更大的系统里面去，就是充当一个组件的作用。系统，子系统，模块，组件是一个概念，都是一定功能的封装体。</p>
<h3 id="3-不同模式的解决方案"><a href="#3-不同模式的解决方案" class="headerlink" title="3.不同模式的解决方案"></a>3.不同模式的解决方案</h3><ol>
<li>定义一个API，然后一个实现类Impl，客户端调用这个接口的实例。</li>
<li>客户端只知道接口，不知道实现。<h3 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h3></li>
<li>简单工厂：提供一个创建对象实例的功能，无须关心具体实现。被创建实例的类型可以是接口，抽象类，也可以是具体的类。</li>
<li>应用简单工厂来解决问题的思路:在内部新建一个类，在里面来创建接口，然后把创建好的接口返回给客户端，外部应用通过这个类就获取相应的接口，然后就可以操作相应的方法，这个对象就叫做简单工厂。</li>
<li>可配置的简单工厂<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h3></li>
<li>简单工厂的优点<ol>
<li>帮助封装</li>
<li>解耦</li>
</ol>
</li>
<li>缺点<ol>
<li>增加客户端的复杂度</li>
<li>不方便扩展子工厂<h3 id="6-思考简单工厂"><a href="#6-思考简单工厂" class="headerlink" title="6.思考简单工厂"></a>6.思考简单工厂</h3></li>
</ol>
</li>
<li>本质:选择实现，重点是实现已经做好了，就算实现简单，也要有具体的实现类。</li>
<li>何时选用简单工厂:完全封装隔离具体实现，让外部只能通过接口来操作封装体。如果想要把创建对象的职责集中管理和控制，选用简单工厂。</li>
</ol>
<p>==================++++++++++++++++++++++=====================</p>
<h2 id="第三章-外观模式-Facade"><a href="#第三章-外观模式-Facade" class="headerlink" title="第三章. 外观模式(Facade)"></a>第三章. 外观模式(Facade)</h2><ol>
<li>解决方案<ol>
<li>界面和接口：为子系统种的一组接口提供一个一直的界面，Facade模式定义了一个高层接口，接口使得这一子系统更加容易使用。</li>
<li>界面—&gt;组件</li>
<li>外观模式就是通过引入这么一个外观类，在这个类里面定义客户端想想要的方法，然后在这些方法的实现里面，由外观类再去分别调用内部的多个模块来实现功能，从而让客户端变得简单。</li>
</ol>
</li>
<li>结构和说明<ol>
<li>Facade:定义子系统的多个模块对外高层接口，通常需要调用内部多个模块，从而把客户端的请求代理给适当的子系统对象。 </li>
<li>模块:接受Facade对象的委派，真正实现功能，各个模块之间会有交互<br>3.理解</li>
<li>目的:不是为了让外部减少与子系统内多个模块的交互，松散耦合，让外不能更简单地使用子系统。</li>
<li>方便客户端调用，封装了系统的内部细节功能。功能的复用。减少了学习成本。</li>
<li>外观模式可以实现成为一个单例，接口。</li>
</ol>
</li>
</ol>
<p>======================++++++++++++++++++++++++================</p>
<h2 id="第四章-适配器模式-Adapter"><a href="#第四章-适配器模式-Adapter" class="headerlink" title="第四章 适配器模式(Adapter)"></a>第四章 适配器模式(Adapter)</h2><ol>
<li>解决方案<ol>
<li>将一个类的接口转换成客户端希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>定义一个类来实现第二版接口，在实现的时候转调第一版的功能，这样通过<strong>对象组合</strong>的方式，复用第一版已有的功能，同时又满足第二版调用的要求。</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/设计模式/">设计模式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/06/算法系列之源初/" title="算法系列之源初" itemprop="url">算法系列之源初</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-06T00:53:52.000Z" itemprop="datePublished"> Published 2018-09-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="3-基本算法思想"><a href="#3-基本算法思想" class="headerlink" title="3. 基本算法思想"></a>3. 基本算法思想</h2><ol>
<li>算法可以帮助用户清理问题的头像，更快地解决问题。</li>
<li>常用的算法：<ol>
<li>穷举</li>
<li>递推</li>
<li>递归</li>
<li>分治</li>
<li>概率<h3 id="3-1-穷举"><a href="#3-1-穷举" class="headerlink" title="3.1 穷举"></a>3.1 穷举</h3></li>
</ol>
</li>
<li>穷举基本思想===无规律场景 <ol>
<li>穷举的基本思想就是从所有可能的情况中搜索正确的答案，执行步骤：<ol>
<li>对于一种可能的结果，计算其结果；</li>
<li>判断结果是否满足要求，如果不满足继续执行（1）步来搜索下一个可能的情况；如果满足结果，则表示找到正确答案。</li>
</ol>
</li>
<li>使用穷举算法时，需要明确问题的答案范围，在指定范围内搜索答案。指定范围后，使用循环语句和条件判断语句逐步验证候选答案的正确性，从而得到正确答案</li>
</ol>
</li>
<li>实例<h3 id="3-2-递推"><a href="#3-2-递推" class="headerlink" title="3.2 递推"></a>3.2 递推</h3></li>
<li>递推基本思想===有规律场景<ol>
<li>理性思维的代表，根据已有数据和关系，逐步推导而得到结果。递推算法如下:<ol>
<li>根据已知结果和关系，求解中间结果。</li>
<li>判定是否达到要求，如果没达到，则根据已知结果和关系求解中间结果;如果满足要求则表示找到一个正确答案。<br>2.问题和答案的关系。</li>
</ol>
</li>
</ol>
</li>
<li>实例<ol>
<li>斐波那契算法<h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3></li>
</ol>
</li>
<li>递归基本思想<ol>
<li>递归算法就是在程序中不断反复调用自身来达到求解问题的方法。要求待求解的问题能够分解为相同问题的一个子问题。</li>
<li>递归调用是一个方法在其方法体内调用自身的方法调用方式。</li>
<li>分类：直接递归，间接递归</li>
<li>编写递归方法时，必须使用if语句强制方法在未执行递归调用前返回。否则永不返回。</li>
</ol>
</li>
<li>实例<h3 id="3-4-分治"><a href="#3-4-分治" class="headerlink" title="3.4 分治"></a>3.4 分治</h3></li>
<li>分治基本思想<ol>
<li>分支问题就是将计算复杂的问题分为规模较小，计算简单的小问题求解，然后综合各个小问题，而得到最终的答案。</li>
<li>过程:<ol>
<li>对于一个规模为N的问题，若该问题可以轻松解决，则直接解决；否则执行以下步骤。</li>
<li>将该问题分解为M个规模较小的自问题，这些子问题相互独立，并且与原问题形式相同。</li>
<li>递归地解这些自问题。</li>
<li>将子问题的解合并得到最终的答案。</li>
</ol>
</li>
</ol>
</li>
<li>实例:寻找假币<h3 id="3-5-概率"><a href="#3-5-概率" class="headerlink" title="3.5 概率"></a>3.5 概率</h3></li>
</ol>
<h2 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4. 排序算法"></a>4. 排序算法</h2><p> 排序算法概述</p>
<pre><code>1. 基本的交换排序，选择排序，插入排序，合并排序。
2. 交换排序:冒泡排序和快速排序
3. 选择排序:选择排序和堆排序
4. 插入排序
5. 多路归并排序
</code></pre><h3 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h3><p>核心代码:</p>
<pre><code>for(int i = 0;i&lt;arr.length;i++) 
{     
    for(int j = 0;j &lt;arr.length-i;j++) {
        if(arr[j] &gt; arr[j+1]) {
            int temp = arr[j];            
            arr[j] = arr[j+1];
            arr[j+1] = temp;            
        }
    }    
}
</code></pre><h3 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h3><ol>
<li>首先从原始数组中选择最小的1个数据，将其和位于第一个位置的数据交换；</li>
<li>接着从剩下的n-1个数据中选择次小的元素，将其和第2个位置数据交换；</li>
<li>不断重复直到最后两个数据完成交换。    </li>
<li>核心代码    </li>
</ol>
<pre><code>for(int i =0;i&lt;a.length-1;i++) {
    int    index = i;
    for(int j=i+1;j&lt;a.length;j++) {
        if(a[j] &lt; a[index]) {
            index = j;            
        }        
    }
    if(index != i) {

    }
} 
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/04/Docker系列之入门介绍/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-04T08:09:26.349Z" itemprop="datePublished"> Published 2018-09-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <hr>
<p>title: Docker系列之入门介绍<br>date: 2018-09-04 16:09:26<br>tags: Docker</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><pre><code>1. 镜像
2. 容器
3. 仓库 
</code></pre><h2 id="2-Docker镜像"><a href="#2-Docker镜像" class="headerlink" title="2.Docker镜像"></a>2.Docker镜像</h2><pre><code>1. 操作系统分为内核和用户空间。对于linux而言内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像，就相当于一个root文件系统。
2. 分层存储
</code></pre><h2 id="3-Docker容器"><a href="#3-Docker容器" class="headerlink" title="3.Docker容器"></a>3.Docker容器</h2><pre><code>1. 镜像和容器就像的类和实例。
2. 拉取镜像:docker pull [地址] [仓库名]
3. 启动容器:docker run --it --rm [地址+仓库名]
4. 列出镜像:docker images
</code></pre><h2 id="4-镜像"><a href="#4-镜像" class="headerlink" title="4.镜像"></a>4.镜像</h2><pre><code>1. 联合文件系统
2. 镜像分层结构
3. 镜像的写时复制
</code></pre><h2 id="5-镜像的命令"><a href="#5-镜像的命令" class="headerlink" title="5.镜像的命令"></a>5.镜像的命令</h2><pre><code>1. docker pull
2. docker search
3. docker images
4. docker inspect
5. docker rmi 
6. docker save 
7. docker load
</code></pre><h2 id="6-Docker-Hub简介"><a href="#6-Docker-Hub简介" class="headerlink" title="6.Docker Hub简介"></a>6.Docker Hub简介</h2><pre><code>1. 镜像仓库:docker login -u -p
2. 搭建仓库
</code></pre><h2 id="7-管理和使用容器"><a href="#7-管理和使用容器" class="headerlink" title="7.管理和使用容器"></a>7.管理和使用容器</h2><pre><code>1. docker create
2. docker run 
3. docker ps
4. docker daemon
5. docker start
6. docker stop
7. docker pause
8. docker unpause
9. docker rm
10. docker top
11. docker log
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/" title="Dubbo系列之Dubbo可扩展性SPI" itemprop="url">Dubbo系列之Dubbo可扩展性SPI</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-03T02:07:36.000Z" itemprop="datePublished"> Published 2018-09-03</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-Dubbo扩展机制"><a href="#1-Dubbo扩展机制" class="headerlink" title="1. Dubbo扩展机制"></a>1. Dubbo扩展机制</h2><ul>
<li>任何系统都是从小系统不断完善的，应当关注当下的需求，然后不断对系统进行迭代。</li>
<li>代码层面，需要适当的对关注点进行抽象和隔离，在不断添加和特性时，仍然能保持良好的结构和可维护性，同时允许第三方开发者对其功能及进程扩展。</li>
<li>对扩展性的追求甚至超过了性能。</li>
<li>良好的扩展性<ul>
<li>作为框架的维护这，在添加新功能的时候，只需要添加一些新的代码，而不用大量修改现有代码，符合开闭原则</li>
<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架源码，在自己工程中添加代码即可。<h2 id="2-可扩展的集中解决方案"><a href="#2-可扩展的集中解决方案" class="headerlink" title="2. 可扩展的集中解决方案"></a>2. 可扩展的集中解决方案</h2></li>
</ul>
</li>
<li>通常有：<ul>
<li>Factory模式</li>
<li>IoC容器</li>
<li>OSGI容器</li>
</ul>
</li>
<li>Dubbo参考了Java原生的SPI机制，并进行一定扩展，以满足Dubbo需求。<h2 id="3-Java-SPI机制"><a href="#3-Java-SPI机制" class="headerlink" title="3. Java SPI机制"></a>3. Java SPI机制</h2></li>
</ul>
<ol>
<li>Java SPI(Service Provider Interface)是JDK一种动态加载扩展点的实现。</li>
<li>在ClassPath的META-INF/services目录下放置一个接口同名的文本文件，内容为接口的实现类，多个实现类用换行符分割。</li>
<li>缺点：<ul>
<li>需要遍历所有的实现，并实例化，然后才能在循环中找到我们需要的实现。</li>
<li>配置文件中只是需要简单的列出所有扩展实现，没有命名，很难定位。</li>
<li>扩展如果依赖其他扩展就做不到自动注入和装配。</li>
<li>不提供类似于Spring IOC和AOP功能。</li>
<li>很难和其他框架集成。<h2 id="4-Dubbo扩展点机制"><a href="#4-Dubbo扩展点机制" class="headerlink" title="4. Dubbo扩展点机制"></a>4. Dubbo扩展点机制</h2></li>
</ul>
</li>
<li>扩展点—Java接口</li>
<li>扩展—扩展点的实现类</li>
<li>扩展实例—扩展点实现类的实例</li>
<li>扩展自适应实例—扩展代理类</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/Dubbo-SPI/">Dubbo SPI</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/k8s/" title="k8s">k8s<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/消息队列/" title="消息队列">消息队列<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Druid-数据库连接池/" title="Druid 数据库连接池">Druid 数据库连接池<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Dubbo-SPI/" title="Dubbo SPI">Dubbo SPI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/netty/" title="netty">netty<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SofaRPC/" title="SofaRPC">SofaRPC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Sentinel系列/" title="Sentinel系列">Sentinel系列<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringMVC/" title="SpringMVC">SpringMVC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringAOP/" title="SpringAOP">SpringAOP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Druid-SQL解析/" title="Druid SQL解析">Druid SQL解析<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Zookeeper/" title="Zookeeper">Zookeeper<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Druid/" title="Druid">Druid<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/秒杀/" title="秒杀">秒杀<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/高并发/" title="高并发">高并发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringCloud-微服务/" title="SpringCloud 微服务">SpringCloud 微服务<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MySQL/" title="MySQL">MySQL<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/微服务设计读书笔记/" title="微服务设计读书笔记">微服务设计读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/跳表-SkipList/" title="跳表 SkipList">跳表 SkipList<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Rocky ZhouJin QQ987415811">Rocky ZhouJin QQ987415811</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
