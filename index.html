
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>Rocky for Everything</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="Rocky ZhouJin QQ987415811">
    

    
    <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">

    
    <link rel="alternative" href="/atom.xml" title="Rocky for Everything" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.png" alt="Rocky for Everything" title="Rocky for Everything"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Rocky for Everything">Rocky for Everything</a></h1>
				<h2 class="blog-motto">慢慢喜欢你</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/11/05/大讲座笔记系列之springcloudnacos讲座/" title="大讲座笔记系列之springcloudnacos讲座" itemprop="url">大讲座笔记系列之springcloudnacos讲座</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-11-05T13:28:38.000Z" itemprop="datePublished"> Published 2018-11-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <a id="more"></a>
<ol>
<li>云计算 云原生</li>
<li>Open Source</li>
<li>LAMP-&gt;Java WEB -&gt;Java WEB -&gt;应用拆分，分布式服务</li>
<li>源代码冲突，项目团队协同</li>
<li>服务注册与管理，配置的注册与管理，服务元数据的管理</li>
<li>支持生态springcloud cloudnative dubbo 公有云</li>
<li>注册中心：zk 缺点:特性，service管理缺失，本质不是做服务发现的产品</li>
<li>基于DNS的服务发现</li>
<li>服务发现与服务管理（在微服务角度如何管理），配置中心（）</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/nacos/">nacos</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/11/Netty系列之Netty实战读书笔记/" title="Netty系列之Netty实战读书笔记" itemprop="url">Netty系列之Netty实战读书笔记</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-10-11T12:21:43.000Z" itemprop="datePublished"> Published 2018-10-11</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p> netty实战的笔记介绍</p>
        
        
        <p class="article-more-link">
          
            <a href="/2018/10/11/Netty系列之Netty实战读书笔记/#more">Read More</a>
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/netty/">netty</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/10/docker系列之doker核心原理解读/" title="docker系列之doker核心原理解读" itemprop="url">docker系列之doker核心原理解读</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-10-10T13:47:14.000Z" itemprop="datePublished"> Published 2018-10-10</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-docker背后的内核知识"><a href="#1-docker背后的内核知识" class="headerlink" title="1. docker背后的内核知识"></a>1. docker背后的内核知识</h2><ol>
<li>docker容器本质上是宿主机上的<strong>进程</strong>。<ol>
<li>通过namespaces实现了资源隔离。</li>
<li>通过cgroups实现了资源限制。</li>
<li>通过写时复制实现高效文件操作。</li>
</ol>
</li>
<li>通过namespace资源隔离<ol>
<li>chroot—文件系统被隔离</li>
<li>在分布式环境下进行通信和定位，容器使用独立的IP，端口，路由等。—网络的隔离</li>
<li>容器需要一个独立的主机名，以便在网络中识别自己。—进程间通信也需要隔离—开发者权限—用户权限</li>
<li>容器中的应用需要有进程号，需要与宿主机的PID进行隔离。</li>
<li>6项隔离：<ul>
<li>主机名与域名</li>
<li>信号量，消息队列，内存共享</li>
<li>进程编号</li>
<li>网络设备，网络栈，端口</li>
<li>挂载点</li>
<li>用户用户组</li>
</ul>
</li>
<li>同一个namespace下的进程可以相互感知彼此的变化</li>
</ol>
</li>
<li><p>namespaceAPI的4种方式</p>
<ol>
<li>通过clone()在创建新进程的同时创建namespace，是Linux系统调用fork()的一种实现方式，通过flags来控制。</li>
<li>查看/proc/[pid]/ns文件：如果两个进程指向的namespace编号相同，就说明他们在同一个namespace下，/proc/[pid]/ns里面设置这些link，一旦link文件被打开，只要打开文件描述符存在，那么/uts。</li>
<li>setnx()加入一个已经存在的namespace</li>
<li>通过unshare()在原先进程上进行namespace隔离</li>
<li>fork()系统调用<ul>
<li>程序调用fork()函数时，系统会创建新的进程，为其分配资源，将原来进程的所有值都复制到新进程种，只有少数数值与原来进程值不同，相当于复制了本身。<br>4.6种namespace</li>
</ul>
</li>
<li>UTS namespace 主机名和域名隔离</li>
<li>IPC namespace 进程间通信:信号量，消息队列，共享内存。申请IPC资源申请一个全局唯一的32位ID,包含了系统IPC标识符以及实现POSIX消息队列的文件系。同一个IPC namespace下进程彼此可见，不同IPC namespace下进程相互不可见。</li>
<li>PID namespace PID重新编号<ol>
<li>PID namespace种的init进程</li>
<li>信号与init进程</li>
<li>挂载proc文件系统</li>
<li>unshare()和setns()</li>
</ol>
</li>
<li>mount namespace 通过隔离文件系统挂载点对隔离文件系统提供支持。共享挂载</li>
<li>network namespace <ol>
<li>网络设备</li>
<li>IPv4</li>
<li>IPv6</li>
<li>IP路由器</li>
<li>防火墙</li>
<li>/proc/net目录</li>
<li>/sys/class/net目录</li>
<li>套接字</li>
</ol>
</li>
<li>user namespace:隔离了安全相关的标识符和属性，包括用户ID,用户组ID,root目录,key以及特殊权限。<ol>
<li>一个物理的网络设备最多存在于一个network namespace中，可以通过创建veth pair(虚拟网络设备对：有两端，类似于管道，如果数据从一段传入另一端也能接收到，反之亦然) </li>
<li>在不同的network namespace间创建通道</li>
<li>一般情况下，物理网络设备都分配在最初的root namespace中。如果有多块物理网卡，可以把其中一块或者多块分配给新创建network namespace。</li>
<li>当新创建的network namespace被释放时，就会返回root namespace。而把网络独立出来，给外部用户一种透明的感觉，彷佛在与一个独立网络实体进行通信。</li>
<li>为了达到该目的，容器的经典的做法就是创建一个veth pair,一端放置在新的namespace中，命名位eth0,一端放在原先的namespace中连接物理网络设备，再通过把多个设备接入网桥或者进行路由转发，来实现通信的目的。</li>
<li>在建立起veth pair之前，通过管道与新旧namespace进行通信。在docker deamon启动容器的，假设容器初始化的进程称为init。Docker deamon在主机上负责创建这个veth pair,把一端绑定到docker0网桥上，另一端接入新建的network space进程中。这个过程执行期间，Docker deamon和init就通过pipe进行通信。具体来说，Docker deamon完成veth pair的创建之前，init的管道的另一端循环等待，直到管道另一端传来docker deamon关于veth设备的信息，并关闭管道。init才结束等待的过程，并把它eth0启动起来。</li>
</ol>
</li>
<li>user namespaces</li>
</ol>
</li>
<li><p>cgroup资源限制</p>
<ol>
<li>限制资源，为资源设置权重，计算使用量，操控任务启停。</li>
<li>cgroups是linux内核提供的一种机制，这种机制可以根据需求把一些列系统任务以及子任务整合到按资源划分等级的不同组内，从而为系统资源管理提供一个统一框架。</li>
<li>cgroups可以限制，记录任务组所使用的物理资源（CPU,memory,IO），为容器实现虚拟化提供了基本保证，是构建Docker等一些列虚拟化管理工具的基石。</li>
<li>cgroups的4个特点：<ol>
<li>cgroups的API以一个伪文件系统的方式实现，用户态的程序可以通过文件操作实现cgroups的组织管理；</li>
<li>cgroups的组织管理操作单元可以细粒度到线程级别，另外用户可以创建和销毁cgroups，从而实现资源再分配和管理；</li>
<li>所有资源管理的功能都以子系统的方式实现，接口统一；</li>
<li>子任务创建之初与父任务处于同一个cgroups的控制组。</li>
</ol>
</li>
<li>本质上来说，cgroups是内核附加在程序上的一系列钩子，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。</li>
<li>cgroups的作用<ol>
<li>目的是：为不同用户层面的资源管理，提供一个统一化接口。从单个任务的资源控制到操作系统层面的虚拟化，cgroups提供四大功能：</li>
<li>资源限制：对任务使用的资源总额进行限制，设定应用运行时使用内存上限，超过额度就发出OOM；</li>
<li>优先级分配：通过分配CPU时间片数量及磁盘IO带宽大小，实际是控制任务的优先级；</li>
<li>资源统计：统计系统的资源使用量，如CPU使用时长，内存用量等；</li>
<li>任务控制：对任务执行挂起，恢复等操作。</li>
</ol>
</li>
<li>cgroups术语表<ol>
<li>task</li>
<li>cgroup</li>
<li>subsystem</li>
<li>hierarchy</li>
</ol>
</li>
<li>组织结构与基本规则<ol>
<li>传统任务管理，实际上是先启动init任务作为根节点，再由init节点创建子任务作为子节点，而子节点又可以创建新的子节点。</li>
</ol>
</li>
</ol>
</li>
<li>docker架构概览<ol>
<li>使用传统的client-server架构模式，用户通过docker client与docker daemon建立通信，并将请求发送给后者。</li>
<li>APIServer用于接收来自docker client的请求后，根据不同的请求分发给docker daemon的不同模块执行相应的工作。</li>
<li>docker通过driver模块来实现对docker容器执行环境的定制。</li>
<li>当需要创建docker容器，可以从docker registry中下载镜像，并通过镜像管理graphdriver将下载的镜像以graph形式存储在本地；</li>
<li>当需要为Docker容器创建网络环境时，则通过网络管理驱动networkdriver创建并配置execdriver来完成。</li>
<li>libcontainer是一个独立的容器管理包，networkdriver和execdriver都通过libcontainer来实现对容器的具体操作，利用uts,ipc,pid,network,mount,user等namespace实现容器之间的资源隔离和利用cgroup实现对容器的资源限制。</li>
<li>当运行容器的命令执行完毕后，该容器就具有独立的文件系统，安全且相互隔离的运行环境。</li>
</ol>
</li>
<li>模块介绍<ol>
<li>docker daemon <ol>
<li>响应来自docker client的请求，然后将这些请求翻译成系统调用完成容器管理操作；</li>
<li>该进程会在后台启动一个API server,负责接收Docker client发送的请求；</li>
<li>接收到的请求将通过docker daemon内部的一个路由分发调度，再由具体的函数来执行请求。</li>
</ol>
</li>
<li>docker client <ol>
<li>用来向指定的docker daemon发起请求，执行相应的容器管理操作。</li>
<li>可以是docker命令行工具，也可以是任何遵循docker api的客户端。</li>
<li>graph组件负责维护已下载的镜像信息以及他们之间的关系，大部分docker相关的操作会有graph组件来完成。</li>
<li>graph通过镜像层和每层的元数据来记录这些镜像的信息，用户发起的镜像管理操作最终都转换成了graph对这些层和元数据的操作。</li>
</ol>
</li>
<li>graphdb<ol>
<li>通过graphdb记录它所维护的所有容器节点以及他们之间的link关系，用一个图结构来及逆行保存。</li>
<li>Graph是一个基于SQLite的最简单版本的图形数据库，能够为调用者提供节点增删遍历连接所有父子节点的查询；</li>
<li>这些节点对应的就是一个容器，而节点间的边就是docker link关系。</li>
<li>每创建一个容器，就会再graphdb里添加一个几点，而当我们为某个容器设置了link操作后，就会创建一个父子关系，即一条边。</li>
</ol>
</li>
<li>driver<ol>
<li>docker daemon负责将用户请求转化成系统调用，进而创建和管理容器的核心进程。为了将这些系统调用抽象成统一的操作接口方便调用者使用，docker把这些操作分类成容器管理驱动，网络管理驱动，文件存储驱动3种。分别对应execdriver,networkdriver和graphdriver。</li>
<li>execdriver是对Linux操作系统的namespace,cgroups,apparmor,SELinux等容器运行所需的系统操作进行一层二次封装，其本质作用类似于LXC,功能更全面。</li>
<li>networkDriver是对容器网络环境进行封装，对于容器来说，网络设备比较独立，并且允许用户进行更多配置。分配通信所需的ip,服务访问的端口和容器与宿主机之间的端口映射，设置hosts,resolv.conf,iptables等。</li>
<li>graphdriver是所有与容器镜像相关操作的最终执行者。graphdriver会在docker工作目录下维护一组与镜像层对应的目录，并记下容器和镜像之间关系等元数据。用户对镜像的操作最终会被映射成这些目录文件以及元数据的增删查改，从而屏蔽掉不同文件存储实现对于上层调用者的影响。 </li>
</ol>
</li>
<li>client和daemon</li>
<li>libcontainer</li>
</ol>
</li>
<li>docker镜像管理<ol>
<li>bootfs:底层引导文件系统，包括bootloader和操作系统内核，类似于linux引导文件系统。</li>
<li>rootfs:包含了一个操作系统运行所需的文件系统，如目录系统，配置，工具。<ol>
<li>传统的Linux操作系统内核启动时，首先时挂载一个只读的rootfs,当系统检测其完整性之后，再将其切换为读写模式。</li>
<li>在docker daemon为docker容器挂载rootfs时，将其设为只读模式。</li>
<li>在挂载完毕后，利用联合挂载技术在已有只读rootfs上再挂载一个读写层。</li>
<li>可读写层处于docker容器文件系统的最顶层，其下可能联合挂载多个只读层，只有docker容器运行过程中文件系统发生变化时，才会把变化的文件内容写到可读写层，并隐藏只读层种的老版本文件，这技术称为写时复制。</li>
<li>联合挂载技术:在一个挂载点同时挂载多个文件系统，将挂载点的原目录与被挂载内容进行整合，使得最终可见的文件系统将会包含整合之后的各层文件和目录。</li>
<li>实现这种联合挂载技术的文件系统同城称为联合文件系统（UNFS）;</li>
<li>当需要修改镜像内的某个文件时，只对处于文件上方的读写层进行变动，不覆盖下层已有文件系统的内容，已有文件在只读层中的原始版本依然存在，但会被读写层中的新版本文件所隐藏，当docker commit这个修改过的容器文件系统为一个新的镜像时，保存内容仅为最上层读写文件系统中被更新过的文件。</li>
</ol>
</li>
<li>docker镜像相关的概念<ol>
<li>registry</li>
<li>repository</li>
<li>index</li>
<li>graph</li>
<li>dockerfile            </li>
</ol>
</li>
</ol>
</li>
<li>Docker存储驱动<ol>
<li>存储驱动根据操作系统底层的支持提供了针对某种文件系统的初始化操作以及对镜像层的增删改查和差异比较等操作。</li>
<li>映射设备，映射表和目标设备。</li>
</ol>
</li>
<li>docker数据卷<ol>
<li>读时复制的缺点    <ol>
<li>容器中的文件在宿主机上存在形式复杂，不能在宿主机上很方便地对容器中的文件进行访问。</li>
<li>多个容器之间数据无法共享。</li>
<li>当删除容器时，容器产生的数据将丢失。</li>
</ol>
</li>
<li>引入数据卷机制。<ol>
<li>存在于一个或多个容器中的特定文件或文件夹，这个目录能够独立于联合文件系统的形式在宿主机中存在，并为数据的共享与持久化提供便利。</li>
<li>volume在创建时就会初始化，在容器运行时可以使用其中的文件。</li>
<li>在不同的容器之间共享和重用。</li>
<li>数据的操作不会影镜像本身。</li>
<li>生存周期独立于容器生存周期，即使删除容器，v仍会存在。  </li>
</ol>
</li>
<li>数据卷原理<ol>
<li>本质是容器中的一个特殊目录。在容器的创建过程中，这个挂载点会被挂载到一个宿主机上的指定目录，这个挂载彷佛是绑定挂载。 </li>
<li>创建volume:不论用户使用何种方式创建或运行一个待volume的容器，volume的来源只有3种，从容器挂载，从宿主机挂载和从其他容器共享。docker daemon首先需要根据用户指定的volume类型，判断并新建出对应的mount对象。daemon针对mount对象执行如下操作：<ol>
<li>解析参数并生存Mount列表，每一个Mount描述一个volume和容器的对应关系或是一个容器与其它容器共享volume的情况。</li>
<li>初始化所有的Mount,这一过程在创建容器时执行，即在宿主机和容器文件目录下创建上述Mount对象种所需的路径。</li>
<li>将Mount对象传递给libcontainer，按照Mount对象中指定的路由，mount参数，读写标志执行所有的mount操作，完成从宿主机到容器内挂载点的映射</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>docker网络管理<ol>
<li>服务虚拟化，存储虚拟化，网络虚拟化</li>
<li>docker网络基础<ol>
<li>docker0网桥<ol>
<li>这台多的网卡会在内核路由表上添加一条达到相应网络的静态路由。eth0是容器与外界通信的网卡。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/docker/">docker</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/10/08/docker系列深入篇/" title="docker系列深入篇" itemprop="url">docker系列深入篇</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-10-08T11:00:51.000Z" itemprop="datePublished"> Published 2018-10-08</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-数据卷"><a href="#1-数据卷" class="headerlink" title="1. 数据卷"></a>1. 数据卷</h2><ol>
<li>网络通信和文件读写</li>
<li>数据卷用于存储文件数据的特殊模块</li>
<li>数据卷：一个挂载在容器内文件系统中的文件或目录。</li>
<li>使用docker create或者docker run创建容器时，可以通过-v参数向容器中挂载一个数据卷。</li>
<li>使用docker rm -v /path删除数据卷<h2 id="2-网络"><a href="#2-网络" class="headerlink" title="2. 网络"></a>2. 网络</h2><h2 id="3-制作镜像"><a href="#3-制作镜像" class="headerlink" title="3. 制作镜像"></a>3. 制作镜像</h2><h2 id="4-网络进阶"><a href="#4-网络进阶" class="headerlink" title="4. 网络进阶"></a>4. 网络进阶</h2></li>
<li>Network Namespaces<ol>
<li>docker的容器技术是基于Linux Kernel提供的Linux Container。在Linux Container中，包含了能够隔离程序进程的Namespaces，在Namespaces技术里，存在一个用于隔离程序对网络信息调用的子模块—Network Namespaces。</li>
<li>每个被NetWork Namespaces隔离的空间都拥有自己的网络设备，ip地址，录用表，防火墙，端口表等。     </li>
</ol>
</li>
<li>Veth Pair<ol>
<li>一个虚拟的网络通道，将通道一段的数据传输到另外一段。实现了容器所隔离的网络环境与容器外部的网络通信。</li>
<li>Veth Pair提供两个端点，只能连接某两个网络终端。</li>
</ol>
</li>
<li>Linux Bridge把Veth Pair的一端都连接到宿主机中某个网桥所构成的交换机中，把容器连接不同的外部网络的任务由Veth Pair转移到网桥上。</li>
<li>Iptables<ol>
<li>用于管理网络过滤的程序，能够根据指定的规则，对位于Linux内核中的netfilter进行操作，实现对网络信息包的过滤功能。</li>
<li>利用Iptables可以实现端口的映射，让宿主机外部访问到容器的端口是通过端口映射来实现。<br>5.Docker网络主要由Network Namespaces,Veth Pair,Linux Bridge,Iptables等技术实现。</li>
<li>Network Namespaces:实现了网络资源隔离，对隔离环境提供了网络设备，协议栈，路由表，防火墙，/proc/net目录，/sys/class/net目录，端口表等网络配置。</li>
<li>Veth Pair:实现了打穿隔离环境的网络传输数据通道。在Docker中，它的一段连接到容器的虚拟网卡上，另一端连接到宿主机专用的网桥上，通过这种方式实现了Docker容器与外部网络的互通。</li>
<li>linux bridge:在置在宿主机中的网桥，起到网络交换机的作用。容器网络通过Veth Pair连接到网桥，能够在容器间转发网络数据。</li>
<li>Iptables:  用于提供网络数据透传，NAT功能，实现docker网络防火墙等网络安全防护的需求。<br>6.网络模型</li>
<li>CNM Container Network Model<ol>
<li>Sandbox 网络沙盒 </li>
<li>Endpoint 端点</li>
<li>NetWork 网络</li>
</ol>
</li>
<li>docker中的网络<ol>
<li>默认网络   </li>
<li>自定义网络</li>
<li>容器与外部通信</li>
</ol>
</li>
<li>网络实践<ol>
<li>管理容器网络</li>
<li>容器连接网络</li>
<li>配置docker0网桥</li>
<li>自定义网桥</li>
<li>配置DNS</li>
<li>使用IPV6<h2 id="5-安全"><a href="#5-安全" class="headerlink" title="5.安全"></a>5.安全</h2></li>
</ol>
</li>
</ol>
</li>
<li>命名空间隔离<ol>
<li>仅仅让不同的命名空间独立享有进程信息，网络信息等。</li>
</ol>
</li>
<li>资源控制组    <ol>
<li>主要功能是CPU,内存,硬盘IO等程序访问的计算机资源进行控制。</li>
<li>docker中，每个容器都拥有一个独立的控制组策略集，用来控制容器中每个程序对计算机资源的访问和调用。</li>
<li>通过控制组:<ol>
<li>资源限制</li>
<li>优先化</li>
<li>用量报告</li>
</ol>
</li>
</ol>
</li>
<li>内核能力机制     </li>
<li>资源使用限制                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/docker/">docker</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/29/Netty系列之netty体系和概念/" title="Netty系列之netty体系和概念" itemprop="url">Netty系列之netty体系和概念</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-29T07:09:05.000Z" itemprop="datePublished"> Published 2018-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/29/k8s系列之k8s核心原理/" title="k8s系列之k8s核心原理" itemprop="url">k8s系列之k8s核心原理</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-29T06:22:49.000Z" itemprop="datePublished"> Published 2018-09-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="第2章-Kubernetes核心原理"><a href="#第2章-Kubernetes核心原理" class="headerlink" title="第2章 Kubernetes核心原理"></a>第2章 Kubernetes核心原理</h2><h3 id="1-Kubernetes-API-Server分析"><a href="#1-Kubernetes-API-Server分析" class="headerlink" title="1.Kubernetes API Server分析"></a>1.Kubernetes API Server分析</h3><ol>
<li>功能和地位    </li>
</ol>
<ul>
<li>提供了集群管理的API接口；</li>
<li>成为集群内各个功能模块之间数据交互和通信的中心枢纽；</li>
<li>拥有完备的集群安全机制。</li>
</ul>
<ol start="2">
<li>如何访问K8S API<ol>
<li>K8S API通过K8S apiserver进程提供服务，运行于master节点。该进程有2个端口：<ol>
<li>本地端口<ol>
<li>该端口用于接收Http请求；</li>
<li>默认值为8080，可以通过修改–insecure-port值来修改默认值。</li>
<li>默认ip地址是localhost,通过修改–insecure-bing-address的值来修改该IP地址；</li>
<li>非认证或授权的Http请求通过该端口访问API Server。</li>
</ol>
</li>
<li>安全端口</li>
</ol>
</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/k8s/">k8s</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/27/k8s系列之入门/" title="k8s系列之入门" itemprop="url">k8s系列之入门</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-27T08:02:12.000Z" itemprop="datePublished"> Published 2018-09-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h1 id="第一章-Kubernetes入门"><a href="#第一章-Kubernetes入门" class="headerlink" title="第一章 Kubernetes入门"></a>第一章 Kubernetes入门</h1><ol>
<li>K8S是什么<ol>
<li>大规模集群管理系统，基于容器技术，实现资源管理的自动化，以及跨多个数据中心得资源利用率最大化。</li>
<li>TCP通信协议进行交互。</li>
<li>完备得分布式系统支撑平台，具有完备得集群管理能力，多层次得安全防护和准入机制，多租户应用支撑能力，透明的服务注册和服务发现机制，内建智能负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力，可扩展的资源自动调度机制，多粒度的资源配额管理能力，完善的管理工具，如开发，部署测试，运维监控等各个环节。</li>
</ol>
</li>
<li>K8S基础<ol>
<li>Service是分布式集群架构的核心，一个Service对象拥有如下关键特征：<ol>
<li>拥有一个唯一指定的名字；</li>
<li>拥有一个虚拟ip和端口号；</li>
<li>能够提供某种远程服务能力；</li>
<li>被映射到了提供这种服务能力的一组容器应用上。</li>
</ol>
</li>
<li>Service的服务进程目前都基于Socket通信方式对外提供服务，如redis,Memcache,MySql,WebServer,或者一个特定的TCP server进程。Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的IP+PORT访问点，从来连接到指定的Service上。</li>
<li>强大的隔离功能，K8S设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器。为了建立Service和Pod间的关联关系，K8S给Pod贴上一个Label，给运行MySQL的Pod贴上name=mysql标签。</li>
<li>Pod在节点中运行，节点可以是物理机，可以是云中的一个虚拟机，每个Pod里面运行着一个特殊的Pause容器，其他容器运行业务容器，这些业务容器工厂Pause容器的网络栈和Volume挂载卷，因而通信和数据交换更为高效。因此密切相关的服务进程放入同一个Pod中。</li>
<li>集群管理:将集群中机器划分为一个Master节点和一群工作节点，Master上运行着集群管理相关的一组进程kube-apiserver,kube-controller-manager和kube-scheduler,这些进程实现了整个集群资源管理，Pod调度，弹性伸缩，安全控制，系统监控和纠错等管理功能，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的APP,在Node上K8S管理的最小运行单元式Pod。Node上运行着Kubelet,kube-proxy服务进程，这些服务进程负责Pod的创建，启动监控，重启销毁以及软件模式的负载均衡。</li>
</ol>
</li>
<li>使用K8S的原因<ol>
<li>IT从来都是技术驱动的。</li>
<li>简化团队，架构师专注于系统服务组件的提炼，开发专注于业务代码，运维负责K8S的部署和运维。</li>
<li>全面拥抱微服务，微服务架构的核心是将一个巨大的单体应用分解维很多小的相互连接的微服务，一个微服务背后有多个实例副本在支撑，副本数量随着系统的负荷变化而进行调整，内嵌的负载均衡器在这里发挥重要作用。</li>
<li>很方便的搬迁到公有云上。</li>
<li>超强的横向扩容能力。<br>4.K8S基本概念和术语</li>
<li>Node—相对于master而言的的工作主机。每个node上运行用于启动和管理的Pod服务-Kubelet，并能够被Master管理。在node上运行的是服务进程包括Kubelet,Kube-proxy,docker deamon。</li>
<li>Node的信息:<ol>
<li>Node地址：主机Ip地址+NodeID</li>
<li>Node运行状态:Pending,Running,Terminated三种状态</li>
<li>Node Condition(条件):描述Running状态Node的运行条件，Read—健康状态，可以接收从Master发来的创建Pod指令。</li>
<li>Node系统容量:描述Node可用的系统资源，包括CPU,内存数量，最大可调度Pod数量等。</li>
<li>其他:内核版本，K8S版本，docker版本，操作系统名称。</li>
</ol>
</li>
<li>Pod<ol>
<li>最基本的操作单元，包含一个或多个紧密相关的容器。是被容器化的环境看作应用层的逻辑宿主机，一个Pod中的多个容器应用是紧耦合的。Pod在node上被创建，启动或者销毁。</li>
<li>在Pod上封装Node的原因:Docker容器之间的通信收到Docker网络机制的限制，只能通过Link方式才能访问另一个容器提供的服务。大量容器之间的Link是一种重量级连接。通过Pod将多个容器组合在一个虚拟的主机内，可以通过Localhost就能通信。</li>
<li>一个Pod中的应用容器共享同一组资源：<ol>
<li>PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID;</li>
<li>网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围；</li>
<li>IPC命名空间：Pod中的多个容器能够使用SystemV IPC或者POSIX消息队列进行通信；</li>
<li>UTS命名空间：Pod中的多个容器共享一个主机名；</li>
<li>Volumes（共享存储卷）:pod中的各个容器可以访问在Pod级别定义的Volumes。</li>
</ol>
</li>
<li>Pod定义通过Yml或者json格式配置文件来完成。</li>
<li>Pod的生命周期是通过Replication Controller来管理的。Pod的生命周期过程包括:在模板进行定义，然后分到Node上运行，在Pod所含容器运行结束后Pod也结束。在整个过程中，Pod处于一下4种状态之一：<ol>
<li>Pending:Pod定义正确，提交Master，但其包含的容器镜像还未完全创建。通常Master对Pod进行调度需要一些时间，之后Node对镜像进行下载也需要一些时间。</li>
<li>Running:Pod已被分配到某个Node上，但其包含的所有容器镜像都已经创建完成，并成功运行起来。</li>
<li>Suceeded:Pod中所有所有容器都成功结束，并且不会重启，这是Pod最终状态。</li>
<li>Failed:Pod中所有容器都结束了，但至少一个容器以失败状态结束的，这是Pod的一种最终状态。</li>
</ol>
</li>
</ol>
</li>
<li>Label(标签)<ol>
<li>Label以key/value键值对的形式附加到各种对象上，如Pod,Service,RC,Node等。Label定义了这些对象的可识别属性，用来对它们进行管理和选择。Label可以在创建对象时附加到对象上，也可以在对象创建后通过API进行管理。</li>
<li>在为对象定义好Label后，其他对象就可以使用Label Selector选择器来定义其作用的对象。<br> “Labels”:{<pre><code>&quot;key1&quot;:&quot;value1&quot;,
&quot;key2&quot;:&quot;value2&quot;
</code></pre> }    </li>
<li>Label Selector时，看作SQL查询语句种的where查询条件的语法。<br>5.Replication Controller(RC)</li>
<li>用于定义Pod副本的数量。在Master内，Controller Manager进行通过RC的定义来完成Pod的创建，监控，启停等操作。</li>
</ol>
</li>
<li>Service<ol>
<li>Pod都会分配一个单独的IP地址，但是会随着Pod的销毁而消失。如果一组Pod组成一个集群来提供服务，如何访问；</li>
<li>一个Service可以看作一组提供相同服务的Pod对外访问接口。Service作用于那些Pod是通过Label Selector来定义的。</li>
<li>Pod的IP地址和Service的Cluster的IP地址<ol>
<li>Pod的IP地址是Docker Daemon根据docker0网桥的IP地址段进行分配的，但是Service的ClusterIP地址是K8s系统种的虚拟IP地址，由系统动态分配。service的ClusterIP地址相对于Pod的IP地址来说相对稳定，Service被创建时被分配一个IP地址，销毁该Service之前，这个IP地址都不会再变化了。Pod在K8S集群中生命周期较短，ReplicationController销毁，再次创建，会分配一个新的IP地址。</li>
</ol>
</li>
<li>外部访问Service<ol>
<li>Service对象在ClusterIPRange池中分配的IP只能在内部访问，所以其他Pod都可以无障碍地访问到它。如果这个Service作为前端服务，准备为集群外的客户端提供服务，就需要分配公共IP;</li>
<li>K8S支持两种对外提供服务的Service的type定义:NodePort和LoadBalancer</li>
<li>NodePort</li>
<li>LoadBalancer</li>
</ol>
</li>
</ol>
</li>
<li>Volume(存储卷)<ol>
<li>Volume是Pod中能够被多个容器访问的共享目录。K8S的Volume概念与Docker的Volume比较类似。</li>
<li>Volume类型<ol>
<li>EmptyDir:一个EmptyDir Volume是在Pod分配到Node时创建得。从它的名称就可以看出，初始为空。同一个Pod中所有容器可以读些EmptyDir中得相同文件。当Pod从Node上移除时，EmptyDir中得数据也会永久被删除。<ol>
<li>用途:临时空间，例如用于某些应用程序运行时所需得临时目录，且无须永久保留。长时间任务的中间过程CheckPoint临时保存目录。一个容器需要从另一个容器中获取数据的目录。</li>
<li>tmpfs</li>
</ol>
</li>
<li>hostPath:在Pod上挂载宿主机上的文件或目录。<ol>
<li>容器应用程序生成的日志文件需要永久保存</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Namespace<ol>
<li>Namespace是k8s系统中另一个非常重要的概念，通过将系统内部的对象分配到不同的Namespace中，形成逻辑上分组的不同项目，小组，用户组，便于不同的分组在共享使用整个集群的同时还能被分别管理。</li>
</ol>
</li>
<li>Annotation</li>
</ol>
</li>
<li>K8S总体架构<ol>
<li>k8s集群由两类节点组成:Master和Node,Master上运行etcd,API Server,Controller Manager和Scheduler四个组件，后三个组件构成了K8S的总控中心，负责对集群中所有资源进行管控和调度。</li>
<li>在每个Node上运行Kubelet,Proxy和Docker Daemon三个组件，负责对本节点上的Pod的生命周期进行管理，以实现服务代理的功能。</li>
<li>所有节点上都可以运行Kubectl命令行工具，提供了K8S的集群管理工具集。</li>
<li>etcd是高可用的key/value存储系统，用于持久化存储集群中所有的资源对象，如Node,Service,Pod,RC,Namespace等。API Server则提供了操作etcd的封装接口API，以Rest方式提供服务，这些API基本上都是集群中资源对象的增删改查及监听资源变化的接口，如创建Pod,创建RC,监听Pod的变化等接口。API Server是连接其他所有服务组件的枢纽。</li>
<li>RC与相关Service创建完整流程<ol>
<li>通过Kubectl提交一个创建RC的请求，该请求通过APIServer被写入etcd;</li>
<li>此时Controller Manager通过API Server的监听资源变化的接口监听到这个RC事件，分析之后，发现当前集群中没有Pod实例。</li>
<li>于是根据RC的Pod模板定义生成一个Pod对象，通过API Server写入etcd中，接下来此事件被Scheduler发现，执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，这个过程称为绑定（Pod Binding）。</li>
<li>通过API Server将这一结果写入到etcd中，随后目标Node上运行的Kubelet进程通过API Server检测到这个新生的Pod并按照定义，启动改Pod并负责其下半生，直到Pod的生命走到尽头。</li>
<li>通过Kubetcl提交一个映射到该Pod的Service的创建请求，Controller Manager会通过Label标签查询到相关联的Pod实例，然后生成Service的EndPoints信息并通过API Server写入到etcd中。</li>
<li>接下来所有Node上运行的Proxy进程通过API Server查询并监听Service对象与其对应的Endpoints信息，建立一个软件方式负载均衡器来实现service访问到后端Pod的流量转发功能。</li>
</ol>
</li>
<li>组件的功能<ol>
<li>API Server:提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，通过相关的资源数据”全量查询”+”变化监听”，这些组件可以实时地完成相关业务功能，如某个新的Pod一旦被提交到API Server中，C M就会立即发现并开始调度。</li>
<li>Controller Manager:集群内部的管理控制中心，其主要目的是实现K8S集群自动检测和恢复的自动化工作，比如根据RC的定义完成Pod的复制或移除，以确保Pod实例数符合RC副本的定义；根据Service与Pod的管理关系，完成服务的EndPoints对象的创建和更新；其他诸如Node的发现，管理和状态监控，死亡容器所占磁盘空间及本地缓存的镜像文件的清理工作也是由Controller Manager完成的。</li>
<li>Scheduler:集群的调度器，负责Pod在集群节点中的调度分配。</li>
<li>Kubelet:负责本Node节点上的Pod创建，修改，监控，删除等全生命周期管理，同事Kubelet定时上报本节点的状态信息到API Server里。</li>
<li>Proxy:实现了Service的代理及软件模式的负载均衡器。</li>
<li>客户端通过Kubectl命令行工具或Kubetcl Proxy来访问K8S系统，在K8S集群内部的客户端可以直接使用Kubetcl命令管理集群。Kubectl Proxy是APIServer的一个反向代理，在K8s集群外部的客户端可以通过Kubectl Proxy来访问API Server。</li>
<li>API Server内部有一套完备的安全机制，包括认证，授权，以及准入控制等相关模块，APIServer在收到Rest请求后，会首先执行认证授权和准入控制的相关逻辑，过滤掉非法请求，然后将请求发送给API Server中的REST服务模块去执行资源的具体操作逻辑。</li>
<li>Node节点运行的K8S服务内嵌了一个cAdvisor服务，用于实时监控Docker上运行的容器指标。</li>
</ol>
</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/k8s/">k8s</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/25/设计模式系列之设计模式基础/" title="设计模式系列之设计模式基础" itemprop="url">设计模式系列之设计模式基础</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-25T12:05:09.000Z" itemprop="datePublished"> Published 2018-09-25</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h2><pre><code>在软件开发中，经过验证的，用于解决特定环境下，重复出现的、特定问题的解决方案。
</code></pre><p><strong>看完后思考，思考后应用，然后再看，再思考，再应用。</strong></p>
<h2 id="2-常见设计模式"><a href="#2-常见设计模式" class="headerlink" title="2.常见设计模式"></a>2.常见设计模式</h2><ol>
<li>简单工厂</li>
<li>外观模式</li>
<li>适配器模式</li>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>抽象工厂模式</li>
<li>生成器模式</li>
<li>原型模式</li>
<li>中介者模式</li>
<li>代理模式</li>
<li>观察者模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>组合模式</li>
<li>模板方法模式</li>
<li>策略模式</li>
<li>状态模式</li>
<li>备忘录模式</li>
<li>亨元模式</li>
<li>解释器模式</li>
<li>装饰模式</li>
<li>职责链模式</li>
<li>桥接模式</li>
<li>访问者模式</li>
</ol>
<p>##3. 讲述结构  ##</p>
<ol>
<li>场景问题<ol>
<li>某个实际应用</li>
<li>不用模式的解决方案</li>
<li>存在问题</li>
</ol>
</li>
<li>解决方案<ol>
<li>某个模式来解决</li>
<li>模式结构和说明</li>
<li>模式的实例代码</li>
<li>使用模式来重写示例</li>
</ol>
</li>
<li>模式讲解<ol>
<li>认识某个模式</li>
<li>针对各个重点难点功能，实际应用结合的讨论和示例</li>
<li>模式的优缺点</li>
<li>思考模式</li>
<li>相关模式</li>
</ol>
</li>
</ol>
<p>++++++============================++++++++</p>
<h2 id="第二章-简单工厂"><a href="#第二章-简单工厂" class="headerlink" title="第二章 简单工厂"></a>第二章 简单工厂</h2><p>-相关：单例，原型，生成器模式</p>
<h3 id="1-场景问题"><a href="#1-场景问题" class="headerlink" title="1. 场景问题"></a>1. 场景问题</h3><pre><code>1. 接口回顾
2. 接口用处
3. 接口思想
4. 接口好处
5. 接口和抽象类
    1. 优先使用接口
    2. 既要定义子类的行为，又要具有公共的功能时使用抽象类
</code></pre><h3 id="2-面向接口编程"><a href="#2-面向接口编程" class="headerlink" title="2.面向接口编程"></a>2.面向接口编程</h3><p>1.分层<br>    表现层 逻辑层 数据层<br>2.接口是被其隔离部分的外观:通过接口来进行交互<br>3.组件:能完成一定功能得封装体。小到一个类，大到一个系统，都可以称为组件，一个小的系统放到更大的系统里面去，就是充当一个组件的作用。系统，子系统，模块，组件是一个概念，都是一定功能的封装体。</p>
<h3 id="3-不同模式的解决方案"><a href="#3-不同模式的解决方案" class="headerlink" title="3.不同模式的解决方案"></a>3.不同模式的解决方案</h3><ol>
<li>定义一个API，然后一个实现类Impl，客户端调用这个接口的实例。</li>
<li>客户端只知道接口，不知道实现。<h3 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h3></li>
<li>简单工厂：提供一个创建对象实例的功能，无须关心具体实现。被创建实例的类型可以是接口，抽象类，也可以是具体的类。</li>
<li>应用简单工厂来解决问题的思路:在内部新建一个类，在里面来创建接口，然后把创建好的接口返回给客户端，外部应用通过这个类就获取相应的接口，然后就可以操作相应的方法，这个对象就叫做简单工厂。</li>
<li>可配置的简单工厂<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h3></li>
<li>简单工厂的优点<ol>
<li>帮助封装</li>
<li>解耦</li>
</ol>
</li>
<li>缺点<ol>
<li>增加客户端的复杂度</li>
<li>不方便扩展子工厂<h3 id="6-思考简单工厂"><a href="#6-思考简单工厂" class="headerlink" title="6.思考简单工厂"></a>6.思考简单工厂</h3></li>
</ol>
</li>
<li>本质:选择实现，重点是实现已经做好了，就算实现简单，也要有具体的实现类。</li>
<li>何时选用简单工厂:完全封装隔离具体实现，让外部只能通过接口来操作封装体。如果想要把创建对象的职责集中管理和控制，选用简单工厂。</li>
</ol>
<p>==================++++++++++++++++++++++=====================</p>
<h2 id="第三章-外观模式-Facade"><a href="#第三章-外观模式-Facade" class="headerlink" title="第三章. 外观模式(Facade)"></a>第三章. 外观模式(Facade)</h2><ol>
<li>解决方案<ol>
<li>界面和接口：为子系统种的一组接口提供一个一直的界面，Facade模式定义了一个高层接口，接口使得这一子系统更加容易使用。</li>
<li>界面—&gt;组件</li>
<li>外观模式就是通过引入这么一个外观类，在这个类里面定义客户端想想要的方法，然后在这些方法的实现里面，由外观类再去分别调用内部的多个模块来实现功能，从而让客户端变得简单。</li>
</ol>
</li>
<li>结构和说明<ol>
<li>Facade:定义子系统的多个模块对外高层接口，通常需要调用内部多个模块，从而把客户端的请求代理给适当的子系统对象。 </li>
<li>模块:接受Facade对象的委派，真正实现功能，各个模块之间会有交互<br>3.理解</li>
<li>目的:不是为了让外部减少与子系统内多个模块的交互，松散耦合，让外不能更简单地使用子系统。</li>
<li>方便客户端调用，封装了系统的内部细节功能。功能的复用。减少了学习成本。</li>
<li>外观模式可以实现成为一个单例，接口。</li>
</ol>
</li>
</ol>
<p>======================++++++++++++++++++++++++================</p>
<h2 id="第四章-适配器模式-Adapter"><a href="#第四章-适配器模式-Adapter" class="headerlink" title="第四章 适配器模式(Adapter)"></a>第四章 适配器模式(Adapter)</h2><ol>
<li>解决方案<ol>
<li>将一个类的接口转换成客户端希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>定义一个类来实现第二版接口，在实现的时候转调第一版的功能，这样通过<strong>对象组合</strong>的方式，复用第一版已有的功能，同时又满足第二版调用的要求。</li>
</ol>
</li>
</ol>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/设计模式/">设计模式</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/06/算法系列之源初/" title="算法系列之源初" itemprop="url">算法系列之源初</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-06T00:53:52.000Z" itemprop="datePublished"> Published 2018-09-06</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="3-基本算法思想"><a href="#3-基本算法思想" class="headerlink" title="3. 基本算法思想"></a>3. 基本算法思想</h2><ol>
<li>算法可以帮助用户清理问题的头像，更快地解决问题。</li>
<li>常用的算法：<ol>
<li>穷举</li>
<li>递推</li>
<li>递归</li>
<li>分治</li>
<li>概率<h3 id="3-1-穷举"><a href="#3-1-穷举" class="headerlink" title="3.1 穷举"></a>3.1 穷举</h3></li>
</ol>
</li>
<li>穷举基本思想===无规律场景 <ol>
<li>穷举的基本思想就是从所有可能的情况中搜索正确的答案，执行步骤：<ol>
<li>对于一种可能的结果，计算其结果；</li>
<li>判断结果是否满足要求，如果不满足继续执行（1）步来搜索下一个可能的情况；如果满足结果，则表示找到正确答案。</li>
</ol>
</li>
<li>使用穷举算法时，需要明确问题的答案范围，在指定范围内搜索答案。指定范围后，使用循环语句和条件判断语句逐步验证候选答案的正确性，从而得到正确答案</li>
</ol>
</li>
<li>实例<h3 id="3-2-递推"><a href="#3-2-递推" class="headerlink" title="3.2 递推"></a>3.2 递推</h3></li>
<li>递推基本思想===有规律场景<ol>
<li>理性思维的代表，根据已有数据和关系，逐步推导而得到结果。递推算法如下:<ol>
<li>根据已知结果和关系，求解中间结果。</li>
<li>判定是否达到要求，如果没达到，则根据已知结果和关系求解中间结果;如果满足要求则表示找到一个正确答案。<br>2.问题和答案的关系。</li>
</ol>
</li>
</ol>
</li>
<li>实例<ol>
<li>斐波那契算法<h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3></li>
</ol>
</li>
<li>递归基本思想<ol>
<li>递归算法就是在程序中不断反复调用自身来达到求解问题的方法。要求待求解的问题能够分解为相同问题的一个子问题。</li>
<li>递归调用是一个方法在其方法体内调用自身的方法调用方式。</li>
<li>分类：直接递归，间接递归</li>
<li>编写递归方法时，必须使用if语句强制方法在未执行递归调用前返回。否则永不返回。</li>
</ol>
</li>
<li>实例<h3 id="3-4-分治"><a href="#3-4-分治" class="headerlink" title="3.4 分治"></a>3.4 分治</h3></li>
<li>分治基本思想<ol>
<li>分支问题就是将计算复杂的问题分为规模较小，计算简单的小问题求解，然后综合各个小问题，而得到最终的答案。</li>
<li>过程:<ol>
<li>对于一个规模为N的问题，若该问题可以轻松解决，则直接解决；否则执行以下步骤。</li>
<li>将该问题分解为M个规模较小的自问题，这些子问题相互独立，并且与原问题形式相同。</li>
<li>递归地解这些自问题。</li>
<li>将子问题的解合并得到最终的答案。</li>
</ol>
</li>
</ol>
</li>
<li>实例:寻找假币<h3 id="3-5-概率"><a href="#3-5-概率" class="headerlink" title="3.5 概率"></a>3.5 概率</h3></li>
</ol>
<h2 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4. 排序算法"></a>4. 排序算法</h2><p> 排序算法概述</p>
<pre><code>1. 基本的交换排序，选择排序，插入排序，合并排序。
2. 交换排序:冒泡排序和快速排序
3. 选择排序:选择排序和堆排序
4. 插入排序
5. 多路归并排序
</code></pre><h3 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h3><p>核心代码:</p>
<pre><code>for(int i = 0;i&lt;arr.length;i++) 
{     
    for(int j = 0;j &lt;arr.length-i;j++) {
        if(arr[j] &gt; arr[j+1]) {
            int temp = arr[j];            
            arr[j] = arr[j+1];
            arr[j+1] = temp;            
        }
    }    
}
</code></pre><h3 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h3><ol>
<li>首先从原始数组中选择最小的1个数据，将其和位于第一个位置的数据交换；</li>
<li>接着从剩下的n-1个数据中选择次小的元素，将其和第2个位置数据交换；</li>
<li>不断重复直到最后两个数据完成交换。    </li>
<li>核心代码    </li>
</ol>
<pre><code>for(int i =0;i&lt;a.length-1;i++) {
    int    index = i;
    for(int j=i+1;j&lt;a.length;j++) {
        if(a[j] &lt; a[index]) {
            index = j;            
        }        
    }
    if(index != i) {

    }
} 
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


  <div class="article-tags">
  
  <span></span> <a href="/tags/算法/">算法</a>
  </div>

</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/09/04/Docker系列之入门介绍/" title="" itemprop="url"></a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="Rocky ZhouJin QQ987415811" target="_blank" itemprop="author">Rocky ZhouJin QQ987415811</a>
		
  <p class="article-time">
    <time datetime="2018-09-04T08:09:26.349Z" itemprop="datePublished"> Published 2018-09-04</time>
    
  </p>
</header>
    <div class="article-content">
        
        <hr>
<p>title: Docker系列之入门介绍<br>date: 2018-09-04 16:09:26<br>tags: Docker</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><pre><code>1. 镜像
2. 容器
3. 仓库 
</code></pre><h2 id="2-Docker镜像"><a href="#2-Docker镜像" class="headerlink" title="2.Docker镜像"></a>2.Docker镜像</h2><pre><code>1. 操作系统分为内核和用户空间。对于linux而言内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像，就相当于一个root文件系统。
2. 分层存储
</code></pre><h2 id="3-Docker容器"><a href="#3-Docker容器" class="headerlink" title="3.Docker容器"></a>3.Docker容器</h2><pre><code>1. 镜像和容器就像的类和实例。
2. 拉取镜像:docker pull [地址] [仓库名]
3. 启动容器:docker run --it --rm [地址+仓库名]
4. 列出镜像:docker images
</code></pre><h2 id="4-镜像"><a href="#4-镜像" class="headerlink" title="4.镜像"></a>4.镜像</h2><pre><code>1. 联合文件系统
2. 镜像分层结构
3. 镜像的写时复制
</code></pre><h2 id="5-镜像的命令"><a href="#5-镜像的命令" class="headerlink" title="5.镜像的命令"></a>5.镜像的命令</h2><pre><code>1. docker pull
2. docker search
3. docker images
4. docker inspect
5. docker rmi 
6. docker save 
7. docker load
</code></pre><h2 id="6-Docker-Hub简介"><a href="#6-Docker-Hub简介" class="headerlink" title="6.Docker Hub简介"></a>6.Docker Hub简介</h2><pre><code>1. 镜像仓库:docker login -u -p
2. 搭建仓库
</code></pre><h2 id="7-管理和使用容器"><a href="#7-管理和使用容器" class="headerlink" title="7.管理和使用容器"></a>7.管理和使用容器</h2><pre><code>1. docker create
2. docker run 
3. docker ps
4. docker daemon
5. docker start
6. docker stop
7. docker pause
8. docker unpause
9. docker rm
10. docker top
11. docker log
</code></pre>
        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/k8s/" title="k8s">k8s<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Sentinel/" title="Sentinel">Sentinel<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/docker/" title="docker">docker<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/消息队列/" title="消息队列">消息队列<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Druid-数据库连接池/" title="Druid 数据库连接池">Druid 数据库连接池<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/netty/" title="netty">netty<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Druid-SQL解析/" title="Druid SQL解析">Druid SQL解析<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SofaRPC/" title="SofaRPC">SofaRPC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringMVC/" title="SpringMVC">SpringMVC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringAOP/" title="SpringAOP">SpringAOP<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Spring/" title="Spring">Spring<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Zookeeper/" title="Zookeeper">Zookeeper<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Dubbo-SPI/" title="Dubbo SPI">Dubbo SPI<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Druid/" title="Druid">Druid<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/秒杀/" title="秒杀">秒杀<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/高并发/" title="高并发">高并发<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/nacos/" title="nacos">nacos<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/SpringCloud-微服务/" title="SpringCloud 微服务">SpringCloud 微服务<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/微服务设计读书笔记/" title="微服务设计读书笔记">微服务设计读书笔记<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/MySQL/" title="MySQL">MySQL<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://coderq.com" target="_blank" title="一个面向程序员交流分享的新一代社区">码农圈</a>
            
          </li>
        
          <li>
            
            	<a href="http://wuchong.me" target="_blank" title="Jark&#39;s Blog">Jark&#39;s Blog</a>
            
          </li>
        
    </ul>
</div>

  


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="weiboshow">
  <p class="asidetitle">Weibo</p>
    <iframe width="100%" height="119" class="share_self"  frameborder="0" scrolling="no" src="http://widget.weibo.com/weiboshow/index.php?language=&width=0&height=119&fansRow=2&ptype=1&speed=0&skin=9&isTitle=1&noborder=1&isWeibo=0&isFans=0&uid=&verifier=b3593ceb&dpc=1"></iframe>
</div>


</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Hello ,I&#39;m Larry Page in Google. <br/>
			This is my blog,believe it or not.</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		<a href="http://weibo.com/2176287895" target="_blank" class="icon-weibo" title="微博"></a>
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="Rocky ZhouJin QQ987415811">Rocky ZhouJin QQ987415811</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>












<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
