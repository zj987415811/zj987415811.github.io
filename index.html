<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Rocky for Everything</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rocky for Everything</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">慢慢喜欢你</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/Druid源码解析之数据库连接池总论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/Druid源码解析之数据库连接池总论/" itemprop="url">
                  Druid源码解析之数据库连接池总论
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-20 18:17:52" itemprop="dateCreated datePublished" datetime="2018-08-20T18:17:52+08:00">2018-08-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-08-21 16:12:19" itemprop="dateModified" datetime="2018-08-21T16:12:19+08:00">2018-08-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-应用程序直接获取数据连接的缺点"><a href="#1-应用程序直接获取数据连接的缺点" class="headerlink" title="1.应用程序直接获取数据连接的缺点"></a>1.应用程序直接获取数据连接的缺点</h2><ol>
<li>用户每次请求都需要向数据库获得连接，数据库创建连接通常需要消耗大量资源，创建时间也较长。</li>
<li>大量得创建极大浪费数据库得资源，并且极易造成数据库服务器内存溢出，宕机。、</li>
</ol>
<h2 id="2-使用数据库连接池优化程序性能"><a href="#2-使用数据库连接池优化程序性能" class="headerlink" title="2.使用数据库连接池优化程序性能"></a>2.使用数据库连接池优化程序性能</h2><ol>
<li>数据库连接池的概念<ol>
<li>数据库连接是一种关键得有限得昂贵得资源，咋多用户网页程序中体现尤为突出。</li>
<li>对数据库连接的管理能力显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</li>
<li>数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li>
<li>数据库连接池在初始化时将创建一定数量的数据库连接池放到连接池中，这些数据库连接的数量由最小数据库连接数来设定。无论这些数据库连接是否被使用，连接池都将保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求连接数超过最大连接数量时，这些请求将会被加入到等待队列中。</li>
<li>数据库连接池的最小连接数和最大连接数的设置需要考虑一下几个因素：<ol>
<li>最小连接数:是连接池一直保持的数据库连接，所以如果应用程序对数据库连接使用量不大，将会有大量数据库连接资源被浪费；</li>
<li>最大连接数:是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响到以后的数据库操作。</li>
</ol>
</li>
</ol>
</li>
<li>编写数据库连接池<ol>
<li>实现java.sql.DataSource接口,DataSource接口定义了两个重载的getConnection方法:<ol>
<li>Connection getConnection();</li>
<li>Connection getConnection(String username, String password);</li>
</ol>
</li>
<li>实现DataSource接口，并实现连接池功能的步骤：<ol>
<li>在DataSource构造函数中批量创建与数据库的连接，并把创建的连接加入LinkedList对象中；</li>
<li>实现getConnection方法，让getConnection方法每次调用时，从LinkedList中去一个Connection返回给用户；</li>
<li>当用户使用完Connection,调用Connection.close()方法时，Collection对象应保证自己返回到LinkedList中，而不是把conn还给数据库。<strong>Collection保证将自己返回到LinkedList中</strong>；</li>
</ol>
</li>
<li>部分核心代码<br> `proxyConn = (Connection) Proxy.newProxyInstance(this.getClass().getClassLoader(),conn.getClass().getInterfaces(),new InvocationHandler(){<pre><code>public Object invoke(Object proxy,Method method,Object[] args) {
    if(method.getName().equals(&quot;close&quot;)) {
        pool.addLast(conn);
        return null;
    }
    return method.invoke(conn,args);
}
</code></pre> })` </li>
</ol>
</li>
<li>开源数据库连接池<ol>
<li>很多WEB服务器都提供了DataSource的实现，即连接池的实现。把DataSource的实现，按其英文含义称之为数据源，数据源中包含了数据库连接池的实现。</li>
<li>DBCP C3P0 使用了数据库连接池，就不需要在编写连接数据库代码了，直接从数据源获得数据库的连接。</li>
<li>DBCP数据源:tomcat采用该连接池</li>
<li>C3P0数据源:dbcp没有自动回收空闲连接的功能，c3p0有自动回收空闲连接功能</li>
<li>Tomcat数据源</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/计算机网络总结复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/计算机网络总结复习/" itemprop="url">
                  计算机网络总结复习
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-20 16:09:39 / Updated at: 16:12:39" itemprop="dateCreated datePublished" datetime="2018-08-20T16:09:39+08:00">2018-08-20</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机网络复习"><a href="#计算机网络复习" class="headerlink" title="计算机网络复习"></a>计算机网络复习</h2><p>1.域名访问流程<br>    1.ip地址查找<br>        1.浏览器查找缓存，是否有ip地址，无则继续<br>        2.操作系统操作缓存，无则继续<br>        3.路由器查找缓存，无则继续<br>        4.本地服务器查找缓存，无则继续<br>        5.根-&gt;顶级-&gt;权威<br>        6.告知其ip地址<br>    2.主机获取ip地址端口建立tcp连接，3次握手<br>    3.浏览器发送请求报文<br>    4.服务器接收报文，并向客户机发出确认请求；<br>    5.客户机收到后，发送确认已接收，完成tcp建立<br>    6.浏览器发出http协议的get请求等；<br>    7.服务器响应，并指定文件发送给浏览器；<br>    8.浏览器显示所有页面<br>2.版本2<br>    1.浏览器输入URL<br>    2.浏览器查看缓存，如果请求资源新鲜，则显示（建立连接？）<br>    3.浏览器缓存<br>        1.如果未还缓存，发起新请求<br>        2.浏览器查看缓存，如果新鲜，返回给客户端<br>        3.浏览器解析URL获取协议，主机，端口号，path<br>        4.组装HTTP请求报文<br>        5.浏览器获取主机ip地址，过程如下：<br>            1.浏览器缓存<br>            2.操作系统缓存<br>            3.hosts文件缓存<br>            4.路由器缓存<br>            5.isp DNS缓存<br>            6.DNS递归查询<br>        6.打开socket与ip地址，建立tcp连接<br>        7.TCP建立后发送http请求报文<br>        8.服务器接受请求并解析，将请求转发到服务器程序<br>        9.检查是否缓存信息，以及缓存信息是否新鲜<br>        10.将请求信息返回给浏览器<br>        11.四次挥手<br>        12.资源缓存<br>    版本3<br>    1.浏览器先尝试从hosts文件获取对应的ip地址。如果没有，则使用DNS协议来获取IP.<br>        1.浏览器查找缓存，是否有ip地址，无则继续<br>        2.操作系统操作缓存，无则继续<br>        3.路由器查找缓存，无则继续<br>        4.本地服务器查找缓存，无则继续<br>        5.根-&gt;顶级-&gt;权威<br>        6.告知其ip地址<br>    2.使用TCP协议，建立tcp连接。<br>        前提：需要用到ip协议 ARP协议<br>        1.发送syn x<br>        2.服务器发送syn ack x+1 y<br>        3.客户端发送syn ack y+1<br>    3.使用Http协议请求网页内容<br>    版本4<br>    1.总论：<br>        i.域名解析成ip地址；<br>        ii.与目的主机进行tcp连接(三次握手);<br>        iii.发送与收取数据(浏览器与目的主机开始http访问过程);<br>        iv.与目的主机断开tcp连接;<br>    2.域名解析成ip地址<br>        i.浏览器向本机DNS模块发出DNS请求，DNS模块生成相关的DNS报文;<br>        ii.DNS模块将生成的DNS报文传递给传输层的UDP协议单元;<br>        iii.UDP协议单元将该书封装成UDP数据报，传递给网络层的IP协议单元;<br>        iv.IP协议单元将该数据封装成IP数据包，其目的ip地址为DNS服务器的ip地址;封装好的ip数据包将传递给数据链路层的协议单元<br>        v.发送时在ARP缓存中查询相关数据，如果没有就发送ARP广播(包含带查询的IP地址，收到广播的主机检验主机的IP,符合条件的主机将含有自己MAC地址的ARP包发送给ARP广播的主机)请求，等待ARP回应;<br>        vi.得到ARP回应后，将IP地址与路由的下一跳MAC地址对应信息写入ARP缓存表;写入缓存后，以路由下一跳的地址填充目的的MAC地址，以数据帧形式转发;转发可能进行多次;<br>        vii.DNS请求到达DNS服务器的数据链路层协议单元;DNS服务器的数据链路层协议单元解析数据帧，将内部的ip数据包传递给网络层IP协议单元；DNS服务器的IP协议单元解析IP数据包，将内部的UDP数据报传递给传输层UDP协议单元;DNS服务器的UDP协议单元解析收到的UDP数据报，将内部的DNS报文传递给DNS服务单元;<br>        viii.DNS服务单元将域名解析成对应IP地址，产生DNS响应报文;DNS回应报文-&gt;UDP-IP-MAC-&gt;我的主机;本地主机收到数据帧，将数据帧-&gt;IP-&gt;UDP-&gt;浏览器;将域名解析结果以域名和IP地址对用形式写入DNS缓存表；<br>    3.与目的主机进行tcp连接<br>        1.SYN seq = x;<br>        2.SYN ACK Ack=x+1;seq = y;<br>        3.ACK Ack = y+1;<br>    4.发送与收取数据(浏览器与目的主机开始HTTP访问过程)<br>        1.浏览器向域名发出GET方法报文;—&gt;HTTP请求<br>        2.报文通过TCP-&gt;IP(DNS)-&gt;MAC(ARP)-&gt;网关-&gt;目的主机；<br>        3.目的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP，HTTP协议单元会回应HTTP协议格式封装好的HTML形式数据；—&gt;HTTP响应：从请求信息中获取客户机想要访问的主机名，从请求信息中获客户机想要访问的web应用。从请求信息中获取客户机要访问的web资源。（即各种文件，图片，视频，文本等）读取响应的主机下web应用，web资源，用读取的web资源数据，创建一个HTTP响应。<br>        4.该HTML通过TCP-&gt;IP-&gt;MAC-&gt;网关-&gt;我的主机<br>        5.我的主机收到数据帧，通过IP-&gt;TCP-&gt;HTTP-&gt;浏览器，浏览器以网页形式显示HTML内容。<br>    5.与目的主机断开TCP连接(四次挥手)<br>        1.浏览器向目的主机发出TCP连接结束的请求报文，此时进入FIN WAIT状态；该报文FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP(DNS)-&gt;MAC(ARP)-&gt;网关-&gt;目的主机;目的主机收到数据帧，通过IP-&gt;TCP,TCP协议单元回应结束应答报文；<br>        2.目的主机收到数据帧，通过IP-&gt;TCP,TCP协议单元回应结束应答报文；<br>        3.当前收到回应，因为目的主机还有数据要传，不急于断开连接；<br>        4.该报文中ACK标志设为1，表示收到结束请求；<br>        5.目的数据发送完所有数据后，向客户端发出TCP连接结束请求报文；该报文把FIN标志位设为1，表示结束请求；TCP结束请求报文通过IP-&gt;MAC-&gt;网关-&gt;我的主机；<br>        6.客户端收到数据帧，通过IP-&gt;TCP，TCP协议单元回应结束应答报文，此时进入TimeWait状态；<br>        7.该报文中FIN均设为1，表示结束应答；<br>        8.目的主机关闭连接；Time Wait等待结束后。</p>
<p>3.TCP/UDP区别<br>    1.TCP 面向连接可靠运输协议 UDP面向非连接不可靠<br>    2.TCP报文段首部20字节，UDP报文段8字节<br>    3.TCP有拥塞控制和流量控制，而UDP没有<br>    4.TCP连接过程有3次握手，4次挥手，时延较大，UDP时延较小<br>    5.TCP是一对一连接 UDP可以一对一一对多<br>4.GET/POST的区别<br>    1.get请求会被缓存，保留在浏览器历史记录中，可作为收藏书签，不应再处理敏感数据时使用，有请求长度限制；<br>    2.post请求不会被缓存，不会保留书签和浏览器历史记录；<br>    3.对长度没要求；<br>5.DNS使用的协议<br>    1.既使用TCP也使用UDP,UDP报文长度最大512字节，当DNS查询超过512字节时，协议的TC标志出现删除标志，这时候使用TCP发送。<br>    2.区域传送时使用TCP:<br>        1.辅域名服务器会定时向主域名服务器进行查询以便了解数据是否有变动。如有变动，执行一次区域传送，进行数据同步。区域传送将使用TCP而不是UDP；<br>        2.TCP是一种可靠连接，保证了数据的准确性。<br>    3.域名解析使用UDP<br>6.幂等<br>7.Cookie和Session区别<br>    1.Cookie是一种能够让网站服务器把少量数据存储在客户端硬盘或内存，或是从客户端的硬盘读取数据的一种技术。当你浏览某网站时，由web服务器置于硬盘上的一个非常小的文本文件，他可以记录你的用户ID,密码，浏览过的网页，停留信息；<br>    2.Session:当用户请求来自应用程序的web页时，如果该用户还没有会话，则web服务器自动创建一个Session对象。当会话过期或者被抛弃后，服务器终止该会话。<br>    3.Session采用在服务器端保持状态的方案，cookie是在客户端保持状态的方案。由于服务器端保持状态的方案在客户端需要保持一个表示，所以session机制需要借助cookie机制来达到保存标识的目的。<br>    4.Session是服务器用来跟踪用户的一种手段，每个session都有一个唯一标识：SessionID;当服务器创建了Session时，给客户端发送的响应报文包含了SetCookie字段，其中有一个名为sid的键值对，这个键值SessionID,客户端收到后就把cookie保存到浏览器，并发之后发送的请求报表都包含SessionID。Http就通过Session和Cookie这两个发送一起合作来实现用户状态跟踪，Session用于服务端，Cookie用于客户端。<br>8.TCP粘包和拆包产生的原因<br>    1.应用程序写入数据的字节大小大于套接字发送缓冲区大小;<br>    2.进行MSS大小的TCP分段。MSS是最大报文段缩写。<br>    3.payLoad大于MTU进行ip分片。MTU指：一种通信协议的某一层上面所能通过的最大数据包大小。如果IP层有一个数据包要传，而且数据的长度比链路层的MTU大，那么IP层就回进行分片，把数据报分成若干片，让每一个片都不超过MTU。IP分片可以发生在原始发送端主机上，也可以发生在中间路由器上。<br>9.TCP粘包拆包的解决策略<br>    1.消息定长<br>    2.在包尾部增加回车空格等特殊字符进行分割，如FTP；<br>    3.将消息分为消息头和消息尾；<br>    4.其他复杂的协议；<br>10.三次握手<br>    1.建立连接时，客户端发送syn包到服务器，并进入syn_Send状态，等待服务器确认；<br>    2.服务器收到Syn包，必须确认客户的syn，同时也发送自己的syn包，此时服务器进入syn_recv状态；<br>    3.客户端端收到SYN+ACK包，向服务器发送确认包ACK,客户端和服务器进入ESTABLISHED状态，完成3次握手。<br>    4.QA:<br>        i.为了保证服务端能够收到客户端信息并且能够做出正确的应答而进行前两次握手，为了保证客户端能够接收到服务端的信息并能够做出正确的应答而进行后二次握手；<br>        ii.三次握手的本质是信道不可靠，但是通信双方需要就某个问题达成一致，而要解决这个问题，无论你在消息中包含了什么信息，三次通信是理论上的最小值，所以三次握手不是tcp本身的要求，而是为了满足:在不可靠信道上可靠地传输信息，本质需求是，信道不可靠，数据传输要可靠，三次是最小带价值；<br>        iii.为什么进行三次握手：为了防止已失效的链接请求报文又突然传送到服务端，因而产生错误。为了解决网络中存在延迟的重复分组问题。<br>        iv.例：client发出的第一个链接请求报文段并没有丢失，而是在某个网络结点长时间滞留了，以致延误到连接释放以后的某个时间才到达Server。本来这是一个早已失效的报文段，但Server收到此失效的连接请求报文后，就误以为是client再次发出一个新的连接请求。于是就向client发出确认报文段，同一建立连接。假设不采用三次握手，那么server确认就建立连接了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发出数据，但server却认为新的运输连接已经建立，并一直等待Client发来数据。这样就浪费了server的资源。防止造成服务端资源浪费。<br>11.Socket<br>    1.网络通信必须的五种信息:连接使用的协议，本地主机的ip地址，本地进程的协议端口，远地主机的IP地址+端口;<br>    2.建立socket:一对套接字，一个运行于客户端，一个运行于服务端。连接分为3个过程：服务器监听，客户端请求，连接确认。<br>12.四次挥手<br>    1.客户端线发送FIN,进入FIN_WAIT状态<br>    2.服务端收到FIN,发送ACK,进入CLOSE_WAIT状态，客户端收到这个ACK,进入FIN_WAIT状态<br>    3.服务端发送FIN，进入LAST_ACK状态<br>    4.客户端收到FIN,发送ACK，进入TIME_WAIT状态，服务端收到ACK,进入CLOSE状态<br>    5.QA:<br>        i.TCP协议是一种面向连接可靠的基于字节流的运输层通信协议。TCP是双全工模式，当主机1发出FIN报文段时，只是表示主机1已经没有数据要发送了。主机1告诉主机2，它的数据已经全部发送完毕了；但是这个时候主机1还是可以接受来自主机2的数据；当主机2返回ACK报文段时，表示它已经知道主机1没有数据发送了，但是主机2可以发送数据到主机1；当主机2发送FIN报文段时候，这个时候表示主机2也没有数据要发送了，就会告诉主机1，之后就断开。<br>        ii.服务端在Listen状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里面发送给客户端。而关闭连接时，当收到对方的FIN。<br>13.TCP如何保证可靠传输<br>    1.三次握手<br>    2.将数据截断为合理的长度。应用数据被分割成TCP认为最适合发送的数据块；按字节编号，合理分片；<br>    3.超时重发。当TCP发出一个段后，它启动一个定时器，如果不能及时收到一个确认就重发；<br>    4.对于收到的请求给出确认响应；<br>    5.校验出包有错，丢弃报文段，不给出响应；<br>    6.对于失序数据进行重新排序，然后才交给应用层；<br>    7.对于重复数据，能够丢弃重复数据；<br>    8.流量控制，TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。<br>    9.拥塞控制，当网络拥塞时，减少数据的发送。<br>14.详细介绍HTTP<br>    1.1.0和2.0的区别<br>        1.多路复用，允许单一的http/2连接同时发起多重请求-响应消息。<br>        2.二进制分帧，位于应用层和传输层之间。<br>        3.首部压缩<br>        4.HTTP2.0支持服务器推送<br>15.HTTPS和HTTP<br>    1.https协议需要到CA申请证书；<br>    2.http时超文本传输协议，信息是铭文传输;https是具有安全性的ssl加密传输协议；<br>    3.http和https使用的是完全不同的连接方式，用的端口不一样，前者是80，后者是443;<br>    4.http的连接很简单，是无状态的；https协议由SSL+HTTP协议构建的可进行加密传输，身份认证的网络协议；</p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/17/手写Java集合类之SkipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/手写Java集合类之SkipList/" itemprop="url">
                  手写Java集合类之SkipList
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-17 09:24:31 / Updated at: 10:47:09" itemprop="dateCreated datePublished" datetime="2018-08-17T09:24:31+08:00">2018-08-17</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-SkipList原理"><a href="#1-SkipList原理" class="headerlink" title="1.SkipList原理"></a>1.SkipList原理</h2><ol>
<li>跳跃表使用概率均衡而不是使用强制性均衡，对于插入和删除结点比传统上的平衡树更为简洁。</li>
<li>传统向有序链表中插入一个结点所需时间是O(n),查找也是O(n),使用跳跃表可以减少查找所需时间为O(n/2)。</li>
<li>每个结点不单单只包含指向下一个结点的指针，可能包含很多个指向后续结点的指针，这样就可以跳过一些不必要的结点，从而加快查找，删除等操作。<strong>对于链表内每一个结点包含多少个指向后续元素的指针，这个过程是通过一个随机函数生成器得到。</strong></li>
<li>跳表的操作<ol>
<li>重要的数据结构定义</li>
<li>初始化表</li>
<li>查找</li>
<li>插入</li>
<li>删除</li>
<li>随机数生成器</li>
<li>释放表</li>
<li>性能比较</li>
</ol>
</li>
<li></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/计算机网络 第五章 网络层/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/计算机网络 第五章 网络层/" itemprop="url">
                  计算机网络 第五章 网络层
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-16 17:50:28 / Updated at: 18:21:48" itemprop="dateCreated datePublished" datetime="2018-08-16T17:50:28+08:00">2018-08-16</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>网络层—&gt;将数据从端到端，是端到端的最底层；<br>    1.网络层必须知道网络拓扑结构，所有路由器与链路的集合，并且找出一条好路;<strong>路径规划</strong><br>    2.网络层要仔细选择路由器，避免某些通信线路和路由器负载过重;<strong>负载均衡</strong></p>
<h2 id="2-网络层设计问题"><a href="#2-网络层设计问题" class="headerlink" title="2.网络层设计问题"></a>2.网络层设计问题</h2><p>1.存储转发数据包交换<br>    1.ISP网络服务提供商的设备和客户端设备<br>    2.一台主机要发送一个数据包：存储-转发数据包交换<br>        1.需要将数据包传递给最近的路由器，路由器可能在它自己的LAN上，也可能在一条通向ISP的点到点链路上；<br>        2.在该数据包到达路由器，并且路由器链路层完成了对它校验和的验证之后，它先被存储在路由器上；<br>        3.沿着路径被转发到下一个路由器，直到到达目标主机；<br>2.提供给传输层的服务<br>    1.设计目标<br>        1.向上提供的服务应该独立于路由器技术；<br>        2.应该向传输层屏蔽路由器数量，类型和拓扑关系；<br>        3.传输层可用的网络地址应该有一个统一编码方案，甚至可以跨越LAN和WAN;<br>    2.面向连接和面向非连接 </p>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/16/Druid源码解析之SQL解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/16/Druid源码解析之SQL解析/" itemprop="url">
                  Druid源码解析之SQL解析
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-16 14:18:27 / Updated at: 17:45:30" itemprop="dateCreated datePublished" datetime="2018-08-16T14:18:27+08:00">2018-08-16</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Druid源码解析之SQL解析"><a href="#Druid源码解析之SQL解析" class="headerlink" title="Druid源码解析之SQL解析"></a>Druid源码解析之SQL解析</h2><p>概述：<br>    SQL解析可以分为三层：</p>
<pre><code>    - AST抽象语法树，语句解析-&gt; MySqlStatementParser:多个表达式和词组成完整的语句 
        - SQLParser
            - errorEndPos:解析出错记录位置
            - lexer:词法解析
            - dbType:数据库类型
        - SQLStatement
            - exprParser:表达式解析类；
            - SQLCreateTableParser:建表语句解析类，其他DDL语句在SQLStatement中；
            - parseValueSize:记录解析结果集大小；
            - keepComments:是否保留注释；
            - parseCompleteValues:是否全部解析完成。
        - MySqlStatementParser
            - 静态关键词
            - exprParser:针对MySQL语句的parser;
    - 表达式解析-&gt; MySqlExprParser:表达式由词组成，用来解析出不同表达式的含义
        - SQLExprParser 
            - AGGREGATE_FUNCTIONS 统计函数的关键词
            - aggregateFunctions 保存统计函数的关键词
        - MysqlExparser
            - AGGREGATE_FUNCTIONS 针对mysql统计函数的关键词

    - 词法解析-&gt; MySqlLexer:解析出每个词的词义,部分关键词含义
        -   symbols_l2
            features
            text:保存目前整个SQL语句
            pos:当前处理位置
            mark:当前处理此开始位置
            ch:当前处理字符
            buf:当前缓存的处理词
            bufPos:用于取出词的标记，当前从text中取出的词应该是mark位置开始
            token:当前位于的关键词
            keywods:所有关键词集合
            stringVal
            lines:总行数
            dbType:数据库类型

- SQL三个重要组成部分：Parser,AST,Visitor
    - Parser 由两部分组成
        - Lexer
        - 表达式
    - AST Parser的产物，语句经过词法分析，语法分析，其结构需要以一种计算机能读懂的方式表达出来，也就是抽象语法树。
    - Visitor 遍历这颗语法树，使用visitor模式，从根节点开始遍历，一直到最后一个叶子节点，在这个过程中，不断地收集信息到一个上下文中，整个遍历过程完成后，这棵树所表达的语法含义就被保存到上下文中。使用广度优先遍历方式。
</code></pre><ol>
<li><p>涉及到的类</p>
<ol>
<li>SQLStatementParser parser = new MySqlStatementParser(sql);</li>
<li><p>MySqlStatementParser执行父类SQLExprParser的方法，这个过程在静态代码块中定义了一系列字段；<br>static {<br> String[] strings = { “AVG”, “COUNT”, “MAX”, “MIN”, “STDDEV”, “SUM” };</p>
<pre><code>AGGREGATE_FUNCTIONS_CODES = FnvHash.fnv1a_64_lower(strings, true);
</code></pre><p> AGGREGATE_FUNCTIONS = new String[AGGREGATE_FUNCTIONS_CODES.length];<br> for (String str : strings) {</p>
<pre><code>long hash = FnvHash.fnv1a_64_lower(str);
int index = Arrays.binarySearch(AGGREGATE_FUNCTIONS_CODES, hash);
AGGREGATE_FUNCTIONS[index] = str;
</code></pre><p> }<br>}<br>//执行MySqlExprParser的构造方法</p>
<p>public MySqlExprParser(String sql){<br> this(new MySqlLexer(sql));<br> this.lexer.nextToken();<br>} </p>
<p>//Lexer构造方法-&gt;SymbolTable初始化</p>
<p>Map&lt;String, Token&gt; map = new HashMap&lt;String, Token&gt;();</p>
<p>this.lexer.nextToken();</p>
</li>
</ol>
</li>
</ol>
<p>3.SQLStatement sqlStatement = parser.parseStatement();</p>
<pre><code>- parseStatement()中通过lexer.token选择对应的方法；
- 如select-&gt;this.parseSelect();
- 构造MySqlSelectParser对象
MySqlSelectParser selectParser = createSQLSelectParser();
SQLSelect select = selectParser.select();
- select()方法
    - SQLSelect select = new SQLSelect();
    - 判断是否是with
    - 如果不是构造SQLSelectQuery
        - SQLSelectQuery query = query();query()方法内部
            - 判断token是否是lparen左括号;
            - 如果不是直接到MySqlSelectQueryBlock queryBlock = new MySqlSelectQueryBlock();并且设置父类的相关属性；
            - 如果token是select,判断查询缓存是否为空；如果不为空进行匹配；
                - selectListCache.match(laxer,queryBlock);
            - 如果token是select,执行laxer.nextTokenValue();执行下一个token解析；
            - Token token = lexer.token();得到下一个token后进行解析；
            - parseSelectList(SQLSelectQueryBlock queryBlock);
                - 构建selectList,final List&lt;SQLSelectItem&gt; selectList = queryBlock.getSelectList();
                - parseSelectItem();
                - expr = new SQLAllColumnExpr();
                - lexer.nextToken();
                - return new SQLSelectItem(expr, null, connectByRoot);
            - parseInto(queryBlock);
        - 将query设置到SQLSelect中;
        - SQLOrderBy orderBy = this.parseOrderBy();
</code></pre><p>4.MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();</p>
<pre><code>- 父类构造方法
 public SchemaStatVisitor(String dbType){
    this(new SchemaRepository(dbType), new ArrayList&lt;Object&gt;());
    this.dbType = dbType;
 }
- SchemaRepository类作为构造函数入参传入，初始化SchemaRepository；
- 初始化mysql相关：consoleVisitor = new MySqlConsoleSchemaVisitor();
- 初始化MySqlConsoleSchemaVisitor的父类MySqlASTVisitorAdapter的父类SQLASTVisitorAdapter；
</code></pre><p>5.sqlStatement.accept(visitor)方法</p>
<pre><code>- priVisitor(this);这是一个空方法0-0
- accept0(SQLASTVisitor visitor);
    - 执行实现类MySqlSchemaStateVisitor的visit(SQLSelectStatement x)；
        - repository.resolve(x);
            - 内部构造一个 SchemaResolveVisitor resolveVisitor = createResolveVisitor(options);
            - createResolveVisitor(SchemaResolveVisitor.Option ...);选择不同类型的数据库；
        - resolveVisitor.visit(stmt);
            - 内部执行 resolve(SchemaResolveVisitor visitor, SQLSelect x) 方法         
            - 创建context环境：SchemaResolveVisitor.Context ctx = visitor.createContext(x);
            - SQLSelectQuery query = x.getQuery();获取query;
            - 之后执行accept(visitor)方法；
</code></pre><p>6.总结：新建MySqlStatementParser</p>
<pre><code>- 内部新建一个MySqlExprParser-&gt;MySqlLexer-&gt;读取第一个有效词:lexer.nextToken();
- 新建一个MySqlLexer-&gt;执行父类Lexer构造方法-&gt;初始化关键词
- new Lexer(String input, CommentHandler commentHandler) 或 new Lexer(String input, boolean skipComment)
    - input 输入语句
    - commentHandler 注释处理器
    - scanChar();读取第一个字符
- 初始化Lexer后，回到MySqlExprParser构造器，初始化KeyWords集合;
- 之后回到MySqlStatementParser:调用父类SQLStatementParser方法初始化;
- new SQLParser(Lexer lexer, String dbType) 完成初始化。 
</code></pre><p>7.代码分析</p>
<pre><code>- `// 新建 MySQLParser
    SQLStatementParser parser = new MySqlStatementParser(sql);
    // 使用Parser解析生成AST，这里SQLStatement就是AST，解析结果是一个SQLStatement,是一个内部维护了树状逻辑结构的类
    SQLStatement statement = parser.parseStatement();

    // 使用visitor来访问AST
    MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
    statement.accept(visitor);
    `
- 词法分析
    - SQLStatementParser parser = new MySqlStatementParser(sql);
    - 语法分析是SQLParser,词法分析Lexer,在Parser中拥有一个Lexer;
    - Lexer有两个，Lexer和其子类MySqlLexer;Lexer作为词法分析器，内部具有词汇表，以keywords表示;
    - keywords是以key为单词，value为Token的字典型结构，Token是单词的类型;
    - MySqlLexer类，除了父类的keywords外还有自己的keywords;Lexer中维护的是通用的，而MySqlLexer除了有通用还有MySQL数据库SQL方言关键字集合。
    - Parser是Lexer的使用者；
    - Lexer需要具备一个函数，能够让命令者命令它解析一个单词，而且Lexer还必须提供一个函数，供使用者获取Lexer上一次解析到的单词亿级单词的类型。
    - 在Lexer中，nextToken()方法提供了解析一个单词的需求，被调用时，就按顺序从SQL语句的开头到结尾，解析出下一个单词;
    - token()方法，则返回上一次解析的单词的Token类型，如果Token类型是标识符(Identifier)，Lexer还提供一个stringVal()方法，让使用者拿到标识符值。
    - nextToken()内部充斥着if语句和switch语句，解析单词时候，是一个个字符地解析，这个方法每次扫描一个字符，都必须判断单词是否结束，用什么方式来验证这个单词等待。这个过程是状态机运作的过程，每解析到一个字符，都要判断当前的状态，以决定应该进入下一个什么状态。
- parseStatement()方法
    - if(lexer.token() == Token.XXX) return XXX;
    - 对应select类型的语句解析
        if (lexer.token() == Token.SELECT) {
            statementList.add(parseSelect());
            continue;
        }
    - parseSelect()方法
        public SQLStatement parseSelect() {
            MySqlSelectParser selectParser = new MySqlSelectParser(this.exprParser);

            SQLSelect select = selectParser.select();

            if (selectParser.returningFlag) {
                return selectParser.updateStmt;
            }

            return new SQLSelectStatement(select, JdbcConstants.MYSQL);
         }
        - 初始化一个针对MySQL Select语句的Parser,然后调用select()方法进行解析，把返回结果SQLSelect放到SQLSelectStatement里。而这个SQLSelectStatement就是AST抽象语法树，SQLSelect是他的第一个子节点。
 - MySqlSchemaStatVisitor visitor = new MySqlSchemaStatVisitor();
     - 有了AST语法树后，需要一个visitor来访问;
     - statement调用accept方法，以visitor作为参数，进行访问；statement的实际类型是SQLSelectStatement;
     - 在Druid中一条SQL语句中的元素，无论高层次还是低层次的元素，都是一个SQLObject,statement,expr,函数，字段，条件都是一种SQLObject。SQLObject是一个接口，accept方法由SQLObject定义，目的是为了让访问者在访问SQLObject时，告知访问者一些事情，在访问过程中手机关于SQLObject的一些信息。
     - accept()在SQLObjectImpl类实现
         public final void accept(SQLASTVisitor visitor) {
                if (visitor == null) {
                    throw new IllegalArgumentException();
                }

                visitor.preVisit(this);
                //真正执行的方法
                accept0(visitor);

                visitor.postVisit(this);
         }
         - 这是一个final方法，所有子类都要遵循这个模板，在accept()前后，visitor会进行一些操作，真正访问流程在acceptor0(visitor)中，这是一个抽象方法。
     - acceptor0(SQLASTVisitor visitor)
         protected void accept0(SQLASTVisitor visitor) {
            if (visitor.visit(this)) {
                acceptChild(visitor, this.select);
            }
            visitor.endVisit(this);
         }
        - 首先使用visitor访问自己，然后决定是否访问自己的子元素。
        - MySqlSchemaStateVisitor的visit()方法:初始化自己的aliasMap,之后返回true;
            public boolean visit(SQLSelectStatement x) {
                setAliasMap();
                return true;
            }
        - 然后递归访问子元素
    - SQLObject负责通知visitor要访问的元素，visitor负责访问相应元素前中后三个过程的逻辑处理。
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/13/SpringBoot实战笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/13/SpringBoot实战笔记/" itemprop="url">
                  SpringBoot实战笔记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-13 14:12:24" itemprop="dateCreated datePublished" datetime="2018-08-13T14:12:24+08:00">2018-08-13</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/Druid源码解析之初步认识/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/Druid源码解析之初步认识/" itemprop="url">
                  Druid源码解析之初步认识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-10 22:38:12" itemprop="dateCreated datePublished" datetime="2018-08-10T22:38:12+08:00">2018-08-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-08-13 14:43:19" itemprop="dateModified" datetime="2018-08-13T14:43:19+08:00">2018-08-13</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>##Druid源码解析##</p>
<ul>
<li>Druid是什么<ul>
<li>数据库连接池，提供强大的监控与扩展功能，包含ProxyDriver,一系列内置的JDBC组件库，一个SQL Parser;</li>
<li>监控组件，监控应用程序的运行情况，包括Web URI,Spring,JDBC等。为了监控执行SQL执行情况，做了一个Filter-Chain模式的ProxyDriver,缺省提供给StatFilter。还做了一个SQL Parser，将数据库连接池，SQL Parser,ProxyDriver合起来做了一个项目，名为Druid.</li>
<li>亚秒级查</li>
<li>支持JDBC兼容的数据库，包括Oracle,MySQL,DB。。。等等</li>
<li>提供快速的聚合能力以及亚秒级的OLAP查询能力，多租户的设计，面向用户分析应用的理想方案</li>
<li>阿里巴巴线上验证</li>
<li>强大的监控特性，通过Druid提供的监控功能，可以清楚知道连接池和SQL工作情况,监控SQL执行时间，ResultSet持有时间，返回行数，更新行数，错误次数，错误堆栈信息。<ul>
<li>SQL执行的耗时区间分布。</li>
<li>监控连接池的物理连接创建和销毁次数，逻辑连接的申请和关闭次数，非空等待次数,PSCache命中率等。</li>
<li>为了方便扩展，提供了Filter-Chain模式的扩展API,可以自己编写Filter拦截JDBC中的任何方法，如性能监控，SQL审计，用户名密码加密，日志等待。</li>
<li>内置StatFilter,日志输出的Log系列Filter,防御SQL注入攻击的WallFilter。</li>
<li>ExceptionSorter,当一个连接产生不可恢复的异常时，必须立即从连接池中逐出，否则会产生大量错误。</li>
<li>PSCache内存优化对于支持游标的数据库,大幅度提升SQL执行性能。一个PreparedStatement对应服务器一个游标，可以缓存起来重复执行。</li>
<li>LRU</li>
</ul>
</li>
</ul>
</li>
<li>Druid如何扩展JDBC？<ul>
<li>Druid在DruidDataSource和ProxyDriver上提供了Filter-Chain模式的扩展API,类似Servlet的Filter;</li>
</ul>
</li>
</ul>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/Sofa学习之SofaRPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/Sofa学习之SofaRPC/" itemprop="url">
                  Sofa学习之SofaRPC
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-10 17:42:05 / Updated at: 22:24:57" itemprop="dateCreated datePublished" datetime="2018-08-10T17:42:05+08:00">2018-08-10</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>1.Sofa是蚂蚁自主研发的金融级分布式中间件，包含构建金融级云原生架构所需的各个组件，包括微服务研发框架，RPC框架，服务注册中心，分布式定时任务，限流/熔断框架，动态配置推送，分布式链路追踪，Metrics监控度量，分布式高可用消息队列，分布式事务框架，分布式数据库代理层等组件，是一套分布式架构的完整解决方案。</p>
<pre><code>- SofaRPC是蚂蚁金服开源高可扩展，高性能，生产级的JavaRPC框架。
- SOfaRPC致力于简化应用之间的RPC调用，为应用提供方便透明，稳定高效的点对点远程服务调用方案。SofaRPC提供丰富的模型抽象和可扩展接口，包括过滤器，路由，负载均衡等等。
- SofaRPC功能特性:
    - (1)透明化，高性能的远程服务调用；
    - (2)支持多种服务器路由以及负载均衡策略；
    - (3)支持多种注册中心的集成；
    -（4）支持多种协议；
    -（5）支持同步单向回调泛化等多种调用方式；
    -（6）支持集群容错，服务预热，自动故障隔离；
    -（7）强大的扩展功能，按需扩展。
</code></pre><ol start="2">
<li><p>架构设计</p>
<ol>
<li>从上到下分为两层：<ul>
<li>核心层：包含RPC的核心组件以及一些通用的实现，如随机等负载均衡算法；</li>
<li>功能实现层：所有功能实现层的用户都是平等的，都是基于扩展机制实现的。</li>
</ul>
</li>
<li><p>架构原理</p>
<ol>
<li>Client<br> Client             —–&gt;客户端发起调用—&gt;调用Stub<br> Proxy              —–&gt;生成Stub,拦截调用，保存调用请求相关信息—&gt;路由寻址<br> Router&amp;Registry —–&gt;根据参数信息从Router和连接管理器中取地址—&gt;参数序列化，作为二进制准备传递<br> Codec           —–&gt;添加requestId等，按照协议格式编码之后传递—&gt;数据编码—&gt;网络传输—&gt;DeCondec:按照协议的规范，进行节码—&gt;解码,序列化—&gt;<br> ServerWorkerManager—&gt;管理发布的服务Bean,进行反射调用—&gt;<br> Server —&gt;业务处理</li>
<li><p>Sofa源码主要包括</p>
<ol>
<li>all(发布打包模块)，</li>
<li>bom(依赖管控模块，用于依赖版本管控)，</li>
<li>example(示例模块)，</li>
<li>test(测试模块，集成测试)，</li>
<li>core(<ol>
<li>api:API模块，涵盖各种基本流程接口,消息,上下文,扩展接口等;</li>
<li>common公共模块，</li>
<li>涵盖工具类utils,数据结构;</li>
<li>exception:异常模块，涵盖各种异常接口等)。</li>
</ol>
</li>
<li>core模块包括<ol>
<li>bootstrap,启动实现模块，用于启动类，发布或者引用服务逻辑,以及registry的操作；</li>
<li>proxy代理实现模块，用于接口实现代理生成；</li>
<li>client 客户端实现模块，用于发送请求，接收响应，连接维护，路由，负载均衡，同步异步等；</li>
<li>server 服务端实现模块，用于启动监听，接收请求，发送响应，业务线程分发等；</li>
<li>filter 拦截器实现模块，用于服务端和客户端的各种拦截器实现；</li>
<li>codec 编解码实现模块，例如压缩，序列化等；</li>
<li>protocol 协议实现模块，用于协议的包装处理，协商；</li>
<li>transport 网络传输实现模块，用于Tcp连接，数据分包粘包处理，请求响应对象分发等；</li>
<li>registry 注册中心实现模块，实现注册中心，如zk等。</li>
</ol>
</li>
</ol>
</li>
<li><p>实现原理</p>
<ol>
<li>Sofa rpc远程调用时通过服务模型来定义调用双方的，服务分为服务消费方和服务提供方，对应rpc的调用端和被调用端。service和reference;</li>
<li>当Sofa rpc的应用启动的时候，如果发现当前应用需求需要发布RPC服务的话，那么sofa rpc会将这些服务注册到配置中心上；</li>
<li>当引用这个服务的sofa应用启动时，会从配置中心订阅对应服务的地址；</li>
<li>当配置中心收到订阅请求后，会将发布方的地址列表推送给订阅方；</li>
<li>当引用服务的一方拿到地址以后，就可以发起直连调用服务。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/Sofa源码学习系列/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/Sofa源码学习系列/" itemprop="url">
                  Sofa源码学习系列
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-10 10:55:42" itemprop="dateCreated datePublished" datetime="2018-08-10T10:55:42+08:00">2018-08-10</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/10/Spring源码解析之Spring声明式事务/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/10/Spring源码解析之Spring声明式事务/" itemprop="url">
                  Spring源码解析之Spring声明式事务
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-10 10:50:55" itemprop="dateCreated datePublished" datetime="2018-08-10T10:50:55+08:00">2018-08-10</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Rocky ZhouJin</p>
              <p class="site-description motion-element" itemprop="description">个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">23</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">17</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rocky ZhouJin</span>

  

  
</div>




  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
