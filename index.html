<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.3.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.3.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.3.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.3.0" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.3.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:type" content="website">
<meta property="og:title" content="Rocky for Everything">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Rocky for Everything">
<meta property="og:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Rocky for Everything">
<meta name="twitter:description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">






  <link rel="canonical" href="http://yoursite.com/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>Rocky for Everything</title>
  









  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rocky for Everything</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">慢慢喜欢你</p>
      
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Toggle navigation bar">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">
    <a href="/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-home"></i> <br />Startseite</a>
  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">
    <a href="/archives/" rel="section">
      <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />Archiv</a>
  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/29/k8s系列之k8s核心原理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/29/k8s系列之k8s核心原理/" itemprop="url">
                  k8s系列之k8s核心原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-09-29 14:22:49 / Updated at: 14:29:49" itemprop="dateCreated datePublished" datetime="2018-09-29T14:22:49+08:00">2018-09-29</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/27/k8s系列之入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/27/k8s系列之入门/" itemprop="url">
                  k8s系列之入门
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-09-27 16:02:12" itemprop="dateCreated datePublished" datetime="2018-09-27T16:02:12+08:00">2018-09-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-09-29 14:29:47" itemprop="dateModified" datetime="2018-09-29T14:29:47+08:00">2018-09-29</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-Kubernetes入门"><a href="#第一章-Kubernetes入门" class="headerlink" title="第一章 Kubernetes入门"></a>第一章 Kubernetes入门</h1><ol>
<li>K8S是什么<ol>
<li>大规模集群管理系统，基于容器技术，实现资源管理的自动化，以及跨多个数据中心得资源利用率最大化。</li>
<li>TCP通信协议进行交互。</li>
<li>完备得分布式系统支撑平台，具有完备得集群管理能力，多层次得安全防护和准入机制，多租户应用支撑能力，透明的服务注册和服务发现机制，内建智能负载均衡器，强大的故障发现和自我修复能力，服务滚动升级和在线扩容能力，可扩展的资源自动调度机制，多粒度的资源配额管理能力，完善的管理工具，如开发，部署测试，运维监控等各个环节。</li>
</ol>
</li>
<li>K8S基础<ol>
<li>Service是分布式集群架构的核心，一个Service对象拥有如下关键特征：<ol>
<li>拥有一个唯一指定的名字；</li>
<li>拥有一个虚拟ip和端口号；</li>
<li>能够提供某种远程服务能力；</li>
<li>被映射到了提供这种服务能力的一组容器应用上。</li>
</ol>
</li>
<li>Service的服务进程目前都基于Socket通信方式对外提供服务，如redis,Memcache,MySql,WebServer,或者一个特定的TCP server进程。Service通常由多个相关的服务进程来提供服务，每个服务进程都有一个独立的IP+PORT访问点，从来连接到指定的Service上。</li>
<li>强大的隔离功能，K8S设计了Pod对象，将每个服务进程包装到相应的Pod中，使其成为Pod中运行的一个容器。为了建立Service和Pod间的关联关系，K8S给Pod贴上一个Label，给运行MySQL的Pod贴上name=mysql标签。</li>
<li>Pod在节点中运行，节点可以是物理机，可以是云中的一个虚拟机，每个Pod里面运行着一个特殊的Pause容器，其他容器运行业务容器，这些业务容器工厂Pause容器的网络栈和Volume挂载卷，因而通信和数据交换更为高效。因此密切相关的服务进程放入同一个Pod中。</li>
<li>集群管理:将集群中机器划分为一个Master节点和一群工作节点，Master上运行着集群管理相关的一组进程kube-apiserver,kube-controller-manager和kube-scheduler,这些进程实现了整个集群资源管理，Pod调度，弹性伸缩，安全控制，系统监控和纠错等管理功能，并且都是全自动完成的。Node作为集群中的工作节点，运行真正的APP,在Node上K8S管理的最小运行单元式Pod。Node上运行着Kubelet,kube-proxy服务进程，这些服务进程负责Pod的创建，启动监控，重启销毁以及软件模式的负载均衡。</li>
</ol>
</li>
<li>使用K8S的原因<ol>
<li>IT从来都是技术驱动的。</li>
<li>简化团队，架构师专注于系统服务组件的提炼，开发专注于业务代码，运维负责K8S的部署和运维。</li>
<li>全面拥抱微服务，微服务架构的核心是将一个巨大的单体应用分解维很多小的相互连接的微服务，一个微服务背后有多个实例副本在支撑，副本数量随着系统的负荷变化而进行调整，内嵌的负载均衡器在这里发挥重要作用。</li>
<li>很方便的搬迁到公有云上。</li>
<li>超强的横向扩容能力。<br>4.K8S基本概念和术语</li>
<li>Node—相对于master而言的的工作主机。每个node上运行用于启动和管理的Pod服务-Kubelet，并能够被Master管理。在node上运行的是服务进程包括Kubelet,Kube-proxy,docker deamon。</li>
<li>Node的信息:<ol>
<li>Node地址：主机Ip地址+NodeID</li>
<li>Node运行状态:Pending,Running,Terminated三种状态</li>
<li>Node Condition(条件):描述Running状态Node的运行条件，Read—健康状态，可以接收从Master发来的创建Pod指令。</li>
<li>Node系统容量:描述Node可用的系统资源，包括CPU,内存数量，最大可调度Pod数量等。</li>
<li>其他:内核版本，K8S版本，docker版本，操作系统名称。</li>
</ol>
</li>
<li>Pod<ol>
<li>最基本的操作单元，包含一个或多个紧密相关的容器。是被容器化的环境看作应用层的逻辑宿主机，一个Pod中的多个容器应用是紧耦合的。Pod在node上被创建，启动或者销毁。</li>
<li>在Pod上封装Node的原因:Docker容器之间的通信收到Docker网络机制的限制，只能通过Link方式才能访问另一个容器提供的服务。大量容器之间的Link是一种重量级连接。通过Pod将多个容器组合在一个虚拟的主机内，可以通过Localhost就能通信。</li>
<li>一个Pod中的应用容器共享同一组资源：<ol>
<li>PID命名空间：Pod中的不同应用程序可以看到其他应用程序的进程ID;</li>
<li>网络命名空间：Pod中的多个容器能够访问同一个IP和端口范围；</li>
<li>IPC命名空间：Pod中的多个容器能够使用SystemV IPC或者POSIX消息队列进行通信；</li>
<li>UTS命名空间：Pod中的多个容器共享一个主机名；</li>
<li>Volumes（共享存储卷）:pod中的各个容器可以访问在Pod级别定义的Volumes。</li>
</ol>
</li>
<li>Pod定义通过Yml或者json格式配置文件来完成。</li>
<li>Pod的生命周期是通过Replication Controller来管理的。Pod的生命周期过程包括:在模板进行定义，然后分到Node上运行，在Pod所含容器运行结束后Pod也结束。在整个过程中，Pod处于一下4种状态之一：<ol>
<li>Pending:Pod定义正确，提交Master，但其包含的容器镜像还未完全创建。通常Master对Pod进行调度需要一些时间，之后Node对镜像进行下载也需要一些时间。</li>
<li>Running:Pod已被分配到某个Node上，但其包含的所有容器镜像都已经创建完成，并成功运行起来。</li>
<li>Suceeded:Pod中所有所有容器都成功结束，并且不会重启，这是Pod最终状态。</li>
<li>Failed:Pod中所有容器都结束了，但至少一个容器以失败状态结束的，这是Pod的一种最终状态。</li>
</ol>
</li>
</ol>
</li>
<li>Label(标签)<ol>
<li>Label以key/value键值对的形式附加到各种对象上，如Pod,Service,RC,Node等。Label定义了这些对象的可识别属性，用来对它们进行管理和选择。Label可以在创建对象时附加到对象上，也可以在对象创建后通过API进行管理。</li>
<li>在为对象定义好Label后，其他对象就可以使用Label Selector选择器来定义其作用的对象。<br> “Labels”:{<pre><code>&quot;key1&quot;:&quot;value1&quot;,
&quot;key2&quot;:&quot;value2&quot;
</code></pre> }    </li>
<li>Label Selector时，看作SQL查询语句种的where查询条件的语法。<br>5.Replication Controller(RC)</li>
<li>用于定义Pod副本的数量。在Master内，Controller Manager进行通过RC的定义来完成Pod的创建，监控，启停等操作。</li>
</ol>
</li>
<li>Service<ol>
<li>Pod都会分配一个单独的IP地址，但是会随着Pod的销毁而消失。如果一组Pod组成一个集群来提供服务，如何访问；</li>
<li>一个Service可以看作一组提供相同服务的Pod对外访问接口。Service作用于那些Pod是通过Label Selector来定义的。</li>
<li>Pod的IP地址和Service的Cluster的IP地址<ol>
<li>Pod的IP地址是Docker Daemon根据docker0网桥的IP地址段进行分配的，但是Service的ClusterIP地址是K8s系统种的虚拟IP地址，由系统动态分配。service的ClusterIP地址相对于Pod的IP地址来说相对稳定，Service被创建时被分配一个IP地址，销毁该Service之前，这个IP地址都不会再变化了。Pod在K8S集群中生命周期较短，ReplicationController销毁，再次创建，会分配一个新的IP地址。</li>
</ol>
</li>
<li>外部访问Service<ol>
<li>Service对象在ClusterIPRange池中分配的IP只能在内部访问，所以其他Pod都可以无障碍地访问到它。如果这个Service作为前端服务，准备为集群外的客户端提供服务，就需要分配公共IP;</li>
<li>K8S支持两种对外提供服务的Service的type定义:NodePort和LoadBalancer</li>
<li>NodePort</li>
<li>LoadBalancer</li>
</ol>
</li>
</ol>
</li>
<li>Volume(存储卷)<ol>
<li>Volume是Pod中能够被多个容器访问的共享目录。K8S的Volume概念与Docker的Volume比较类似。</li>
<li>Volume类型<ol>
<li>EmptyDir:一个EmptyDir Volume是在Pod分配到Node时创建得。从它的名称就可以看出，初始为空。同一个Pod中所有容器可以读些EmptyDir中得相同文件。当Pod从Node上移除时，EmptyDir中得数据也会永久被删除。<ol>
<li>用途:临时空间，例如用于某些应用程序运行时所需得临时目录，且无须永久保留。长时间任务的中间过程CheckPoint临时保存目录。一个容器需要从另一个容器中获取数据的目录。</li>
<li>tmpfs</li>
</ol>
</li>
<li>hostPath:在Pod上挂载宿主机上的文件或目录。<ol>
<li>容器应用程序生成的日志文件需要永久保存</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>Namespace<ol>
<li>Namespace是k8s系统中另一个非常重要的概念，通过将系统内部的对象分配到不同的Namespace中，形成逻辑上分组的不同项目，小组，用户组，便于不同的分组在共享使用整个集群的同时还能被分别管理。</li>
</ol>
</li>
<li>Annotation</li>
</ol>
</li>
<li>K8S总体架构<ol>
<li>k8s集群由两类节点组成:Master和Node,Master上运行etcd,API Server,Controller Manager和Scheduler四个组件，后三个组件构成了K8S的总控中心，负责对集群中所有资源进行管控和调度。</li>
<li>在每个Node上运行Kubelet,Proxy和Docker Daemon三个组件，负责对本节点上的Pod的生命周期进行管理，以实现服务代理的功能。</li>
<li>所有节点上都可以运行Kubectl命令行工具，提供了K8S的集群管理工具集。</li>
<li>etcd是高可用的key/value存储系统，用于持久化存储集群中所有的资源对象，如Node,Service,Pod,RC,Namespace等。API Server则提供了操作etcd的封装接口API，以Rest方式提供服务，这些API基本上都是集群中资源对象的增删改查及监听资源变化的接口，如创建Pod,创建RC,监听Pod的变化等接口。API Server是连接其他所有服务组件的枢纽。</li>
<li>RC与相关Service创建完整流程<ol>
<li>通过Kubectl提交一个创建RC的请求，该请求通过APIServer被写入etcd;</li>
<li>此时Controller Manager通过API Server的监听资源变化的接口监听到这个RC事件，分析之后，发现当前集群中没有Pod实例。</li>
<li>于是根据RC的Pod模板定义生成一个Pod对象，通过API Server写入etcd中，接下来此事件被Scheduler发现，执行一个复杂的调度流程，为这个新的Pod选定一个落户的Node，这个过程称为绑定（Pod Binding）。</li>
<li>通过API Server将这一结果写入到etcd中，随后目标Node上运行的Kubelet进程通过API Server检测到这个新生的Pod并按照定义，启动改Pod并负责其下半生，直到Pod的生命走到尽头。</li>
<li>通过Kubetcl提交一个映射到该Pod的Service的创建请求，Controller Manager会通过Label标签查询到相关联的Pod实例，然后生成Service的EndPoints信息并通过API Server写入到etcd中。</li>
<li>接下来所有Node上运行的Proxy进程通过API Server查询并监听Service对象与其对应的Endpoints信息，建立一个软件方式负载均衡器来实现service访问到后端Pod的流量转发功能。</li>
</ol>
</li>
<li>组件的功能<ol>
<li>API Server:提供了资源对象的唯一操作入口，其他所有组件都必须通过它提供的API来操作资源数据，通过相关的资源数据”全量查询”+”变化监听”，这些组件可以实时地完成相关业务功能，如某个新的Pod一旦被提交到API Server中，C M就会立即发现并开始调度。</li>
<li>Controller Manager:集群内部的管理控制中心，其主要目的是实现K8S集群自动检测和恢复的自动化工作，比如根据RC的定义完成Pod的复制或移除，以确保Pod实例数符合RC副本的定义；根据Service与Pod的管理关系，完成服务的EndPoints对象的创建和更新；其他诸如Node的发现，管理和状态监控，死亡容器所占磁盘空间及本地缓存的镜像文件的清理工作也是由Controller Manager完成的。</li>
<li>Scheduler:集群的调度器，负责Pod在集群节点中的调度分配。</li>
<li>Kubelet:负责本Node节点上的Pod创建，修改，监控，删除等全生命周期管理，同事Kubelet定时上报本节点的状态信息到API Server里。</li>
<li>Proxy:实现了Service的代理及软件模式的负载均衡器。</li>
<li>客户端通过Kubectl命令行工具或Kubetcl Proxy来访问K8S系统，在K8S集群内部的客户端可以直接使用Kubetcl命令管理集群。Kubectl Proxy是APIServer的一个反向代理，在K8s集群外部的客户端可以通过Kubectl Proxy来访问API Server。</li>
<li>API Server内部有一套完备的安全机制，包括认证，授权，以及准入控制等相关模块，APIServer在收到Rest请求后，会首先执行认证授权和准入控制的相关逻辑，过滤掉非法请求，然后将请求发送给API Server中的REST服务模块去执行资源的具体操作逻辑。</li>
<li>Node节点运行的K8S服务内嵌了一个cAdvisor服务，用于实时监控Docker上运行的容器指标。</li>
</ol>
</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/25/设计模式系列之设计模式基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/25/设计模式系列之设计模式基础/" itemprop="url">
                  设计模式系列之设计模式基础
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-09-25 20:05:09" itemprop="dateCreated datePublished" datetime="2018-09-25T20:05:09+08:00">2018-09-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-09-27 15:52:50" itemprop="dateModified" datetime="2018-09-27T15:52:50+08:00">2018-09-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-设计模式"><a href="#1-设计模式" class="headerlink" title="1. 设计模式"></a>1. 设计模式</h2><pre><code>在软件开发中，经过验证的，用于解决特定环境下，重复出现的、特定问题的解决方案。
</code></pre><p><strong>看完后思考，思考后应用，然后再看，再思考，再应用。</strong></p>
<h2 id="2-常见设计模式"><a href="#2-常见设计模式" class="headerlink" title="2.常见设计模式"></a>2.常见设计模式</h2><ol>
<li>简单工厂</li>
<li>外观模式</li>
<li>适配器模式</li>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
<li>抽象工厂模式</li>
<li>生成器模式</li>
<li>原型模式</li>
<li>中介者模式</li>
<li>代理模式</li>
<li>观察者模式</li>
<li>命令模式</li>
<li>迭代器模式</li>
<li>组合模式</li>
<li>模板方法模式</li>
<li>策略模式</li>
<li>状态模式</li>
<li>备忘录模式</li>
<li>亨元模式</li>
<li>解释器模式</li>
<li>装饰模式</li>
<li>职责链模式</li>
<li>桥接模式</li>
<li>访问者模式</li>
</ol>
<p>##3. 讲述结构  ##</p>
<ol>
<li>场景问题<ol>
<li>某个实际应用</li>
<li>不用模式的解决方案</li>
<li>存在问题</li>
</ol>
</li>
<li>解决方案<ol>
<li>某个模式来解决</li>
<li>模式结构和说明</li>
<li>模式的实例代码</li>
<li>使用模式来重写示例</li>
</ol>
</li>
<li>模式讲解<ol>
<li>认识某个模式</li>
<li>针对各个重点难点功能，实际应用结合的讨论和示例</li>
<li>模式的优缺点</li>
<li>思考模式</li>
<li>相关模式</li>
</ol>
</li>
</ol>
<p>++++++============================++++++++</p>
<h2 id="第二章-简单工厂"><a href="#第二章-简单工厂" class="headerlink" title="第二章 简单工厂"></a>第二章 简单工厂</h2><p>-相关：单例，原型，生成器模式</p>
<h3 id="1-场景问题"><a href="#1-场景问题" class="headerlink" title="1. 场景问题"></a>1. 场景问题</h3><pre><code>1. 接口回顾
2. 接口用处
3. 接口思想
4. 接口好处
5. 接口和抽象类
    1. 优先使用接口
    2. 既要定义子类的行为，又要具有公共的功能时使用抽象类
</code></pre><h3 id="2-面向接口编程"><a href="#2-面向接口编程" class="headerlink" title="2.面向接口编程"></a>2.面向接口编程</h3><p>1.分层<br>    表现层 逻辑层 数据层<br>2.接口是被其隔离部分的外观:通过接口来进行交互<br>3.组件:能完成一定功能得封装体。小到一个类，大到一个系统，都可以称为组件，一个小的系统放到更大的系统里面去，就是充当一个组件的作用。系统，子系统，模块，组件是一个概念，都是一定功能的封装体。</p>
<h3 id="3-不同模式的解决方案"><a href="#3-不同模式的解决方案" class="headerlink" title="3.不同模式的解决方案"></a>3.不同模式的解决方案</h3><ol>
<li>定义一个API，然后一个实现类Impl，客户端调用这个接口的实例。</li>
<li>客户端只知道接口，不知道实现。<h3 id="4-解决方案"><a href="#4-解决方案" class="headerlink" title="4.解决方案"></a>4.解决方案</h3></li>
<li>简单工厂：提供一个创建对象实例的功能，无须关心具体实现。被创建实例的类型可以是接口，抽象类，也可以是具体的类。</li>
<li>应用简单工厂来解决问题的思路:在内部新建一个类，在里面来创建接口，然后把创建好的接口返回给客户端，外部应用通过这个类就获取相应的接口，然后就可以操作相应的方法，这个对象就叫做简单工厂。</li>
<li>可配置的简单工厂<h3 id="5-优缺点"><a href="#5-优缺点" class="headerlink" title="5.优缺点"></a>5.优缺点</h3></li>
<li>简单工厂的优点<ol>
<li>帮助封装</li>
<li>解耦</li>
</ol>
</li>
<li>缺点<ol>
<li>增加客户端的复杂度</li>
<li>不方便扩展子工厂<h3 id="6-思考简单工厂"><a href="#6-思考简单工厂" class="headerlink" title="6.思考简单工厂"></a>6.思考简单工厂</h3></li>
</ol>
</li>
<li>本质:选择实现，重点是实现已经做好了，就算实现简单，也要有具体的实现类。</li>
<li>何时选用简单工厂:完全封装隔离具体实现，让外部只能通过接口来操作封装体。如果想要把创建对象的职责集中管理和控制，选用简单工厂。</li>
</ol>
<p>==================++++++++++++++++++++++=====================</p>
<h2 id="第三章-外观模式-Facade"><a href="#第三章-外观模式-Facade" class="headerlink" title="第三章. 外观模式(Facade)"></a>第三章. 外观模式(Facade)</h2><ol>
<li>解决方案<ol>
<li>界面和接口：为子系统种的一组接口提供一个一直的界面，Facade模式定义了一个高层接口，接口使得这一子系统更加容易使用。</li>
<li>界面—&gt;组件</li>
<li>外观模式就是通过引入这么一个外观类，在这个类里面定义客户端想想要的方法，然后在这些方法的实现里面，由外观类再去分别调用内部的多个模块来实现功能，从而让客户端变得简单。</li>
</ol>
</li>
<li>结构和说明<ol>
<li>Facade:定义子系统的多个模块对外高层接口，通常需要调用内部多个模块，从而把客户端的请求代理给适当的子系统对象。 </li>
<li>模块:接受Facade对象的委派，真正实现功能，各个模块之间会有交互<br>3.理解</li>
<li>目的:不是为了让外部减少与子系统内多个模块的交互，松散耦合，让外不能更简单地使用子系统。</li>
<li>方便客户端调用，封装了系统的内部细节功能。功能的复用。减少了学习成本。</li>
<li>外观模式可以实现成为一个单例，接口。</li>
</ol>
</li>
</ol>
<p>======================++++++++++++++++++++++++================</p>
<h2 id="第四章-适配器模式-Adapter"><a href="#第四章-适配器模式-Adapter" class="headerlink" title="第四章 适配器模式(Adapter)"></a>第四章 适配器模式(Adapter)</h2><ol>
<li>解决方案<ol>
<li>将一个类的接口转换成客户端希望的另一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li>
<li>定义一个类来实现第二版接口，在实现的时候转调第一版的功能，这样通过<strong>对象组合</strong>的方式，复用第一版已有的功能，同时又满足第二版调用的要求。</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/06/算法系列之源初/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/06/算法系列之源初/" itemprop="url">
                  算法系列之源初
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-09-06 08:53:52 / Updated at: 14:32:36" itemprop="dateCreated datePublished" datetime="2018-09-06T08:53:52+08:00">2018-09-06</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="3-基本算法思想"><a href="#3-基本算法思想" class="headerlink" title="3. 基本算法思想"></a>3. 基本算法思想</h2><ol>
<li>算法可以帮助用户清理问题的头像，更快地解决问题。</li>
<li>常用的算法：<ol>
<li>穷举</li>
<li>递推</li>
<li>递归</li>
<li>分治</li>
<li>概率<h3 id="3-1-穷举"><a href="#3-1-穷举" class="headerlink" title="3.1 穷举"></a>3.1 穷举</h3></li>
</ol>
</li>
<li>穷举基本思想===无规律场景 <ol>
<li>穷举的基本思想就是从所有可能的情况中搜索正确的答案，执行步骤：<ol>
<li>对于一种可能的结果，计算其结果；</li>
<li>判断结果是否满足要求，如果不满足继续执行（1）步来搜索下一个可能的情况；如果满足结果，则表示找到正确答案。</li>
</ol>
</li>
<li>使用穷举算法时，需要明确问题的答案范围，在指定范围内搜索答案。指定范围后，使用循环语句和条件判断语句逐步验证候选答案的正确性，从而得到正确答案</li>
</ol>
</li>
<li>实例<h3 id="3-2-递推"><a href="#3-2-递推" class="headerlink" title="3.2 递推"></a>3.2 递推</h3></li>
<li>递推基本思想===有规律场景<ol>
<li>理性思维的代表，根据已有数据和关系，逐步推导而得到结果。递推算法如下:<ol>
<li>根据已知结果和关系，求解中间结果。</li>
<li>判定是否达到要求，如果没达到，则根据已知结果和关系求解中间结果;如果满足要求则表示找到一个正确答案。<br>2.问题和答案的关系。</li>
</ol>
</li>
</ol>
</li>
<li>实例<ol>
<li>斐波那契算法<h3 id="3-3-递归"><a href="#3-3-递归" class="headerlink" title="3.3 递归"></a>3.3 递归</h3></li>
</ol>
</li>
<li>递归基本思想<ol>
<li>递归算法就是在程序中不断反复调用自身来达到求解问题的方法。要求待求解的问题能够分解为相同问题的一个子问题。</li>
<li>递归调用是一个方法在其方法体内调用自身的方法调用方式。</li>
<li>分类：直接递归，间接递归</li>
<li>编写递归方法时，必须使用if语句强制方法在未执行递归调用前返回。否则永不返回。</li>
</ol>
</li>
<li>实例<h3 id="3-4-分治"><a href="#3-4-分治" class="headerlink" title="3.4 分治"></a>3.4 分治</h3></li>
<li>分治基本思想<ol>
<li>分支问题就是将计算复杂的问题分为规模较小，计算简单的小问题求解，然后综合各个小问题，而得到最终的答案。</li>
<li>过程:<ol>
<li>对于一个规模为N的问题，若该问题可以轻松解决，则直接解决；否则执行以下步骤。</li>
<li>将该问题分解为M个规模较小的自问题，这些子问题相互独立，并且与原问题形式相同。</li>
<li>递归地解这些自问题。</li>
<li>将子问题的解合并得到最终的答案。</li>
</ol>
</li>
</ol>
</li>
<li>实例:寻找假币<h3 id="3-5-概率"><a href="#3-5-概率" class="headerlink" title="3.5 概率"></a>3.5 概率</h3></li>
</ol>
<h2 id="4-排序算法"><a href="#4-排序算法" class="headerlink" title="4. 排序算法"></a>4. 排序算法</h2><p> 排序算法概述</p>
<pre><code>1. 基本的交换排序，选择排序，插入排序，合并排序。
2. 交换排序:冒泡排序和快速排序
3. 选择排序:选择排序和堆排序
4. 插入排序
5. 多路归并排序
</code></pre><h3 id="4-1-冒泡排序"><a href="#4-1-冒泡排序" class="headerlink" title="4.1 冒泡排序"></a>4.1 冒泡排序</h3><p>核心代码:</p>
<pre><code>for(int i = 0;i&lt;arr.length;i++) 
{     
    for(int j = 0;j &lt;arr.length-i;j++) {
        if(arr[j] &gt; arr[j+1]) {
            int temp = arr[j];            
            arr[j] = arr[j+1];
            arr[j+1] = temp;            
        }
    }    
}
</code></pre><h3 id="4-2-选择排序"><a href="#4-2-选择排序" class="headerlink" title="4.2 选择排序"></a>4.2 选择排序</h3><ol>
<li>首先从原始数组中选择最小的1个数据，将其和位于第一个位置的数据交换；</li>
<li>接着从剩下的n-1个数据中选择次小的元素，将其和第2个位置数据交换；</li>
<li>不断重复直到最后两个数据完成交换。    </li>
<li>核心代码    </li>
</ol>
<pre><code>for(int i =0;i&lt;a.length-1;i++) {
    int    index = i;
    for(int j=i+1;j&lt;a.length;j++) {
        if(a[j] &lt; a[index]) {
            index = j;            
        }        
    }
    if(index != i) {

    }
} 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/04/Docker系列之入门介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/04/Docker系列之入门介绍/" itemprop="url">
                  Unbenannt
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-09-04 16:09:26" itemprop="dateCreated datePublished" datetime="2018-09-04T16:09:26+08:00">2018-09-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-09-06 14:32:40" itemprop="dateModified" datetime="2018-09-06T14:32:40+08:00">2018-09-06</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title: Docker系列之入门介绍<br>date: 2018-09-04 16:09:26<br>tags: Docker</p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><pre><code>1. 镜像
2. 容器
3. 仓库 
</code></pre><h2 id="2-Docker镜像"><a href="#2-Docker镜像" class="headerlink" title="2.Docker镜像"></a>2.Docker镜像</h2><pre><code>1. 操作系统分为内核和用户空间。对于linux而言内核启动后，会挂载root文件系统为其提供用户空间支持。而Docker镜像，就相当于一个root文件系统。
2. 分层存储
</code></pre><h2 id="3-Docker容器"><a href="#3-Docker容器" class="headerlink" title="3.Docker容器"></a>3.Docker容器</h2><pre><code>1. 镜像和容器就像的类和实例。
2. 拉取镜像:docker pull [地址] [仓库名]
3. 启动容器:docker run --it --rm [地址+仓库名]
4. 列出镜像:docker images
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/09/03/Dubbo系列之Dubbo可扩展性SPI/" itemprop="url">
                  Dubbo系列之Dubbo可扩展性SPI
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-09-03 10:07:36" itemprop="dateCreated datePublished" datetime="2018-09-03T10:07:36+08:00">2018-09-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-09-04 18:03:11" itemprop="dateModified" datetime="2018-09-04T18:03:11+08:00">2018-09-04</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-Dubbo扩展机制"><a href="#1-Dubbo扩展机制" class="headerlink" title="1. Dubbo扩展机制"></a>1. Dubbo扩展机制</h2><ul>
<li>任何系统都是从小系统不断完善的，应当关注当下的需求，然后不断对系统进行迭代。</li>
<li>代码层面，需要适当的对关注点进行抽象和隔离，在不断添加和特性时，仍然能保持良好的结构和可维护性，同时允许第三方开发者对其功能及进程扩展。</li>
<li>对扩展性的追求甚至超过了性能。</li>
<li>良好的扩展性<ul>
<li>作为框架的维护这，在添加新功能的时候，只需要添加一些新的代码，而不用大量修改现有代码，符合开闭原则</li>
<li>作为框架的使用者，在添加一个新功能时，不需要去修改框架源码，在自己工程中添加代码即可。<h2 id="2-可扩展的集中解决方案"><a href="#2-可扩展的集中解决方案" class="headerlink" title="2. 可扩展的集中解决方案"></a>2. 可扩展的集中解决方案</h2></li>
</ul>
</li>
<li>通常有：<ul>
<li>Factory模式</li>
<li>IoC容器</li>
<li>OSGI容器</li>
</ul>
</li>
<li>Dubbo参考了Java原生的SPI机制，并进行一定扩展，以满足Dubbo需求。<h2 id="3-Java-SPI机制"><a href="#3-Java-SPI机制" class="headerlink" title="3. Java SPI机制"></a>3. Java SPI机制</h2></li>
</ul>
<ol>
<li>Java SPI(Service Provider Interface)是JDK一种动态加载扩展点的实现。</li>
<li>在ClassPath的META-INF/services目录下放置一个接口同名的文本文件，内容为接口的实现类，多个实现类用换行符分割。</li>
<li>缺点：<ul>
<li>需要遍历所有的实现，并实例化，然后才能在循环中找到我们需要的实现。</li>
<li>配置文件中只是需要简单的列出所有扩展实现，没有命名，很难定位。</li>
<li>扩展如果依赖其他扩展就做不到自动注入和装配。</li>
<li>不提供类似于Spring IOC和AOP功能。</li>
<li>很难和其他框架集成。<h2 id="4-Dubbo扩展点机制"><a href="#4-Dubbo扩展点机制" class="headerlink" title="4. Dubbo扩展点机制"></a>4. Dubbo扩展点机制</h2></li>
</ul>
</li>
<li>扩展点—Java接口</li>
<li>扩展—扩展点的实现类</li>
<li>扩展实例—扩展点实现类的实例</li>
<li>扩展自适应实例—扩展代理类</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/29/微服务系列之深入理解SpringCloud与微服务构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/29/微服务系列之深入理解SpringCloud与微服务构建/" itemprop="url">
                  微服务系列之深入理解SpringCloud与微服务构建
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-29 16:25:35" itemprop="dateCreated datePublished" datetime="2018-08-29T16:25:35+08:00">2018-08-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-08-31 18:51:17" itemprop="dateModified" datetime="2018-08-31T18:51:17+08:00">2018-08-31</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="序"><a href="#序" class="headerlink" title="序"></a>序</h3><ol>
<li>系统的架构决定了系统能否满足业务，技术，组织，灵活，可扩展性等多种要求，同时肩负起了解放程序员生产力的作用。</li>
<li>微服务框架:服务注册和发现===Eureka组件，负载均衡Ribbon组件，熔断器Hystrix组件，路由网关Zuul组件，SpringCloud配置中心，服务链路追踪等内容。</li>
<li>微服务提出者Martin Fowler<h2 id="第2章-SpringCloud简介"><a href="#第2章-SpringCloud简介" class="headerlink" title="第2章 SpringCloud简介"></a>第2章 SpringCloud简介</h2><h3 id="2-1-微服务应该具备的功能"><a href="#2-1-微服务应该具备的功能" class="headerlink" title="2.1 微服务应该具备的功能"></a>2.1 微服务应该具备的功能</h3></li>
<li>服务:一个独立运行的单元组件，每个单元组件运行在独立的进程中，组件与组件之间通常使用HTTP的通信机制进行通信。</li>
<li>微服务的特点:<ol>
<li>按照业务来划分服务，单个服务代码量小，业务单一，易于维护；</li>
<li>每个微服务都有自己独立的基础组件，如数据库，缓存，且运行在独立的进程中；</li>
<li>微服务之间的通信通过Http协议或者消息组件，且具有容错能力；</li>
<li>微服务有一套服务治理的解决方案，服务之间不耦合，可以随时加入和剔除服务；</li>
<li>单个微服务能够集群化部署，并且负载均衡能力；</li>
<li>整个微服务系统有一个完整的安全机制，包括用户验证，权限验证，资源保护等；</li>
<li>链路追踪的能力；</li>
<li>完整的实时日志系统。<h3 id="2-1-1-服务的注册与发现"><a href="#2-1-1-服务的注册与发现" class="headerlink" title="2.1.1 服务的注册与发现"></a>2.1.1 服务的注册与发现</h3></li>
</ol>
</li>
</ol>
<ul>
<li>服务粒度小，服务数量众多，服务之间相互依赖成网状，需要服务注册中心来同一管理微服务实例，方便查看每一个微服务实例的健康状态。</li>
<li>服务注册是指向服务注册中心注册一个服务实例，服务提供者将自己的服务信息(如服务名，IP地址等)告知服务注册中心。</li>
<li>服务发现是指当服务消费者需要消费另一个服务时，服务注册中心能够告知服务消费者它所要消费服务的实例信息（服务名，IP地址等）。</li>
<li>通常一个服务既是服务提供者也是服务消费者，使用Http协议或者消息组件进行服务费。</li>
<li>注册中心会提供服务的健康检查方案，检查被注册的服务是否可用。通常实例注册后，会定时向服务注册中心提供心跳，以表明自己还处于可用状态。当一个服务实例停止向服务注册中心提供心跳一段时间后，服务注册中心会认为该服务实例不可用，将会从服务注册列表中剔除。</li>
<li>如果这个被剔除掉的服务实例过一段时间重新加入服务器注册中心列表中，就重新恢复心跳。</li>
<li>微服务的服务注册组件都回提供服务的健康状况查看UI界面，通过界面可以指导服务的健康状态。<h3 id="2-1-2-服务的负载均衡"><a href="#2-1-2-服务的负载均衡" class="headerlink" title="2.1.2 服务的负载均衡"></a>2.1.2 服务的负载均衡</h3></li>
<li>微服务架构中，服务之间相互调用通过http通信协议来实现。网络往往不可靠，为了保证高可用，服务单元往往需要集群化部署。===&gt;引发负载均衡</li>
<li>服务消费者集成了负载均衡组件，该组件回向服务消费者提供获取的服务注册列表，并隔一段时间重新刷新该列表。</li>
<li>注册中心集群化。<h4 id="2-1-3-集群的容错"><a href="#2-1-3-集群的容错" class="headerlink" title="2.1.3 集群的容错"></a>2.1.3 集群的容错</h4></li>
<li>部分服务不可用，引发阻塞，消耗系统资源，引发雪崩。</li>
<li>解决方案：熔断机制<ol>
<li>当一个服务处理用户请求失败次数小于设定的阈值时，熔断器处于关闭状态，服务正常</li>
<li>当失败次数大于设定阈值时，说明服务出现了故障，打开熔断器，所有该服务的请求会执行快速失败，不执行业务逻辑。</li>
<li>当处于打开状态的熔断器时，一段时间后会处于半打开状态，并执行一定数量的请求，剩余的请求会执行快速失败，如果执行请求失败，则继续打开熔断器；若成功了，则将熔断器关闭。 </li>
</ol>
</li>
<li>熔断器的附加功能：<ol>
<li>将资源隔离，如果某个API出现故障，将该API隔离，不会影响其他API接口。被隔离的API接口会执行快速失败的逻辑，不会等待，请求不会阻塞。</li>
<li>服务降级功能。当服务处于正常状态时，大量请求在短时间内同时涌入，超过了服务的处理能力，这是熔断器打开可以将服务降级，以免服务器因负载过高而出现故障。</li>
<li>自我修复能力。比如网络短时间内不可用，熔断器被打开。如果不能自我监控，自我检测和自我修复，那么需要开发人员手动去关闭熔断器，会增加开发工作量。</li>
<li>Netfix的Hystrix熔断器组件功能非常强大，有熔断器功能，熔断器状态检测，UI，开发人员或者运维人员通过UI界面能够直观看到熔断器的状态和各种性能指标。<h4 id="2-1-4-服务网关"><a href="#2-1-4-服务网关" class="headerlink" title="2.1.4 服务网关"></a>2.1.4 服务网关</h4></li>
<li>微服务系统通过将资源以API接口的形式暴露给外界来提供服务。API接口资源通常是由服务网关统一暴露，内部服务不直接对外提供API资源暴露，将内部服务隐藏。</li>
<li>API网关通常有请求转发的作用，可能需要负责一定的安全验证，如请求是否合法，对某一资源是否具有操作权限等。</li>
<li>通常网关层以集群形式存在，在服务网关层之前，会加上负载均衡层，通常为nginx双机热备，通过一定路由策略，将请求转发到网管层。</li>
<li>到达网关层后，经过一系列用户身份验证，权限判断，最终转发到具体的服务。</li>
<li>服务经过一些列的逻辑运算和数据操作，最终将结果返回给用户。</li>
<li>网关层的意义：<ol>
<li>网关将所有的API接口资源统一聚合，对外统一暴露，外界系统调用的API接口都是网关对外暴露的API接口。</li>
<li>身份认证，权限认证，防止非法请求操作API接口，对内部服务起保护作用。</li>
<li>网关可以实现监控功能，实时日志输出，对请求进行记录。</li>
<li>网关可以用来做流控，在流量情况下，对服务进行降级。</li>
<li>API接口从内部服务分离出来，方便测试。<h4 id="2-1-5-服务配置的统一管理"><a href="#2-1-5-服务配置的统一管理" class="headerlink" title="2.1.5 服务配置的统一管理"></a>2.1.5 服务配置的统一管理</h4></li>
</ol>
</li>
<li>数据库配置，日志是输出级别配置，不同环境不一样，管理复杂。</li>
<li>SpringCloud的Config组件，阿里Diamond，百度Disconf，携程Apollo等。</li>
<li>大致过程：<ol>
<li>Config Server读取配置文件仓库的配置信息，其中配置文件存放在配置服务的本地仓库，也可以放在远程Git仓库。</li>
<li>配置服务启动后，读取配置文件信息，读取完成配置信息存放在配置服务的内存中。</li>
<li>当启动服务A,B是，由于服务A，B指定了向配置服务读取配置信息，服务A，B向配置服务读取配置信息。</li>
<li>当服务配置信息需要修改且修改完成后，向配置服务发送Post请求进行刷新，这时服务A,B会向配置服务重写读取配置文件。<h4 id="2-1-6-服务链路追踪"><a href="#2-1-6-服务链路追踪" class="headerlink" title="2.1.6 服务链路追踪"></a>2.1.6 服务链路追踪</h4></li>
</ol>
</li>
<li>服务单元数量多且复杂，服务与服务之间的调用非常复杂，出现异常和错误很难追踪；</li>
<li>实现分布式链路追踪，去跟进一个请求到底有哪些服务参与，参与的顺序，使得每个请求链路清晰可见，方便问题定位。<h3 id="2-2-Sprin-Cloud"><a href="#2-2-Sprin-Cloud" class="headerlink" title="2.2 Sprin Cloud"></a>2.2 Sprin Cloud</h3></li>
<li>基于SpringBoot—&gt;简化开发和部署的过程，简化Spring复杂的配置和依赖管理；</li>
<li>通过起步依赖和内置Servlet容器就能快速搭建起一个Web工程。 </li>
<li>SpringCloud首要目标是通过一些列开发组件和框架，快速搭建分布式微服务系统。<h4 id="2-2-1-常用组件"><a href="#2-2-1-常用组件" class="headerlink" title="2.2.1 常用组件"></a>2.2.1 常用组件</h4><h3 id="2-3-Dubbo"><a href="#2-3-Dubbo" class="headerlink" title="2.3 Dubbo"></a>2.3 Dubbo</h3></li>
<li>RPC调用:封装了长连接NIO框架，采用多线程模式；</li>
<li>集群容错：提供了基于接口方法的远程调用功能。集群容错:实现了负载均衡，失败容错；服务发现:集成了Zookeeper,用于服务注册和发现。</li>
<li>SpringCloud通信方式基于http restful风格，服务与服务之间五耦合，无状态，语言平台普适。</li>
<li>Dubbo基于远程调用，对接口平台和语言有强依赖。跨平台调用更需要额外依赖。 <h3 id="2-4-Kubernetes简介"><a href="#2-4-Kubernetes简介" class="headerlink" title="2.4 Kubernetes简介"></a>2.4 Kubernetes简介</h3>1.Kubernetes是一个容器集群管理系统，为容器化的应用程序提供部署运行，维护，扩展，资源调度，服务发现等功能呢。</li>
</ol>
</li>
</ul>
<h2 id="3-构建微服务的准备"><a href="#3-构建微服务的准备" class="headerlink" title="3.构建微服务的准备"></a>3.构建微服务的准备</h2><h3 id="3-3-构建啊工具Maven使用"><a href="#3-3-构建啊工具Maven使用" class="headerlink" title="3.3 构建啊工具Maven使用"></a>3.3 构建啊工具Maven使用</h3><pre><code>1. 基于工程对象模型，Maven可以管理项目构建整个生命周期，包括清理，编译，打包，测试等环节。
2. 构建一个项目需要的流程：
    1. 生成源码； 2. 从源码中生存文档；3.编译源码；4.测试；5.将源码打包成Jar,运行在服务器，仓库或者其他位置。
</code></pre><h4 id="3-3-1-Maven核心概念"><a href="#3-3-1-Maven核心概念" class="headerlink" title="3.3.1 Maven核心概念"></a>3.3.1 Maven核心概念</h4><pre><code>1. 核心是pom文件，pom文件以及xml文件的形式表示的资源，依赖jar,插件，构建文件等。
2. 工作过程：
    1. Maven 读取pom文件，构建的生命周期各阶段和目标；
    2. 依赖---&gt;Maven本地仓库；
    3. 构建插件
    4. 构建Profile
3. 首先读取pom文件，pom文件时Maven核心，所有的项目依赖，插件都在pom文件中统一管理。
4. 下载依赖jar到本地仓库。Maven命令执行时，首先会检查pom文件的依赖jar，当检测本地没有安装jar时，会默认Maven的中央仓库下载依赖Jar，中央仓库地址为:/.
5. 依赖下载后，会存放在本地仓库中，如果下载不成功，该命令无法执行通过。
6. 执行构建的生命周期。Maven的构建过程会被分解成构建阶段和构建目标，共同构成了Maven的生命周期。
7. 执行构建插件。插件可以更方便地执行构建各个阶段，可以用插件实现一些额外功能。
</code></pre><h4 id="3-3-2-编写Pom文件"><a href="#3-3-2-编写Pom文件" class="headerlink" title="3.3.2 编写Pom文件"></a>3.3.2 编写Pom文件</h4><pre><code>1. pom文件是一个xml文件，用于描述项目用到的资源，项目依赖，插件，代码位置等信息。
2. pom.xml文件一般放在根目录。
</code></pre><h4 id="3-3-3-Maven构建项目的生命周期"><a href="#3-3-3-Maven构建项目的生命周期" class="headerlink" title="3.3.3 Maven构建项目的生命周期"></a>3.3.3 Maven构建项目的生命周期</h4><pre><code>1. Maven工程中，默认定义了构建工程的生命周期，本身集成了这些插件。
2. validate initialize compile test package verify install deploy
</code></pre><h4 id="3-3-4-常用Maven命令"><a href="#3-3-4-常用Maven命令" class="headerlink" title="3.3.4 常用Maven命令"></a>3.3.4 常用Maven命令</h4><pre><code>1. mvn clean 删除工程target下所有文件；
2. mvn package将工程打为jar包
3. 上述由一些列命令构成：
    1. 验证verify
    2. 编译compile
    3. 处理代码
    4. 生成资源文件
    5. 生成Jar包
    6. 测试
4. mvn package -Dmaven.test.ship=ture，打包跳过测试；
5. mvn compile 编译代码工程，不生成jar包；
6. mvn install 包含了mvn package的所有过程，并且将生成的jar包安装到本地仓库。
7. mvn spring-boot:run 使用spring-boot插件，启动Springboot工程；
8. mvn test 测试；
9. mvn idea:idea 生成idea项目
10. mvn mvnLjar只打jar包
11. mvn vaildate 检验资源是否可用。
</code></pre><h2 id="4-Spring-Boot"><a href="#4-Spring-Boot" class="headerlink" title="4.Spring Boot"></a>4.Spring Boot</h2><pre><code>1. 特点：自动配置，起步依赖，Actuator对运行状态的监控。
2. 安全，度量，监控检查，内嵌Servlet容器，外置设置
</code></pre><h3 id="4-1-构建SpringBoot项目"><a href="#4-1-构建SpringBoot项目" class="headerlink" title="4.1 构建SpringBoot项目"></a>4.1 构建SpringBoot项目</h3><pre><code>1. @SpringBootApplication注解包含了@SpringBootConfiguration,@EnableAutoConfiguration和@    ComponentScan，开启包扫描配置和自动配置的功能；
2. @RestController = @Controller + @ResponseBody；
3. @RequestMapping = 配置请求地址的Url映射； 
4. 测试:
    1. @RunWith(SpringRunner.class) 和 SpringBootTest注解。
    2. @SpringBootTest注解加上Web测试环境的端口为随机端口的配置 
</code></pre><h3 id="4-2-SpringBoot-配置文件详解"><a href="#4-2-SpringBoot-配置文件详解" class="headerlink" title="4.2 SpringBoot 配置文件详解"></a>4.2 SpringBoot 配置文件详解</h3><h4 id="4-2-1-自定义属性"><a href="#4-2-1-自定义属性" class="headerlink" title="4.2.1 自定义属性"></a>4.2.1 自定义属性</h4><pre><code>1. 默认创建application.properties;同时也支持yml格式的文件；
2. 读取配置文件的值:在变量上加上@Value(&quot;${属性名}&quot;)；
</code></pre><h4 id="4-2-2-将配置文件的属性赋给实体类"><a href="#4-2-2-将配置文件的属性赋给实体类" class="headerlink" title="4.2.2 将配置文件的属性赋给实体类"></a>4.2.2 将配置文件的属性赋给实体类</h4><pre><code>1. 当有多个配置属性的时候，通常会把这些属性名创建一个JavaBean变量，并将属性值赋给JavaBean变量。
2. random.int 生成整型值，random.uuid生成一个uuid,random.value随机生成一个值，random.value(10)随机生成一个小于10整数。
3. 在一个Bean类上加一个注解@ConfigurationProperies,表明该类为配置属性类，并且加上配置的prefix,并且加上@Component注解。
</code></pre><h4 id="4-2-3-自定义配置文件"><a href="#4-2-3-自定义配置文件" class="headerlink" title="4.2.3 自定义配置文件"></a>4.2.3 自定义配置文件</h4><pre><code>1. 如在resource下自定义一个test.properties配置文件：
    com.my.name = rocky
    com.my.age = 23
2. 此时需要在类名上加上@Configuration,@PropertySource和@ConfigurationProperties这3个注解。
</code></pre><h3 id="4-3-运行状态监控Actuator"><a href="#4-3-运行状态监控Actuator" class="headerlink" title="4.3 运行状态监控Actuator"></a>4.3 运行状态监控Actuator</h3><h3 id="4-4-SpringBoot-整合JPA"><a href="#4-4-SpringBoot-整合JPA" class="headerlink" title="4.4 SpringBoot 整合JPA"></a>4.4 SpringBoot 整合JPA</h3><h3 id="4-5-SpringBoot-整合Redis"><a href="#4-5-SpringBoot-整合Redis" class="headerlink" title="4.5 SpringBoot 整合Redis"></a>4.5 SpringBoot 整合Redis</h3><pre><code>1. Redis简介
2. 加入redis依赖
</code></pre><h2 id="5-服务注册与发现Eureka"><a href="#5-服务注册与发现Eureka" class="headerlink" title="5.服务注册与发现Eureka"></a>5.服务注册与发现Eureka</h2><h3 id="5-1-源码解析Eureka"><a href="#5-1-源码解析Eureka" class="headerlink" title="5.1 源码解析Eureka"></a>5.1 源码解析Eureka</h3><pre><code>1. Register---服务注册
    当Eureka Client向Euerka Server注册时，Eureka Client提供自身的元数据，如IP地址，端口，运行状态指标Url,主页地址信息
2. Renew---服务续约
    Eureka Client每隔30秒发送一次心跳来进行服务续约。通过服务续约来告知Eureka Server该Eureka Client仍然可用，没有出现故障。正常情况下，如果Eureka Server在90s内没有收到Eureka Client的心跳，EurekaServer会将Eureka Client实例从注册列表中删除。
3. Fetch Registries---获取服务注册列表信息
    C从S获取服务注册表信息，并将其缓存在本地。C使用服务注册列表信息查找其他服务信息，从而进行RPC。该注册列表信息定时更新，每次返回与缓存可能不同，Eureka Client缓存信息不同，C会自己处理。注册信息不匹配时，C重新获取整个注册表信息。S缓存了所有服务的注册列表信息，并将整个注册列表以及每个应用程序的信息进行压缩，以Json和XML数据格式进行通信。默认使用Json方式来获取服务注册列表信息。

4. Cancel---服务下线
    C程序关闭时，向S发送下线请求。完成请求后，S将C从list删除。需要在程序关闭时调用方法。
5. Eviction---服务剔除
    连续90s没有向Eureka Server发送服务续约，就会将该S从服务注册列表删除。
</code></pre><h3 id="5-2-1-Eureka高可用架构"><a href="#5-2-1-Eureka高可用架构" class="headerlink" title="5.2.1 Eureka高可用架构"></a>5.2.1 Eureka高可用架构</h3><h3 id="5-2-2-Register服务注册"><a href="#5-2-2-Register服务注册" class="headerlink" title="5.2.2 Register服务注册"></a>5.2.2 Register服务注册</h3><h3 id="5-2-3-Renew服务续约"><a href="#5-2-3-Renew服务续约" class="headerlink" title="5.2.3 Renew服务续约"></a>5.2.3 Renew服务续约</h3><h2 id="6-负载均衡Ribbon"><a href="#6-负载均衡Ribbon" class="headerlink" title="6. 负载均衡Ribbon"></a>6. 负载均衡Ribbon</h2><h3 id="6-1-RestTemplate简介"><a href="#6-1-RestTemplate简介" class="headerlink" title="6.1 RestTemplate简介"></a>6.1 RestTemplate简介</h3><pre><code>1. 是SpringResources中的一个访问第三方Restful API接口的网络请求框架。目的都是为了执行复杂任务提供一个具有默认行为的简单方法。
2. RestTemplate是用来消费Rest服务的，所有方法都与Rest的Http协议的一些方法紧密相连。
</code></pre><h3 id="6-2-Ribbon简介"><a href="#6-2-Ribbon简介" class="headerlink" title="6.2 Ribbon简介"></a>6.2 Ribbon简介</h3><pre><code>1. 负载均衡方式:独立进程单元，通过负载均衡策略将请求转发到不同执行单元上，如Nginx；另一种是将负载均衡逻辑以代码形式封装到服务消费者的客户端上，C中维护了一份服务提供者信息列表，通过负载均衡策略将请求分摊给多个服务提供者，从而达到负载均衡的目的。
2. Ribbon采用第二种方式。有两种使用方式：一种是和RestTemplate结合，另一种是和Feign结合。默认与feign结合。
3. 源码解析
</code></pre><h2 id="7-声明式调用Feign"><a href="#7-声明式调用Feign" class="headerlink" title="7.声明式调用Feign"></a>7.声明式调用Feign</h2><h2 id="8-熔断器Hystrix"><a href="#8-熔断器Hystrix" class="headerlink" title="8.熔断器Hystrix"></a>8.熔断器Hystrix</h2><ol>
<li>分布式系统中，服务与服务之间的依赖错综复杂，一种不可避免的情况就是某些服务出现故障，导致依赖他们的其他服务出现远程调度的线程阻塞。Hystrix具有熔断器功能，能够阻止分布式系统中出现联动故障。Hystrix通过隔离服务访问点阻止联动故障，并提供故障解决方案，从而提高整个分布式系统的弹性。</li>
<li>高并发情况下，单个服务的延迟会导致整个请求都处于延迟状态，导致服务处于线程饱和状态，资源消耗殆尽。并且因为服务的依赖，导致其他服务也处于阻塞状态，引发雪崩。</li>
<li>Hystrix设计原则    <ol>
<li>防止单个服务的故障耗尽整个服务的Serlvet容器线程资源。</li>
<li>快速失败机制，如果单个服务出现故障，则调用服务的请求快速失败，而不是线程等待。</li>
<li>提供回退方案，在请求发生故障时，提供设定好的回退方案。</li>
<li>使用熔断机制，防止故障扩散到其他服务。</li>
<li>提供熔断器监控组件Hystrix Dashboard,实时监控熔断器状态。</li>
</ol>
</li>
<li>Hystrix工作机制</li>
</ol>
<h2 id="9-路由网关Spring-Cloud-Zuul"><a href="#9-路由网关Spring-Cloud-Zuul" class="headerlink" title="9.路由网关Spring Cloud Zuul"></a>9.路由网关Spring Cloud Zuul</h2><ol>
<li>用于构建边界服务，致力于动态路由，过滤，监控，弹性伸缩和安全。<h3 id="9-1-为什么需要Zuul"><a href="#9-1-为什么需要Zuul" class="headerlink" title="9.1 为什么需要Zuul"></a>9.1 为什么需要Zuul</h3><h3 id="9-2-Zuul工作原理"><a href="#9-2-Zuul工作原理" class="headerlink" title="9.2 Zuul工作原理"></a>9.2 Zuul工作原理</h3></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/28/微服务系列之源初/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/28/微服务系列之源初/" itemprop="url">
                  微服务系列之源初
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-28 11:10:23" itemprop="dateCreated datePublished" datetime="2018-08-28T11:10:23+08:00">2018-08-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-09-27 15:52:48" itemprop="dateModified" datetime="2018-09-27T15:52:48+08:00">2018-09-27</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote>
<p>近期安排主要路线：</p>
<ul>
<li>微服务-&gt;service mesh-&gt;dubbo相关源码<br></li>
<li>设计模式-&gt;主流框架设计模式总结</li>
<li>微服务系列主要以微服务设计+深入理解SpringCloud与微服务构建这两本书的读书笔记为主。</li>
</ul>
</blockquote>
<h1 id="微服务设计读书笔记"><a href="#微服务设计读书笔记" class="headerlink" title="微服务设计读书笔记"></a>微服务设计读书笔记</h1><h2 id="0-前言"><a href="#0-前言" class="headerlink" title="0. 前言"></a>0. 前言</h2><pre><code>微服务是一种分布式解决方案，推动细粒度服务的使用，这些服务协同工作，并且每个服务都有自己的生命周期。微服务主要围绕业务领域建模，所以避免了传统的分层架构引发的问题。避免了面向服务的架构中的陷阱。
</code></pre><h2 id="1-微服务"><a href="#1-微服务" class="headerlink" title="1.微服务"></a>1.微服务</h2><pre><code>i.领域驱动设计---用代码呈现真实世界的重要性。
ii.六边形架构理论---&gt;替代分层架构---&gt;更好的体现业务逻辑。借助虚拟化平台可以按需创建机器并且调整大小，借助基础设施自动化，可以从一台机器扩展到多台。
iii.领域驱动设计，持续交付，按需虚拟化，基础设施自动化，小型自治团队，大型集群系统---&gt;微服务诞生。
</code></pre><h3 id="1-1-什么是微服务"><a href="#1-1-什么是微服务" class="headerlink" title="1.1 什么是微服务"></a>1.1 什么是微服务</h3><blockquote>
<p>微服务就是一些协同工作的小而自治的服务。</p>
</blockquote>
<h4 id="1-1-1-很小专注于做好一件事"><a href="#1-1-1-很小专注于做好一件事" class="headerlink" title="1.1.1 很小专注于做好一件事"></a>1.1.1 很小专注于做好一件事</h4><ol>
<li>在一个单块系统内，通常会创建一些抽象层或者模块来保证代码的内聚性；内聚性是指将相关代码放一起，在考虑使用微服务的时候，<strong>内聚性很重要</strong>；</li>
<li>单一职责原则：把因相同原因而变化的东西聚合在一起，而把因不同原因而变化的东西分离开来。</li>
<li>微服务的理念应用在独立的服务上。根据业务的边界来确定服务的边界，从而确定某个功能代码应该放在那里。</li>
<li>小-&gt;服务管理难度增加</li>
</ol>
<h4 id="1-1-2-自治性"><a href="#1-1-2-自治性" class="headerlink" title="1.1.2 自治性"></a>1.1.2 自治性</h4><ol>
<li>一个微服务就是一个独立的实体，可以独立部署在PAAS上，作为操作系统独立进程存在。避免将多个服务部署在同一台机器上。通过隔离也会带来一定量的代价，但是能够简化分布式系统的构建。</li>
<li>服务之间均通过网络进行通信，加强了服务之间的隔离性，避免紧耦合。</li>
<li>服务可以彼此间独立进行修改，某一个服务的部署不应该引起服务消费方的变动。对于一个服务来说，需要考虑什么应该暴露，什么应该隐藏。如果暴露过多会造成消费方与服务的内部实现产生耦合，使得服务和消费方之间产生额外的协调工作，从而降低服务的自治性。</li>
<li>服务会暴露出API,然后服务之间通过这些API进行通信。API的实现技术应该避免与消费放耦合，这就意味着应该选择与具体技术不相关的API实现方法，以保证技术的选择不被限制。</li>
<li>如果系统没有很好地解耦，那么一旦出现问题，所有功能都将不可用</li>
</ol>
<h3 id="1-2-主要好处"><a href="#1-2-主要好处" class="headerlink" title="1.2 主要好处"></a>1.2 主要好处</h3><h4 id="1-2-1-技术异构性"><a href="#1-2-1-技术异构性" class="headerlink" title="1.2.1 技术异构性"></a>1.2.1 技术异构性</h4><ol>
<li>一个由多个服务相互协作的系统中，可以在不同的服务中使用最合适改服务的技术。通用的技术不会得到很好的性能。</li>
<li>如果系统中一部分需要做性能提升，可以使用性能更好的技术栈重新构建该部分。<strong>系统中不同部分可以使用不同的数据存储技术，比如社交网络来说，图数据库能够更好地处理用户之间的交互操作，对于用户发布的帖子，使用文档数据库可能更好的选择。异构架构。</strong></li>
<li>微服务可以帮助我们更快地采用新技术，并且理解这些新技术的好处。—&gt;单块降低风险。<h4 id="1-2-2-弹性"><a href="#1-2-2-弹性" class="headerlink" title="1.2.2 弹性"></a>1.2.2 弹性</h4></li>
<li>如果系统中的一个组件不可用了，但并没有导致级联故障，那么系统的其他部分还可以正常运行。服务边界就是一个很显然的舱壁。</li>
<li>在单块系统中，如果服务不可用，那么所有的功能都会不可用，那么对于单块服务的系统而言，可以通过将同样的实例运行在不同的机器上来降低功能完全不可用的概率，微服务本身能够很好地处理服务不可用和功能降级的问题。<h4 id="1-2-3-扩展"><a href="#1-2-3-扩展" class="headerlink" title="1.2.3 扩展"></a>1.2.3 扩展</h4><h4 id="1-2-4-简化部署"><a href="#1-2-4-简化部署" class="headerlink" title="1.2.4 简化部署"></a>1.2.4 简化部署</h4>几百万行的单块应用程序中，即使只修改一行代码也需要重新部署整个应用程序才能发布改变更。<h4 id="1-2-5-与组织结构相匹配"><a href="#1-2-5-与组织结构相匹配" class="headerlink" title="1.2.5 与组织结构相匹配"></a>1.2.5 与组织结构相匹配</h4><h4 id="1-2-6-可组合性"><a href="#1-2-6-可组合性" class="headerlink" title="1.2.6 可组合性"></a>1.2.6 可组合性</h4></li>
<li>单纯考虑桌面网站或者移动应用程序时代过去，现在需要考虑的应用程序包括web，原生应用，移动端web,平板应用以及可穿戴设备等。</li>
<li>在微服务架构中，系统会开放很多接缝供外部使用。当情况发生改变的时候，可以使用不同的方式构建应用，而整体化应用程序只能提供一个非常粗粒度的接缝供外部使用。</li>
</ol>
<h3 id="1-3-面向服务架构"><a href="#1-3-面向服务架构" class="headerlink" title="1.3 面向服务架构"></a>1.3 面向服务架构</h3><pre><code>1.SOA是一种设计方法，其中包含多个服务，服务之间通过配合最终提供一系列功能。服务之间通过网络调用，而非采用进程内调用的方式进行通信。
2.SOA遇到的问题：通信协议的选择，第三方中间件的选择，服务粒度如何确定，如何划分系统。
</code></pre><h2 id="2-演化式架构师"><a href="#2-演化式架构师" class="headerlink" title="2.演化式架构师"></a>2.演化式架构师</h2><h3 id="2-1-不确定的比较"><a href="#2-1-不确定的比较" class="headerlink" title="2.1 不确定的比较"></a>2.1 不确定的比较</h3><pre><code>1. 架构师的职责:确保团队由共同的技术愿景，以帮助我们向客户交付他们想要的系统。
2. 架构师的影响:所构建系统的质量，同事的工作条件，组织应对变化的能力等。
</code></pre><h3 id="2-2-架构师的演化视角"><a href="#2-2-架构师的演化视角" class="headerlink" title="2.2 架构师的演化视角"></a>2.2 架构师的演化视角</h3><pre><code>1. 软件中会面临大量需求变更，使用的工具和技术也具有多样性。必须改掉从一开始就要设计出完美产品的想法，相反应该设计出一个合理的框架，在这个框架下可以慢慢演化出正确的系统。
2. 架构师应该像城市规划师那样专注在大方向上，只有很有限的情况下参与到非常具体的细节实现中来。他们需要保证系统不但能够满足当前需求，还能够应对将来的变化。
</code></pre><h3 id="2-3-分区"><a href="#2-3-分区" class="headerlink" title="2.3 分区"></a>2.3 分区</h3><pre><code>1. 代码架构师---&gt;团队
</code></pre><h3 id="2-4-一个原则性的方法"><a href="#2-4-一个原则性的方法" class="headerlink" title="2.4 一个原则性的方法"></a>2.4 一个原则性的方法</h3><pre><code>做系统设计方面决定通常在于舍取，微服务中需要舍取更多。如数据存储技术，如何带来过呢更好的可伸缩性技术。系统种是否可接受两种技术栈，做某些决策所需要的信息获取。
</code></pre><h4 id="2-4-1-战略目标"><a href="#2-4-1-战略目标" class="headerlink" title="2.4.1 战略目标"></a>2.4.1 战略目标</h4><pre><code>公司的走向 客户的满意程度
</code></pre><h4 id="2-4-2-原则"><a href="#2-4-2-原则" class="headerlink" title="2.4.2 原则"></a>2.4.2 原则</h4><pre><code>目标-&gt;规则。组织上线周期，交付团队应该对整个软件生命周期有完全的控制权。
Heroku的12Factors原则
</code></pre><h4 id="2-4-3-实践"><a href="#2-4-3-实践" class="headerlink" title="2.4.3 实践"></a>2.4.3 实践</h4><pre><code>1. 通过相应的实践来保证与那则能够得到实施，这些实践知道我们如何完成任务。这些实践通常与技术相关，并且较为底层。任何开发人员都能够理解。这些实践包括代码规范，日志数据集中捕获，或者http/rest作为标准集成风格等。
2. 由于偏技术层面，其改变频率会高于原则。
3. 实践有时候会反映出组织内的一些限制。
4. 实践应该巩固原则
</code></pre><h4 id="2-4-4-将原则和实践相结合"><a href="#2-4-4-将原则和实践相结合" class="headerlink" title="2.4.4 将原则和实践相结合"></a>2.4.4 将原则和实践相结合</h4><pre><code>1.Http/Rest作为原则，而不是实践，
</code></pre><h4 id="2-4-5-真实世界的例子"><a href="#2-4-5-真实世界的例子" class="headerlink" title="2.4.5 真实世界的例子"></a>2.4.5 真实世界的例子</h4><h3 id="2-5-要求的标准"><a href="#2-5-要求的标准" class="headerlink" title="2.5 要求的标准"></a>2.5 要求的标准</h3><pre><code>1.系统允许多少可变性
2.我们需要识别出各个服务需要遵守的通用规则
3.给出一个好服务的例子来阐释好服务的特点
</code></pre><h4 id="2-5-1-监控"><a href="#2-5-1-监控" class="headerlink" title="2.5.1 监控"></a>2.5.1 监控</h4><pre><code>1. 能够清晰的描绘服务系统的健康状态非常关键。这是系统级别的而不是单个服务级别进行考虑的。
2. 在需要诊断一个跨服务问题或者想要了解更大趋势时，需要知道每个服务的健康状态。
3. 所有的服务使用相同的方式报告健康状态以及监控相关的数据。
4. 推送机制:每个服务主动把数据推送到某个集中的为止。使用Graphite来收集数据，使用Nagios来检测健康状态。总之尽量标准化。
5. 每个服务内的技术应该对外不透明，并且不要为了服务的具体实现而改变监控系统，日志功能和监控情况类似，需要集中式管理。
</code></pre><h4 id="2-5-2-接口"><a href="#2-5-2-接口" class="headerlink" title="2.5.2 接口"></a>2.5.2 接口</h4><h4 id="2-5-3-架构安全性"><a href="#2-5-3-架构安全性" class="headerlink" title="2.5.3 架构安全性"></a>2.5.3 架构安全性</h4><pre><code>1. 必须保证每个服务都可以应对下游服务的错误请求。
2. 如果下游错误请求的服务堆积，就会使系统脆弱。每个下游服务使用他们自己的连接池，进一步让每个服务使用一个断路器。
3. 返回码应该遵守一定的规则。
</code></pre><h3 id="2-6-代码治理"><a href="#2-6-代码治理" class="headerlink" title="2.6 代码治理"></a>2.6 代码治理</h3><pre><code>提供范例和服务代码模板
</code></pre><h4 id="2-6-1-范例"><a href="#2-6-1-范例" class="headerlink" title="2.6.1 范例"></a>2.6.1 范例</h4><pre><code>1. 编写文档 
2. 代码
</code></pre><h4 id="2-6-2-裁剪服务代码模板"><a href="#2-6-2-裁剪服务代码模板" class="headerlink" title="2.6.2 裁剪服务代码模板"></a>2.6.2 裁剪服务代码模板</h4><h3 id="2-7-技术债务"><a href="#2-7-技术债务" class="headerlink" title="2.7 技术债务"></a>2.7 技术债务</h3><pre><code>1. 为了发布一些紧急的特性，会忽略一些约束。这是另一个需要做的取舍。技术愿景有其本身的道理。
2. 偏离了这个愿景短期内会带来利益，但是长期看来需要付出代价。可以使用技术债务来理解这个取舍。
2. 架构师的职责就是从更高层次触发，理解如何做权衡。理解债务的层次及其对系统的影响非常重要。
3. 架构师应该能够提供一些温和的指导，然后让团队自行决定如何偿还这些技术债务。结构化，维护一个债务列表，定期回顾。
</code></pre><h3 id="2-8-例外管理"><a href="#2-8-例外管理" class="headerlink" title="2.8 例外管理"></a>2.8 例外管理</h3><pre><code>1. 如果系统偏离了原则和实践，就可以针对某个规则破例，然后记录，如果出现多次可以通过修改原则和实践的方式把我们的理解固化下来。
2. 如，在一般情况使用MySQL，在海量存储的场景应该使用**Cassandra**；
3. 于是就可以修改原则，在大多数场景使用MySQL做存储，在数据快速增长的场景，使用Cassandra。
</code></pre><h3 id="2-9-集中治理和领导"><a href="#2-9-集中治理和领导" class="headerlink" title="2.9 集中治理和领导"></a>2.9 集中治理和领导</h3><pre><code>1. 架构师的部分职责是治理，COBIT给出的定义:治理通过评估干系人的需求，当前情况下以及下一步的可能性来确保企业目标的达成，通过排优先级和做决策来设定方向。对于已经达成一致的方向和目标进行监督。
2. 架构师的职责是确保有一个技术愿景，治理就是要确保我们构建的系统符合这个愿景，而且在需要的时候还应对愿景进行演化。 
</code></pre><h2 id="3-如何建模服务"><a href="#3-如何建模服务" class="headerlink" title="3.如何建模服务"></a>3.如何建模服务</h2><h3 id="3-1-MusicCorp简介"><a href="#3-1-MusicCorp简介" class="headerlink" title="3.1 MusicCorp简介"></a>3.1 MusicCorp简介</h3><h3 id="3-2-什么样的服务是好服务"><a href="#3-2-什么样的服务是好服务" class="headerlink" title="3.2 什么样的服务是好服务"></a>3.2 什么样的服务是好服务</h3><h3 id="3-2-1-松耦合"><a href="#3-2-1-松耦合" class="headerlink" title="3.2.1 松耦合"></a>3.2.1 松耦合</h3><pre><code>1. 修改一个服务不需要修改另一个服务。
 2. 使用微服务，能够独立修改及部署单个服务而不需要修改修通的其他部分。
 3. 一个松耦合的服务应该尽可能少的直到与之协作的那些服务的信息。应该限制两个服务之间不同调用形式的数量。不仅是性能还有，过度通信导致的紧耦合。
</code></pre><h3 id="3-2-2-高内聚"><a href="#3-2-2-高内聚" class="headerlink" title="3.2.2 高内聚"></a>3.2.2 高内聚</h3><pre><code>1. 把相关的行为聚集在一起，把不相关的行为放在别处。
2. 如果想改变某个行为，最好能够只在一个地方修改，然后就可以尽快地发布。
3. 如果需要在很多不同的地方修改就需要同时发布多个微服务才能够交付这个功能。
4. 在很多个地方进行修改会很慢，同时部署多个服务风险也高。
5. 找到问题的边界就可以确保相关的行为可以放在同一个地方，并且他们会与其他边界以尽量松耦合的形式进行通信。
</code></pre><h3 id="3-3-限界上下文"><a href="#3-3-限界上下文" class="headerlink" title="3.3 限界上下文"></a>3.3 限界上下文</h3><pre><code>1. 领域驱动设计主要专注如何实现世界的领域进行建模。如通用语言，仓储，抽象等。其中引入了限界上下文文。
2. 任何一个给定的**领域都包含多个限界上下文**，这个上下文中的东西分成2部分，**一部份不需要与外部通信，另一部分则需要。**每个上下文都有明确的接口，该接口决定了它会暴露哪些模型给其他上下文。
3. 另一个限界上下文定义：**一个由显式边界限定的特定职责**，如果想从一个限界上下文中获取信息，或者向其发起请求，需要使用模型和它的显式边界进行通信。、
</code></pre><h4 id="3-3-1-共享的隐藏模型"><a href="#3-3-1-共享的隐藏模型" class="headerlink" title="3.3.1 共享的隐藏模型"></a>3.3.1 共享的隐藏模型</h4><h4 id="3-3-2-模块和服务"><a href="#3-3-2-模块和服务" class="headerlink" title="3.3.2 模块和服务"></a>3.3.2 模块和服务</h4><pre><code>1. 同一个进程内使用模块来减少彼此之间的耦合也是一种选择。
2. 微服务应该清晰地和限界上下文呢保持一致。
</code></pre><h4 id="3-3-3-过早划分"><a href="#3-3-3-过早划分" class="headerlink" title="3.3.3 过早划分"></a>3.3.3 过早划分</h4><h3 id="3-4-业务功能"><a href="#3-4-业务功能" class="headerlink" title="3.4 业务功能"></a>3.4 业务功能</h3><h3 id="3-5-逐步划分上下文"><a href="#3-5-逐步划分上下文" class="headerlink" title="3.5 逐步划分上下文"></a>3.5 逐步划分上下文</h3><pre><code>1. 一开始接触一些粗粒度的限界上下文，这里面可能会包含一些嵌套限界上下文。
2. 当考虑微服务边界时，首先考虑比较大，粗粒度的那些上下文，当发现合适的缝隙后，再进一步划分出且套上下文。
</code></pre><h2 id="4-集成"><a href="#4-集成" class="headerlink" title="4.集成"></a>4.集成</h2><h3 id="4-1-集成技术"><a href="#4-1-集成技术" class="headerlink" title="4.1 集成技术"></a>4.1 集成技术</h3><pre><code>1. SOAP XML-RPC REST Protocol Buffers 
2. 易于使用，隐藏内部实现细节
</code></pre><h3 id="4-2-为用户创建接口"><a href="#4-2-为用户创建接口" class="headerlink" title="4.2 为用户创建接口"></a>4.2 为用户创建接口</h3><h3 id="4-3-共享数据库"><a href="#4-3-共享数据库" class="headerlink" title="4.3 共享数据库"></a>4.3 共享数据库</h3><h3 id="4-4-同步和异步"><a href="#4-4-同步和异步" class="headerlink" title="4.4 同步和异步"></a>4.4 同步和异步</h3><pre><code>1. 请求/响应：客户端发起一个请求，然后等待响应。
2. 异步通信:发起一个请求，然后注册一个回调，当服务端操作结束后，会调用该回调。
3. 基于事件的协作方式，客户端不是发起请求，而是发布一个事件，然后期待其他的协作者接收该消息，并且知道怎么做。
4. 基于事件的系统天生是异步，并且业务逻辑不是集中式的而是平均分布在不同的协作者中。
5. 基于事件的协作方式耦合性很低。客户端发布一个事件，但不需要知道谁或者什么会对此做出响应，也就是说不影响客户端的情况下，对该事件添加新的订阅。
</code></pre><h3 id="4-5-编排与协同"><a href="#4-5-编排与协同" class="headerlink" title="4.5 编排与协同"></a>4.5 编排与协同</h3><pre><code>1. 编排：依赖于某个中心大佬指导并驱动整个流程。
    1.让客户服务作为中心大脑
    2.过于依赖中心大脑
2. 协同：仅仅告知系统中各个部分各自的职责，而具体怎么做的细节留给他们自己，同时也会响应周围其他人。
    1. 协同可以降低系统的耦合度，并且可以更加灵活地对现有系统进行修改。但是需要额外的工作来对业务流程做跨服务的监控。
    2. 同步调用简单，如果想要请求/响应风格的语义，又想避免其在耗时业务上的困境，可以采用异步请求加回调的方式。
    3. 使用异步方式有利于协同方案的实施，从而大大减少服务间的耦合，这是能独立发布服务而追求的特性。
3. 针对请求/响应方式，可以考虑2中技术:RPC和REST
</code></pre><h3 id="4-6-远程过程调用"><a href="#4-6-远程过程调用" class="headerlink" title="4.6 远程过程调用"></a>4.6 远程过程调用</h3><pre><code>1. 允许你进行一个本地调用，但是实际结果由某个远程服务器产生。PRC种类繁多，其中一些依赖于接口定义（SOAP,Thrift,Protocol buffers等）。不同的技术栈可以通过接口定义轻松生成客户端和服务端的桩代码。
2. 用JAVA服务暴露一个SOAP接口，然后使用WSDL定义接口生成.net客户端的代码。
3. 很多技术本质上是二进制的，比如JAVA RMI,Thrift,protocol buffers等，SOAP使用XML作为消息格式。有些RPC实现与特定网络协议相绑定，同时也有不同的协议实现。
4. Tcp能够保证送达，UDP虽然不能保证送达，但是协议开销较小。
</code></pre><h3 id="4-7-REST"><a href="#4-7-REST" class="headerlink" title="4.7 REST"></a>4.7 REST</h3><pre><code>1. Rest是RPC的一种替代方案；
2. 资源，处于服务之内。服务可以根据请求内容创建消费对象的不同表现形式，一个资源的对外显示方式和内部存储方式之间没有耦合。
3. 例如，客户端可能会请求一个customer的json表示形式，而customer内部存储方式可以完全不同。客户端一旦得到该customer得表示，就可以发出请求对其进行修改，而服务器可以选择应答与否。
4. **Richardson的成熟度模型**
5. REST本身没有提及底层的协议，最常用的是http，或者usb，串口等等。
</code></pre><h4 id="4-7-1-Rest和Http"><a href="#4-7-1-Rest和Http" class="headerlink" title="4.7.1 Rest和Http"></a>4.7.1 Rest和Http</h4><pre><code>http的方法get,post可以很好和资源一起使用。Rest架构风格声明了一组对所有资源的标准方法，HTTP恰好也定义了一组方法供使用。GET使用幂等的方式获取资源，Post创建一个新资源。
</code></pre><h4 id="4-7-2-超媒体作为程序状态引擎"><a href="#4-7-2-超媒体作为程序状态引擎" class="headerlink" title="4.7.2 超媒体作为程序状态引擎"></a>4.7.2 超媒体作为程序状态引擎</h4><pre><code>1. 超媒体:有一块内容，该内容包含了指向其他内容的链接，而这些内容的格式可以不同，如文本，图像，声音等。你可以在任何一个网页上看到超媒体控制形式的链接，当你点击时可以看到相关的内容，
2. **Rest实战**
</code></pre><h3 id="4-8-试下基于事件的异步协作方式"><a href="#4-8-试下基于事件的异步协作方式" class="headerlink" title="4.8 试下基于事件的异步协作方式"></a>4.8 试下基于事件的异步协作方式</h3><h4 id="4-8-1-技术选择"><a href="#4-8-1-技术选择" class="headerlink" title="4.8.1 技术选择"></a>4.8.1 技术选择</h4><pre><code>1. 微服务发布事件机制和消费者接收事件机制。尽量让中间件保持简单，把业务逻辑放在自己的服务中。 
2. 使用HTTP来传播
</code></pre><h4 id="4-8-3-异步机构的复杂性"><a href="#4-8-3-异步机构的复杂性" class="headerlink" title="4.8.3 异步机构的复杂性"></a>4.8.3 异步机构的复杂性</h4><pre><code>1. 复杂性：不仅仅是对于消息发布订阅操作，对于非常耗时的异步请求/响应，需要考虑返回时怎么处理。该响应是否回到发送请求那个节点？如果是，节点停止服务怎么办?如果不是，是否需要把信息事先存储到其他地方，以便于做相应处理？
2. 如果API设计得当，短生命周期的异步操作很容易管理。但是需要思维的转换。
3. 灾难性故障转移
</code></pre><h3 id="4-9-服务即状态机"><a href="#4-9-服务即状态机" class="headerlink" title="4.9 服务即状态机"></a>4.9 服务即状态机</h3><h3 id="4-10-响应式扩展"><a href="#4-10-响应式扩展" class="headerlink" title="4.10 响应式扩展"></a>4.10 响应式扩展</h3><h2 id="5-分解单块系统"><a href="#5-分解单块系统" class="headerlink" title="5.分解单块系统"></a>5.分解单块系统</h2><h3 id="5-1-关键是接缝"><a href="#5-1-关键是接缝" class="headerlink" title="5.1 关键是接缝"></a>5.1 关键是接缝</h3><p>1.高内聚，低耦合。<br>2.限界上下文:组织内高内聚和低耦合的边界。</p>
<h3 id="5-2-分解项目"><a href="#5-2-分解项目" class="headerlink" title="5.2 分解项目"></a>5.2 分解项目</h3><ol>
<li>4个上下文<ul>
<li>产品目录：与正在销售商品相关的元数据</li>
<li>财务:账户，支付，退款等项目的报告</li>
<li>仓库:分发客户订单，处理退货，管理仓库等</li>
<li>推荐：推荐算法</li>
</ul>
</li>
<li>创建包结构来表示上下文，用IDE重构功能来自动完成代码移动。<h3 id="5-3-分解单块系统的原因"><a href="#5-3-分解单块系统的原因" class="headerlink" title="5.3 分解单块系统的原因"></a>5.3 分解单块系统的原因</h3></li>
<li>改变的速度</li>
<li>团队结构</li>
<li>安全</li>
<li>技术</li>
<li>依赖</li>
<li>数据库</li>
<li>找到问题的关键<h3 id="5-4-事务边界"><a href="#5-4-事务边界" class="headerlink" title="5.4 事务边界"></a>5.4 事务边界</h3></li>
<li>事务:要么全部做完，要么什么都不变。 </li>
<li>重试</li>
<li>快速失败</li>
<li>分布式事务<ol>
<li>事务管理器</li>
<li>事务运行在不同的进程种，通过网络进行通信</li>
<li>二阶段提交：投票阶段，很容易让所有参与者都等待中央协调进行的指令，从而容易导致系统中断。<h3 id="5-5-通过服务调用来获取数据"><a href="#5-5-通过服务调用来获取数据" class="headerlink" title="5.5 通过服务调用来获取数据"></a>5.5 通过服务调用来获取数据</h3><h3 id="5-6-数据导出"><a href="#5-6-数据导出" class="headerlink" title="5.6 数据导出"></a>5.6 数据导出</h3><h2 id="6-部署"><a href="#6-部署" class="headerlink" title="6.部署"></a>6.部署</h2><h3 id="6-1-持续集成"><a href="#6-1-持续集成" class="headerlink" title="6.1 持续集成"></a>6.1 持续集成</h3></li>
</ol>
</li>
<li>CI能够保证新提交的代码与已有代码进行集成，从而让所有人保持同步。CI服务器会检测到代码已提交并签出，然后花些时间来验证代码是否通过编译以及测试是否通过。</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/28/Sentinel系列之起源/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/28/Sentinel系列之起源/" itemprop="url">
                  Sentinel系列之起源
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-28 09:24:02 / Updated at: 11:02:44" itemprop="dateCreated datePublished" datetime="2018-08-28T09:24:02+08:00">2018-08-28</time>
            

            
              

              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-什么是Sentinel"><a href="#1-什么是Sentinel" class="headerlink" title="1.什么是Sentinel"></a>1.什么是Sentinel</h2><blockquote>
<p>i.分布式系统的流量防卫兵；<br><br>ii.微服务架构中，服务与服务之间的稳定性变得越来越重要。Sentinel以流量为切入点，从流控，熔断，降级，系统负载保护等多个维度来提供服务稳定性支持；<br>iii.轻量级。</p>
</blockquote>
<h2 id="2-Sentinel功能"><a href="#2-Sentinel功能" class="headerlink" title="2.Sentinel功能"></a>2.Sentinel功能</h2><blockquote>
<p>i.流控，针对秒杀环境，对于突发流量可以控制在系统承受范围内；<br><br>ii.削峰填谷;<br><br>iii.实时熔断下游不可用应用;<br><br>iv.完备的监控功能:提供实时的监控功能，可以精确到秒级数据；<br><br>v.Sentinel提供简易的扩展点，快速定制逻辑，例如定制规则管理，适配数据源。</p>
</blockquote>
<h2 id="3-核心架构"><a href="#3-核心架构" class="headerlink" title="3.核心架构"></a>3.核心架构</h2><pre><code>核心库:不依赖任何框架/库，能够运行于所有java运行时环境，对Dubbo/Spring Cloud等框架有较好的支持。
控制台:基于SpringBoot开发，打包后直接运行，不需要额外的Tomcat应用容器。
</code></pre><h2 id="4-基本概念"><a href="#4-基本概念" class="headerlink" title="4.基本概念"></a>4.基本概念</h2><h3 id="4-1-资源"><a href="#4-1-资源" class="headerlink" title="4.1 资源"></a>4.1 资源</h3><ol>
<li>资源是Sentinel的关键概念，可以是APP中的任意内容。如由应用程序提供的服务，或者由应用程序调用的其他应用提供的服务，或者一段代码。</li>
<li>只要通过Sentinel API定义的代码就是资源，能够被Sentinel保护起来。通常使用方法签名，URL，甚至服务名称作为资源名来标识资源。<h3 id="4-2-规则"><a href="#4-2-规则" class="headerlink" title="4.2 规则"></a>4.2 规则</h3>围绕资源的实时状态设定的规则，可以包括流量控制规则，熔断降级规则以及系统保护规则。所有规则可以动态实时调整。</li>
</ol>
<h2 id="5-Sentinel功能合设计理念"><a href="#5-Sentinel功能合设计理念" class="headerlink" title="5.Sentinel功能合设计理念"></a>5.Sentinel功能合设计理念</h2><h3 id="5-1-流量控制"><a href="#5-1-流量控制" class="headerlink" title="5.1 流量控制"></a>5.1 流量控制</h3><p><strong>1.</strong> <strong>什么是流量控制</strong></p>
<blockquote>
<p>流控是网络传输中的常用概念，用于调整网络包的发送数据。<br><br>流控的目的是从系统的稳定性角度来考虑的，在处理请求的速度上，有很多讲究。<br><br>任意时间到来的请求是随机不可控的，但是系统的处理能力有限，需要根据系统的能力进行流控。<br><br>Sentinel作为一个适配器，可以根据需要把随机请求调整成合适的形状。<br></p>
</blockquote>
<p><strong>2.流控设计理念</strong><br></p>
<blockquote>
<p>资源的调用关系，例如资源的调用链路，资源和资源之间的关系。<br><br>运行指标，如QPS,线程池,系统负载等。<br><br>控制效果，如直接限流，冷启动，排队等。<br><br><strong>Sentinel的设计理念是，自由选择控制的角度，进行灵活组合，达到想要的效果。</strong></p>
</blockquote>
<h3 id="5-2-熔断降级"><a href="#5-2-熔断降级" class="headerlink" title="5.2 熔断降级"></a>5.2 熔断降级</h3><p><strong>1.什么是熔断降级</strong></p>
<blockquote>
<p>核心还是保护系统稳定性，降低调用链路中的不稳定资源。由于调用关系的复杂性，如果链路中的部分资源不稳定，最终会导致请求发生堆积。<br><br>Sentinel和Hystrix原则一致：当调用链路中某个资源出现不稳定，例如表现timeout，异常比例升高的时候，则对这个资源调用进行限制，<strong>让某个请求快速失败</strong>，避免影响到其他资源，最终产生雪崩的效果。<br></p>
</blockquote>
<p><strong>2.熔断降级的设计理念</strong></p>
<blockquote>
<ul>
<li>限制手段上，Sentinel和HyStrix采取不同的方法；HyStrix通过线程池的方式，来依赖(在我们的概念中对应资源)进行了隔离。这样的好处是对资源和资源之间进行彻底的隔离。缺点是增加了线程切换的成本，还需要预留资源给各个线程池大小的分配。<br></li>
<li>Sentinel对于这个问题采用了两种手段：<br><ol>
<li>通过并发线程数进行限制:通过限制资源并发线程数量，来减少不稳定资源对其他资源的影响，这样没有线程切换的损耗，也不需要预先分配线程池的大小。当某个资源出现不稳定的情况下，如响应时间变长，对资源的直接影响是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定数量之后，该资源的新请求就会被拒绝，堆积的线程完成后才开始接收请求。</li>
<li>通过响应时间对资源进行降级：除了对并发线程数进行控制意外，Sentinel还可以通过响应时间来快速降级不稳定资源，当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定时间窗口后才重新恢复。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="5-3-系统的过载保护"><a href="#5-3-系统的过载保护" class="headerlink" title="5.3 系统的过载保护"></a>5.3 系统的过载保护</h2><pre><code>系统入口流量和系统的负载达到一个平衡，保证系统在能力范围之内处理更多的请求。
</code></pre><h2 id="6-Sentinel是如何工作的"><a href="#6-Sentinel是如何工作的" class="headerlink" title="6.Sentinel是如何工作的"></a>6.Sentinel是如何工作的</h2><pre><code>1. 对主流框架提供适配或者显示的API，来定义需要保护的资源，并提供设施对资源进行实时统计和调用链路分析。
2. 根据预设的规则，结合对资源的实时统计信息，对流量进行控制。同时，Sentinel提供开放的接口，方便定义和改变规则。
3. Sentinel提供实时的监控系统，方便快速了解当前系统的状态。 
</code></pre>
          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/20/Druid源码解析之数据库连接池总论/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Rocky ZhouJin QQ987415811">
      <meta itemprop="description" content="个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rocky for Everything">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/20/Druid源码解析之数据库连接池总论/" itemprop="url">
                  Druid源码解析之数据库连接池总论
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Post created: 2018-08-20 18:17:52" itemprop="dateCreated datePublished" datetime="2018-08-20T18:17:52+08:00">2018-08-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">Edited on</span>
                
                <time title="Updated at: 2018-08-21 16:12:19" itemprop="dateModified" datetime="2018-08-21T16:12:19+08:00">2018-08-21</time>
              
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-应用程序直接获取数据连接的缺点"><a href="#1-应用程序直接获取数据连接的缺点" class="headerlink" title="1.应用程序直接获取数据连接的缺点"></a>1.应用程序直接获取数据连接的缺点</h2><ol>
<li>用户每次请求都需要向数据库获得连接，数据库创建连接通常需要消耗大量资源，创建时间也较长。</li>
<li>大量得创建极大浪费数据库得资源，并且极易造成数据库服务器内存溢出，宕机。、</li>
</ol>
<h2 id="2-使用数据库连接池优化程序性能"><a href="#2-使用数据库连接池优化程序性能" class="headerlink" title="2.使用数据库连接池优化程序性能"></a>2.使用数据库连接池优化程序性能</h2><ol>
<li>数据库连接池的概念<ol>
<li>数据库连接是一种关键得有限得昂贵得资源，咋多用户网页程序中体现尤为突出。</li>
<li>对数据库连接的管理能力显著影响到整个应用程序的伸缩性和健壮性，影响到程序的性能指标。</li>
<li>数据库连接池负责分配，管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个。</li>
<li>数据库连接池在初始化时将创建一定数量的数据库连接池放到连接池中，这些数据库连接的数量由最小数据库连接数来设定。无论这些数据库连接是否被使用，连接池都将保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求连接数超过最大连接数量时，这些请求将会被加入到等待队列中。</li>
<li>数据库连接池的最小连接数和最大连接数的设置需要考虑一下几个因素：<ol>
<li>最小连接数:是连接池一直保持的数据库连接，所以如果应用程序对数据库连接使用量不大，将会有大量数据库连接资源被浪费；</li>
<li>最大连接数:是连接池能申请的最大连接数，如果数据库连接请求超过次数，后面的数据库连接请求将被加入到等待队列中，这会影响到以后的数据库操作。</li>
</ol>
</li>
</ol>
</li>
<li>编写数据库连接池<ol>
<li>实现java.sql.DataSource接口,DataSource接口定义了两个重载的getConnection方法:<ol>
<li>Connection getConnection();</li>
<li>Connection getConnection(String username, String password);</li>
</ol>
</li>
<li>实现DataSource接口，并实现连接池功能的步骤：<ol>
<li>在DataSource构造函数中批量创建与数据库的连接，并把创建的连接加入LinkedList对象中；</li>
<li>实现getConnection方法，让getConnection方法每次调用时，从LinkedList中去一个Connection返回给用户；</li>
<li>当用户使用完Connection,调用Connection.close()方法时，Collection对象应保证自己返回到LinkedList中，而不是把conn还给数据库。<strong>Collection保证将自己返回到LinkedList中</strong>；</li>
</ol>
</li>
<li>部分核心代码<br> `proxyConn = (Connection) Proxy.newProxyInstance(this.getClass().getClassLoader(),conn.getClass().getInterfaces(),new InvocationHandler(){<pre><code>public Object invoke(Object proxy,Method method,Object[] args) {
    if(method.getName().equals(&quot;close&quot;)) {
        pool.addLast(conn);
        return null;
    }
    return method.invoke(conn,args);
}
</code></pre> })` </li>
</ol>
</li>
<li>开源数据库连接池<ol>
<li>很多WEB服务器都提供了DataSource的实现，即连接池的实现。把DataSource的实现，按其英文含义称之为数据源，数据源中包含了数据库连接池的实现。</li>
<li>DBCP C3P0 使用了数据库连接池，就不需要在编写连接数据库代码了，直接从数据源获得数据库的连接。</li>
<li>DBCP数据源:tomcat采用该连接池</li>
<li>C3P0数据源:dbcp没有自动回收空闲连接的功能，c3p0有自动回收空闲连接功能</li>
<li>Tomcat数据源</li>
</ol>
</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Rocky ZhouJin QQ987415811</p>
              <p class="site-description motion-element" itemprop="description">个人笔记和学习网站，欢迎大家交流，rockyzjin@formail.com</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">31</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">Tags</span>
                  
                </div>
              
            </nav>
          

          

          

          
          

          
          

          
            
          
          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rocky ZhouJin QQ987415811</span>

  

  
</div>




  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> v3.7.1</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme – <a class="theme-link" target="_blank" href="https://theme-next.org">NexT.Muse</a> v6.3.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    
	
    

    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.3.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.3.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.3.0"></script>



  



  










  





  

  

  

  

  
  

  

  

  

  

  

</body>
</html>
